Id,Status,Situation,Criteria,Justification,Title,Abstract,Main Topic,Method,Authors,Venue,Year,Venue Type,DOI,Link,Downloaded,Keywords
S1,Read,Accepted,[IC1] - The primary study presents or points to a software artifact that automates a task within at least one TD management activity.,,Identification of refused bequest code smells,"Accumulated technical debt can be alleviated by means of refactoring application aiming at architectural improvement. A prerequisite for wide scale refactoring application is the automated identification of the corresponding refactoring opportunities, or code smells. One of the major architectural problems that has received limited attention is the so called 'Refused Bequest' which refers to inappropriate use of inheritance in object-oriented systems. This code smell occurs when subclasses do not take advantage of the inherited behavior, implying that replacement by delegation should be used instead. In this paper we propose a technique for the identification of Refused Bequest code smells whose major novelty lies in the intentional introduction of errors in the inherited methods. The essence of inheritance is evaluated by exercising the system's functionality through the corresponding unit tests in order to reveal whether inherited methods are actually employed by clients. Based on the results of this approach and other structural information, an indication of the smell strength on a 'thermometer' is obtained. The proposed approach has been implemented as an Eclipse plugin. © 2013 IEEE.",Smells,Tool,"Ligu, E. and Chatzigeorgiou, A. and Chaikalis, T. and Ygeionomakis, N.","IEEE International Conference on Software Maintenance, ICSM","2,013.00",Conference Paper,10.1109/ICSM.2013.55,https://www.scopus.com/inward/record.uri?eid=2-s2.0-84891703020&doi=10.1109%2fICSM.2013.55&partnerID=40&md5=bf2f683b69d141c10b6e19556c5d4d8b,No,Code smell;  Refactoring;  Refused Bequest;  Software maintenance
S2,Read,Accepted,[IC1] - The primary study presents or points to a software artifact that automates a task within at least one TD management activity.,,"A multiple case study of design pattern decay, grime, and rot in evolving software systems","Software designs decay as systems, uses, and operational environments evolve. Decay can involve the design patterns used to structure a system. Classes that participate in design pattern realizations accumulate grime-non-pattern-related code. Design pattern realizations can also rot, when changes break the structural or functional integrity of a design pattern. Design pattern rot can prevent a pattern realization from fulfilling its responsibilities, and thus represents a fault. Grime buildup does not break the structural integrity of a pattern but can reduce system testability and adaptability. This research examined the extent to which software designs actually decay, rot, and accumulate grime by studying the aging of design patterns in three successful object-oriented systems. We generated UML models from the three implementations and employed a multiple case study methodology to analyze the evolution of the designs. We found no evidence of design pattern rot in these systems. However, we found considerable evidence of pattern decay due to grime. Dependencies between design pattern components increased without regard for pattern intent, reducing pattern modularity, and decreasing testability and adaptability. The study of decay and grime showed that the grime that builds up around design patterns is mostly due to increases in coupling. © 2012 Springer Science+Business Media, LLC.",TD Symptoms/Consequences,Case Study,"Izurieta, C. and Bieman, J.M.",Software Quality Journal,"2,013.00",Article,10.1007/s11219-012-9175-x,https://www.scopus.com/inward/record.uri?eid=2-s2.0-84875478113&doi=10.1007%2fs11219-012-9175-x&partnerID=40&md5=51d1796a2db69b0fa54f5d8fb34bfe0e,No,Decay;  Design concepts;  Design patterns;  Grime;  Multiple case study;  Object-oriented design methods;  Software evolution;  Technical debt
S4,Read,Accepted,[IC1] - The primary study presents or points to a software artifact that automates a task within at least one TD management activity.,,Visualizing and managing technical debt in agile development: An experience report,"This paper reports the experience of an architecture team of a software development department with 25 agile teams in supporting technical decisions regarding technical practices. The main motivation to use technical debt metaphor was its acknowledged potential in driving software development and maintenance decisions, especially those long term maintenance tradeoffs which are usually less visible to developers and decision makers in general. We propose the use of a ""technical debt board"" with main technical debt categories to manage and visualize the high-level debt, combined with tools to measure it at low-level (software metrics and other kind of static analysis). We have found that our approach improved the teams’ awareness about the technical debt, stimulated a beneficial competition between teams towards the debt payment and enhanced the communication regarding technical decisions. © Springer-Verlag Berlin Heidelberg 2013.",Technical Debt,Experience Report,"dos Santos, P.S.M. and Varella, A. and Dantas, C.R. and Borges, D.B.",Lecture Notes in Business Information Processing,"2,013.00",Conference Paper,10.1007/978-3-642-38314-4_9,https://www.scopus.com/inward/record.uri?eid=2-s2.0-84979538124&doi=10.1007%2f978-3-642-38314-4_9&partnerID=40&md5=866c1da990d6155f2e75038fc7098d65,No,Agile practices;  Software quality;  Technical debt;  Visualization
S16,Read,Accepted,[IC1] - The primary study presents or points to a software artifact that automates a task within at least one TD management activity.,,Integrating technical debt into MDE,"The main goal of this work is to evaluate the feasibility to calculate the technical debt (a traditional software quality approach) in a model-driven context through the same tools used by software developers at work. The SonarQube tool was used, so that the quality check was performed directly on projects created with Eclipse Modeling Framework (EMF) instead of traditionals source code projects. In this work, XML was used as the model specification language to verify in Sonar-Qube due to the creation of EMF metamodels in XMI (XML Metadata Interchange) and that SonarQube offers a plugin to assess the XML language. After this, our work focused on the definition of model rules as an XSD schema (XML Schema Definition) and the integration between EMF-SonarQube in order that these metrics were directly validated by SonarQube; and subsequently, this tool determined the technical debt that the analyzed EMF models could contain.",Technical Debt,Case Study,"Giraldo, F.D. and España, S. and Pineda, M.A. and Giraldo, W.J. and Pastor, O.",CEUR Workshop Proceedings,"2,014.00",Conference Paper,,https://www.scopus.com/inward/record.uri?eid=2-s2.0-84924351316&partnerID=40&md5=038ecd86e2bcb5d206902c1f23c88d16,No,EMF;  Model-driven engineering;  SonarQube;  Technical debt
S9,Read,Accepted,[IC1] - The primary study presents or points to a software artifact that automates a task within at least one TD management activity.,,Comparing four approaches for technical debt identification,"Software systems accumulate technical debt (TD) when short-term goals in software development are traded for long-term goals (e.g., quick-and-dirty implementation to reach a release date versus a well-refactored implementation that supports the long-term health of the project). Some forms of TD accumulate over time in the form of source code that is difficult to work with and exhibits a variety of anomalies. A number of source code analysis techniques and tools have been proposed to potentially identify the code-level debt accumulated in a system. What has not yet been studied is if using multiple tools to detect TD can lead to benefits, that is, if different tools will flag the same or different source code components. Further, these techniques also lack investigation into the symptoms of TD “interest” that they lead to. To address this latter question, we also investigated whether TD, as identified by the source code analysis techniques, correlates with interest payments in the form of increased defect- and change-proneness. Comparing the results of different TD identification approaches to understand their commonalities and differences and to evaluate their relationship to indicators of future TD “interest.” We selected four different TD identification techniques (code smells, automatic static analysis issues, grime buildup, and Modularity violations) and applied them to 13 versions of the Apache Hadoop open source software project. We collected and aggregated statistical measures to investigate whether the different techniques identified TD indicators in the same or different classes and whether those classes in turn exhibited high interest (in the form of a large number of defects and higher change-proneness). The outputs of the four approaches have very little overlap and are therefore pointing to different problems in the source code. Dispersed Coupling and Modularity violations were co-located in classes with higher defect-proneness. We also observed a strong relationship between Modularity violations and change-proneness. Our main contribution is an initial overview of the TD landscape, showing that different TD techniques are loosely coupled and therefore indicate problems in different locations of the source code. Moreover, our proxy interest indicators (change- and defect-proneness) correlate with only a small subset of TD indicators. © 2013, Springer Science+Business Media New York.",Technical Debt,Case Study,"Zazworka, N. and Vetro’, A. and Izurieta, C. and Wong, S. and Cai, Y. and Seaman, C. and Shull, F.",Software Quality Journal,"2,014.00",Article,10.1007/s11219-013-9200-8,https://www.scopus.com/inward/record.uri?eid=2-s2.0-84928169106&doi=10.1007%2fs11219-013-9200-8&partnerID=40&md5=0ca77046cb825627495cf14aba1d3991,No,ASA;  Code smells;  Grime;  Modularity violations;  Software maintenance;  Software quality;  Source code analysis;  Technical debt
S29,Read,Accepted,[IC1] - The primary study presents or points to a software artifact that automates a task within at least one TD management activity.,,(Automated) software modularization using community detection,"The modularity of a software system is known to have an effect on, among other, development effort, change impact, and technical debt. Modularizing a specific system and evaluating this modularization is, however, challenging. In this paper, we apply community detection methods to the graph of class dependencies in software systems to find optimal modularizations through communities. We evaluate this approach through a study of 111 Java systems contained in the Qualitas Corpus. We found that using the modularity function of Newman with an Erdős-Rényi null-model and using the community detection algorithm of Reichardt and Bornholdt improved community quality for all systems, that coupling decreased for 99 of the systems, and that coherence increased for 102 of the systems. Furthermore, the modularity function correlates with existing metrics for coupling and coherence. © Springer International Publishing Switzerland 2015.",TD Symptoms/Consequences,Tool,"Hansen, K.M. and Manikas, K.",IFIP Advances in Information and Communication Technology,"2,015.00",Conference Paper,10.1007/978-3-319-23727-5_8,https://www.scopus.com/inward/record.uri?eid=2-s2.0-84951144543&doi=10.1007%2f978-3-319-23727-5_8&partnerID=40&md5=7232daaf4d84c16dddd07cd99793e5ff,No,Module structure;  Software architecture;  Software modularity
S38,Read,Accepted,[IC1] - The primary study presents or points to a software artifact that automates a task within at least one TD management activity.,,Assessing the Effectiveness of Static Analysis through Defect Correlation Analysis,"Assessment of code and design quality using Software Code Assessment tools is important for continuous improvement and monitoring of code quality in the software industry in general and for global software development in particular. Static Analysis is believed to help identify issues at an early stage in the software development life cycle (SDLC), however it is still under utilized in the industry. In this paper, we discuss our experiences in determining the importance of Static Analysis and the extent to which the defects (that could otherwise be slipped to later stages of SDLC) could have been reduced with the continuous use of Static Analysis. Towards this end, we have performed analysis of defects reported from testing/field by correlating the defects to Static Analysis Rules, for projects that were developed across different regions. Our focus was to gather insight into the number and type of defects that could be identified in advance through Static Analysis Rules. The purpose of gaining the insights is to justify the ROI for software quality checks, fine tune, update existing software quality practices and introduce new practices uniformly across the teams as necessary. The results substantiate the role of Static Analysis in reducing technical debt by identifying potential defects early in the SDLC. © 2015 IEEE.",TD Symptoms/Consequences,Experience Report,"Venkatasubramanyam, R.D. and Gupta, S. and Uppili, U.","Proceedings - 2015 IEEE 10th International Conference on Global Software Engineering, ICGSE 2015","2,015.00",Conference Paper,10.1109/ICGSE.2015.18,https://www.scopus.com/inward/record.uri?eid=2-s2.0-84957873187&doi=10.1109%2fICGSE.2015.18&partnerID=40&md5=26bf00c52b0b3a12499dd733cb3258b5,No,defect analysis;  defect correlation;  software code quality;  software product quality;  static analysis
S27,Read,Accepted,[IC1] - The primary study presents or points to a software artifact that automates a task within at least one TD management activity.,,Conciliating model-driven engineering with technical debt using a quality framework,"The main goal of this work is to evaluate the feasibility to calculate the technical debt (a traditional software quality approach) in a model-driven context through the same tools used by software developers at work. The SonarQube tool was used, so that the quality check was performed directly on projects created with Eclipse Modeling Framework (EMF) instead of traditionals source code projects. In this work, XML was used as the model specification language to verify in Sonar- Qube due to the creation of EMF metamodels in XMI (XML Metadata Interchange) and that SonarQube offers a plugin to assess the XML language. After this, our work focused on the definition of model rules as an XSD schema (XML Schema Definition) and the integration between EMF-SonarQube in order that these metrics were directly validated by SonarQube; and subsequently, this tool determined the technical debt that the analyzed EMF models could contain. © Springer International Publishing Switzerland 2015.",Technical Debt,Case Study,"Giraldo, F.D. and España, S. and Pineda, M.A. and Giraldo, W.J. and Pastor, O.",Lecture Notes in Business Information Processing,"2,015.00",Conference Paper,10.1007/978-3-319-19270-3_13,https://www.scopus.com/inward/record.uri?eid=2-s2.0-84946415372&doi=10.1007%2f978-3-319-19270-3_13&partnerID=40&md5=529c0a2cb556c966d08f0b9544d65389,No,EMF;  Model-driven engineering;  SonarQube;  Technical debt
S66,Read,Accepted,[IC1] - The primary study presents or points to a software artifact that automates a task within at least one TD management activity.,,JSpIRIT: A flexible tool for the analysis of code smells,"Code smells are a popular mechanism to identify structural design problems in software systems. Since it is generally not feasible to f x all the smells arising in the code, some of them are often postponed by developer s to be resolved in the future. One reason for this decision is that the improvement of the code structure, to achieve modifability goals, requires extra effort from developer s. Therefore, they might not always spend this additional effort, particularly when they are focused on delivering customer-visible features. This postponement of code smells are seen as a source of technical debt. Furthermore, not all the code smells may be urgent to f x in the context of the system's modifability and business goals. While there are a number of tools to detect smells, they do not allow developer s to discover the most urgent smells according to their goals. In this article, we present a fexible tool to prioritize technical debt in the form of code smells. The tool is fexible to allow developer s to add new smell detection strategies and to prioritize smells, and groups of smells, based on the confguration of their manifold criteria. To illustrate this fexibility, we present an application example of our tool. The results suggest that our tool can be easily extended to be aligned with the developer's goals. © 2015 IEEE.",Smells,Tool,"Vidal, S. and Vazquez, H. and Diaz-Pace, J.A. and Marcos, C. and Garcia, A. and Oizumi, W.","Proceedings - International Conference of the Chilean Computer Science Society, SCCC","2,016.00",Conference Paper,10.1109/SCCC.2015.7416572,https://www.scopus.com/inward/record.uri?eid=2-s2.0-84963765824&doi=10.1109%2fSCCC.2015.7416572&partnerID=40&md5=60c8c22f1ef0ffc4da831beed02748d7,No,
S79,Read,Accepted,[IC1] - The primary study presents or points to a software artifact that automates a task within at least one TD management activity.,,Designite - A software design quality assessment tool,"Poor design quality and huge technical debt are common issues perceived in real-life software projects. Design smells are indicators of poor design quality and the volume of design smells found could be treated as the design debt of the software system. The existing smell detection tools focus largely on implementation smells and do not reveal a comprehensive set of smells that arise at design level. In this paper, we present Designite - a software design quality assessment tool. It not only supports comprehensive design smells detection but also provides a detailed metrics analysis. Further, it offers various features to help identify issues contributing to design debt and improve the design quality of the analyzed software system. © 2016 ACM.",Smells,Tool,"Sharma, T. and Mishra, P. and Tiwari, R.","Proceedings - 1st International Workshop on Bringing Architectural Design Thinking Into Developers' Daily Activities, Bridge 2016","2,016.00",Conference Paper,10.1145/2896935.2896938,https://www.scopus.com/inward/record.uri?eid=2-s2.0-84974622642&doi=10.1145%2f2896935.2896938&partnerID=40&md5=1d1ba425177c0704407cab048957516f,No,Design debt;  Design smells;  DSM;  Refactoring;  Technical debt
S82,Read,Accepted,[IC1] - The primary study presents or points to a software artifact that automates a task within at least one TD management activity.,,An experience report on detecting and repairing software architecture erosion,"Architecture erosion constitutes the most visible effect of the degradation of design. It is a major reason to address the design debt, often caused by architectural mismatch problems. Today, the identification of design erosion is a major concern for designers and software maintainers. Adequate tools are necessary to identify and repair the debt. This paper describes our experience on identifying architectural erosion problems on existing open source software applications through the support of two well known tools. Moreover, we outline if the tools provide useful hints in repairing some of the detected problems. © 2016 IEEE.",TD Symptoms/Consequences,Tool,"Fontana, F.A. and Roveda, R. and Zanoni, M. and Raibulet, C. and Capilla, R.","Proceedings - 2016 13th Working IEEE/IFIP Conference on Software Architecture, WICSA 2016","2,016.00",Conference Paper,10.1109/WICSA.2016.37,https://www.scopus.com/inward/record.uri?eid=2-s2.0-84983320450&doi=10.1109%2fWICSA.2016.37&partnerID=40&md5=46a6d5e499d089006b06ed2568cc31b9,No,
S76,Read,Accepted,[IC1] - The primary study presents or points to a software artifact that automates a task within at least one TD management activity.,,Tool support for evaluating architectural debt of an existing system: An experience report,"During software development, maintenance and evolution, we can assess the quality of code, design and architecture to capture hints of possible problems and face them as soon as possible. We can capture signals of architecture erosion in different ways by exploiting several tools with the aim to identify architectural violations, architectural smells or other relevant features. In this paper, we provide our experience report in using three known tools to capture information that can be useful to identify and evaluate the architectural debt of an application. We outline the main differences among these tools and the results they produce. © 2016 ACM.",Technical Debt,Tool,"Fontana, F.A. and Roveda, R. and Zanoni, M.",Proceedings of the ACM Symposium on Applied Computing,"2,016.00",Conference Paper,10.1145/2851613.2851963,https://www.scopus.com/inward/record.uri?eid=2-s2.0-84975824272&doi=10.1145%2f2851613.2851963&partnerID=40&md5=7b63365315c9596f33d6e670e3ffcf93,No,Architectural debt;  Architecture assessment;  Tool experimentation
S85,Read,Accepted,[IC1] - The primary study presents or points to a software artifact that automates a task within at least one TD management activity.,,Technical debt reduction using search based automated refactoring,"Software refactoring has been recognized as a valuable process during software development and is often aimed at repaying technical debt. Technical debt arises when a software product has been built or amended without full care for structure and extensibility. Refactoring is useful to keep technical debt low and if it can be automated there are obvious efficiency benefits. Using a combination of automated refactoring techniques, software metrics and metaheuristic searches, an automated refactoring tool can improve the structure of a software system without affecting its functionality. In this paper, four different refactoring approaches are compared using an automated software refactoring tool. Weighted sums of metrics are used to form different fitness functions that drive the search process towards certain aspects of software quality. Metrics are combined to measure coupling, abstraction and inheritance and a fourth fitness function is proposed to measure reduction in technical debt. The 4 functions are compared against each other using 3 different searches on 6 different open source programs. Four out of the 6 programs show a larger improvement in the technical debt function after the search based refactoring process. The results show that the technical debt function is useful for assessing improvement in quality. © 2016 Elsevier Inc.",Technical Debt,Tool,"Mohan, M. and Greer, D. and McMullan, P.",Journal of Systems and Software,"2,016.00",Article,10.1016/j.jss.2016.05.019,https://www.scopus.com/inward/record.uri?eid=2-s2.0-84969523698&doi=10.1016%2fj.jss.2016.05.019&partnerID=40&md5=07eba65643d86978f95d37848a0257a0,No,Automated refactoring;  Refactoring tools;  Search based software engineering;  Simulated annealing;  Software metrics;  Technical debt
S88,Read,Accepted,[IC1] - The primary study presents or points to a software artifact that automates a task within at least one TD management activity.,,Technical Debt Indexes Provided by Tools: A Preliminary Discussion,"In software maintenance and evolution, it is important to assess both code and architecture in order to identify issues to be solved to improve software quality. Different tools provide some kind of index giving us an overall evaluation of a project to be used when managing its technical debt. In this paper, we outline how the indexes, that we call in general Technical Debt Indexes, provided by five different tools are computed. We describe their principal features and differences, what aspects they are missing, and we outline if (and how) the indexes take into account architectural problems that could have a major impact on the architectural debt. We show that the indexes rely on different information sources and measure different quantities. © 2016 IEEE.",Technical Debt,Tool,"Fontana, F.A. and Roveda, R. and Zanoni, M.","Proceedings - 2016 IEEE 8th International Workshop on Managing Technical Debt, MTD 2016","2,016.00",Conference Paper,10.1109/MTD.2016.11,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85010711619&doi=10.1109%2fMTD.2016.11&partnerID=40&md5=81015e08d5566c37bcc3a7fd0dc6d3ab,No,Architectural Debt;  Software Quality Analysis Tools;  Technical Debt Indexes
S67,Read,Accepted,[IC1] - The primary study presents or points to a software artifact that automates a task within at least one TD management activity.,,Pragmatic approach for managing technical debt in legacy software project,"Tackling the issues of technical debt in a large system in parallel with continuing to enable it to evolve is a challenging problem. In this paper, we are describing a case study of managing technical debt on a legacy project referred here as Global Configurator Project (GCP) using pragmatic approach. The paper presents holistic lifecycle approach with four stages and various practices in each stage for managing technical debt. Given life cycle approach and practices will be useful for any software project. In particular, these practices will be significant to any legacy project towards repaying debt. These methods can also be applied to continuously improve code quality and product quality. This paper also focus on technical debt user stories to gain business buy-in and share few 'best in market' tools that we used in repaying technical debt. It also focuses on sensitizing developers to the concept of debt and improving their skills. This paper describes the process used by a separate team formed to reduce technical debt in a large legacy system. The paper targets to the Project Managers, Test Managers architects and Scrum Masters in agile software development. © 2016 ACM.",Technical Debt,Theoretical Artifact,"Gupta, R.K. and Manikreddy, P. and Naik, S. and Arya, K.",ACM International Conference Proceeding Series,"2,016.00",Conference Paper,10.1145/2856636.2856655,https://www.scopus.com/inward/record.uri?eid=2-s2.0-84976633741&doi=10.1145%2f2856636.2856655&partnerID=40&md5=f3a0f1ddeebc44e1ba6644a2b11f1ded,No,Code quality;  Lifecycle approach;  Pragmatic;  Product quality;  Static analysis;  Technical debt
S59,Read,Accepted,[IC1] - The primary study presents or points to a software artifact that automates a task within at least one TD management activity.,,Technical debt prioritization using predictive analytics,"Recently, Technical Debt (TD) has gained popularity in the Software Engineering community to describe design decisions that allow software development teams to achieve short term benefits such as expedited release of code. Technical debt accrued should be managed to avoid the disastrous consequences of these temporary workarounds. Management of technical debt involve documenting the debt item in the backlog including some type of quantification in terms of person-hours or story points for example. Subsequently, the debt items are prioritized and addressed. Developers or project managers face problems to decide which debt is higher priority or more ""problematic"" and which one needs to be addressed first. This decision-making process is not standardized and is currently context dependent in most organizations. This paper bridge this gap by proposing a framework which makes use of a plethora of techniques ranging from data mining to prediction and decision models that project managers can use in their decision-making process to determine which technical debt is more critical and should be addressed first. © 2016 Authors.",Technical Debt,Theoretical Artifact,"Codabux, Z. and Williams, B.J.",Proceedings - International Conference on Software Engineering,"2,016.00",Conference Paper,10.1145/2889160.2892643,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85026644004&doi=10.1145%2f2889160.2892643&partnerID=40&md5=04f55ee0c4942646e573cec7da631394,No,Decision-making;  Prediction model;  Technical debt
S102,Read,Accepted,[IC1] - The primary study presents or points to a software artifact that automates a task within at least one TD management activity.,,Does your configuration code smell?,"Infrastructure as Code (IaC) is the practice of specifying computing system configurations through code, and managing them through traditional software engineering methods. The wide adoption of configuration management and increasing size and complexity of the associated code, prompt for assessing, maintaining, and improving the configuration code's quality. In this context, traditional software engineering knowledge and best practices associated with code quality management can be leveraged to assess and manage configuration code quality. We propose a catalog of 13 implementation and 11 design configuration smells, where each smell violates recommended best practices for configuration code. We analyzed 4,621 Puppet repositories containing 8.9 million lines of code and detected the cataloged implementation and design configuration smells. Our analysis reveals that the design configuration smells show 9% higher average co-occurrence among themselves than the implementation configuration smells. We also observed that configuration smells belonging to a smell category tend to co-occur with configuration smells belonging to another smell category when correlation is computed by volume of identified smells. Finally, design configuration smell density shows negative correlation whereas implementation configuration smell density exhibits no correlation with the size of a configuration management system. © 2016 ACM.",Smells,MSR Studies,"Sharma, T. and Fragkoulis, M. and Spinellis, D.","Proceedings - 13th Working Conference on Mining Software Repositories, MSR 2016","2,016.00",Conference Paper,10.1145/2901739.2901761,https://www.scopus.com/inward/record.uri?eid=2-s2.0-84974602546&doi=10.1145%2f2901739.2901761&partnerID=40&md5=36515addaf62a0f66d66b793919a0207,No,Code quality;  Configuration smells;  Infrastructure as Code;  Maintainability;  Technical debt
S71,Read,Accepted,[IC1] - The primary study presents or points to a software artifact that automates a task within at least one TD management activity.,,"Minimizing refactoring effort through prioritization of classes based on historical, architectural and code smell information","Improving a software system's internal structure through regular refactoring is considered vital for its long and healthy life. However, despite its amenities, refactoring is not readily adopted by software development teams in industry mainly due to strict project deadlines and limited resources. Hence, they look for optimal refactoring recommendations that would incur minimal effort overhead while outputting decent benefits in terms of enhanced software quality. To this end, we propose an approach for identifying and prioritizing object-oriented software classes in need of refactoring. Our approach first identifies the most refactoring-prone as well as architecturally relevant classes, and then generates class ranks based on the code smell information. In addition to locating classes with the most significant incremental refactoring opportunities, this work contributes through suggesting developers on estimating maximum code smell correction (paying off maximum technical debt) with minimum refactoring effort. We evaluated the proposed approach on a sample of 1621 classes and 2358 code smell instances, distributed over 28 versions of four open source java systems. © 2016, CEUR-WS. All rights reserved.",Smells,Case Study,"Choudhary, A. and Singh, P.",CEUR Workshop Proceedings,"2,016.00",Conference Paper,,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85009466009&partnerID=40&md5=696c7c304db407e66bf56b8784f350e8,No,Class prioritization;  Code smell;  Refactoring effort;  Software refactoring;  Technical debt
S56,Read,Accepted,[IC1] - The primary study presents or points to a software artifact that automates a task within at least one TD management activity.,,Technical debt in MDE: A case study on GMF/EMF-based projects,"Technical Debt (TD) is a metaphor referring to immature software artifacts that can hurt the long-term maintenance of a system. Model-Driven Engineering (MDE) is a modelcentric software development approach, which promises better maintainability. However, there is a lack of empirical evidence on the existence and influence of TD in the context of MDE. This paper investigates the code-level TD in MDE projects, which is incurred during code generation. We evaluated 16 open-source and non-trivial GMF/EMF-based MDE projects using bad smells, which are widely-accepted TD indicators. The results demonstrate that MDE is not TD-free, and code generators also incur TD, similarly to developers. In fact, the generated code usually contains more TD than handwritten code, which influences significantly the maintenance of MDE projects. © 2016 ACM.",Technical Debt,MSR Studies,"He, X. and Avgeriou, P. and Liang, P. and Li, Z.","Proceedings - 19th ACM/IEEE International Conference on Model Driven Engineering Languages and Systems, MODELS 2016","2,016.00",Conference Paper,10.1145/2976767.2976806,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85008477494&doi=10.1145%2f2976767.2976806&partnerID=40&md5=a8e3ed39c28fe64d6c9d1e6f7e922d4a,No,
S57,Read,Accepted,[IC1] - The primary study presents or points to a software artifact that automates a task within at least one TD management activity.,,How do software development teams manage technical debt? – An empirical study,"Technical debt (TD) is a metaphor for taking shortcuts or workarounds in technical decisions to gain short-term benefit in time-to-market and earlier software release. In this study, one large software development organization is investigated to gather empirical evidence related to the concept of technical debt management (TDM). We used the exploratory case study method to collect and analyze empirical data in the case organization by interviewing a total of 25 persons in eight software development teams. We were able to identify teams where the current strategy for TDM was only to fix TD when necessary, when it started to cause too much trouble for development. We also identified teams where the management had a systematic strategy to identify, measure and monitor TD during the development process. It seems that TDM can be associated with a similar maturity concept as software development in general. Development teams may raise their maturity by increasing their awareness and applying more advanced processes, techniques and tools in TDM. TDM is an essential part of sustainable software development, and companies have to find right approaches to deal with TD to produce healthy software that can be developed and maintained in the future. © 2016 The Authors",Technical Debt,Interview,"Yli-Huumo, J. and Maglyas, A. and Smolander, K.",Journal of Systems and Software,"2,016.00",Article,10.1016/j.jss.2016.05.018,https://www.scopus.com/inward/record.uri?eid=2-s2.0-84969206783&doi=10.1016%2fj.jss.2016.05.018&partnerID=40&md5=ddad6957a54013c53c4bb80ba5c89d7b,No,Exploratory case study;  Technical debt;  Technical debt management
S129,Read,Rejected,[EC2] - The study shows a theoretical artifact or do not provide a link to the artifact's repository;,"After reading the paper, it does not use or explain how to use the tools. Moreover, it does not provide a link to the proposed tool.",An open tool for assisting in technical debt management,"Technical debt monitoring is one of the activities that have to be performed in technical debt management. To do that, there are different techniques that can be used to estimate technical debt and different tools that implement those different techniques. This paper presents TEDMA Tool, a tool for monitoring technical debt over the software evolution and that it is open to integrate third party tools. TEDMA is based on the analysis of source code repositories and is useful for researching using empirical data extracted from software projects. Currently, it is been used to analyze big projects in the execution of several case studies. The expected evolution of TEDMA will make the tool useful for software development industry. © 2017 IEEE.",Technical Debt,Tool,"Fernandez-Sanchez, C. and Humanes, H. and Garbajosa, J. and Diaz, J.","Proceedings - 43rd Euromicro Conference on Software Engineering and Advanced Applications, SEAA 2017",2017,Conference Paper,10.1109/SEAA.2017.60,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85034425200&doi=10.1109%2fSEAA.2017.60&partnerID=40&md5=a6b083d770b2e260cf2ec2664624369d,No,Git;  Neo4j;  Technical debt;  Technical debt management;  Tool
S125,Read,Accepted,[IC1] - The primary study presents or points to a software artifact that automates a task within at least one TD management activity.,,Towards triaging code-smell candidates via runtime scenarios and method-call dependencies,"Managing technical debt includes the detection and assessment of debt at the code and design levels (such as bad smells). Existing approaches and tools for smell detection primarily use static program data for decision support. While a static analysis allows for identifying smell candidates without executing and instrumenting the system, such approaches also come with the risk of missing candidates or of producing false positives. Moreover, smell candidates might result from a deliberate design decision (e.g., of applying a particular design pattern). Such risks and the general ambivalence of smell detection require a manual design and/or code inspection for reviewing all alleged smells. In this paper, we propose an approach to obtain tailorable design documentation for object-oriented systems based on runtime tests. In particular, the approach supports a tool-supported triaging of code-smell candidates. We use runtime scenario tests to extract execution traces. Based on these execution traces, different (automatically derived) model perspectives on method-call dependencies (e.g., dependency structure matrices, DSMs; UML2 sequence diagrams) are then used as decision support for assessing smell candidates. Our approach is implemented as part of the KaleidoScope tool which is publicly available for download. © 2017 Copyright held by the owner/author(s). Publication rights licensed to Association for Computing Machinery.",Smells,Tool,"Haendler, T. and Sobernig, S. and Strembeck, M.",ACM International Conference Proceeding Series,"2,017.00",Conference Paper,10.1145/3120459.3120468,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85029862351&doi=10.1145%2f3120459.3120468&partnerID=40&md5=d96e772b15a135e054ebd4839ede7b3c,No,Code smell;  Decision support;  Dependency structure matrix;  Design documentation;  Execution trace;  Scenario-based testing;  Software behavior;  Technical debt;  Unified modeling language (UML2)
S105,Read,Accepted,[IC1] - The primary study presents or points to a software artifact that automates a task within at least one TD management activity.,,Formative Evaluation of a Tool for Managing Software Quality,"Context/Background: To achieve high software quality, particularly in the context of agile software development, organizations need tools to continuously analyze software quality. Several quality management (QM) tools have been developed in recent years. However, there is a lack of evidence regarding the quality of QM tools, standardized definitions of such quality, and reliable instruments for measuring it. This, in turn, impedes proper selection and improvement of QM tools. Goals: We aimed at operationalizing the quality of a research QM tool, namely the ProDebt prototype, and evaluating its quality. The goal of the ProDebt prototype is to provide practitioners with support for managing software quality and technical debt. Method: We performed interviews, workshops, and a mapping study to operationalize the quality of the ProDebt prototype and to identify reliable instruments to measure it. We designed a mixed-method study aimed at formative evaluation, i.e., at assessing the quality of the ProDebt prototype and providing guidance for its further development. Eleven practitioners from two German companies evaluated the ProDebt prototype. Results: The participants assessed the information provided by the ProDebt prototype as understandable and relevant. They considered the ProDebt prototype's functionalities as easy to use but of limited usability. They identified improvement needs, e.g., that the analysis results should be linked to other information sources. Conclusions: The evaluation design was of practical value for evaluating the ProDebt prototype considering the limited resources such as the practitioners' time. The evaluation results provided the developers of the ProDebt prototype with guidance for its further development. We conclude that it can be used and tailored for replication or evaluation of other QM tools. © 2017 IEEE.",TD Symptoms/Consequences,Tool,"Guzman, L. and Vollmer, A.M. and Ciolkowski, M. and Gillmann, M.",International Symposium on Empirical Software Engineering and Measurement,"2,017.00",Conference Paper,10.1109/ESEM.2017.43,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85034595512&doi=10.1109%2fESEM.2017.43&partnerID=40&md5=63c2a1f2f40969cde097f76e359d1d4e,No,software engineering;  software measurement;  software quality
S136,Read,Accepted,[IC1] - The primary study presents or points to a software artifact that automates a task within at least one TD management activity.,,Compiling static software metrics for reliability and maintainability from GitHub repositories,"This paper identifies a small, essential set of static software code metrics linked to the software product quality characteristics of reliability and maintainability and to the most commonly identified sources of technical debt. A plug-in is created for the Understand code visualization and static analysis tool that calculates and aggregates the metrics. The plug-in produces a high-level interactive html report as well as developer-level information needed to address quality issues using Understand. A script makes use of Git, Understand, and the plug-in to compile results for a list of GitHub repositories into a single file. The primary contribution of this work is to describe an open-source plug-in to measure and visualize architectural complexity based on the propagation cost and core size metrics, which are not currently found in other tools. The plug-in should be useful to researchers and practitioners interested in these two metrics and as an expedient starting point to experimentation with metric collection and aggregation for groups of GitHub repositories. The plug-in was developed as a first step in an ongoing project aimed at applying case-based reasoning to the issue of software product quality. © 2017 IEEE.",TD Symptoms/Consequences,Tool,"Ludwig, J. and Xu, S. and Webber, F.","2017 IEEE International Conference on Systems, Man, and Cybernetics, SMC 2017","2,017.00",Conference Paper,10.1109/SMC.2017.8122569,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85044185772&doi=10.1109%2fSMC.2017.8122569&partnerID=40&md5=3ee00c22476fcec5a129421943a007d5,No,Architecture;  Maintainability;  Metrics;  Reliability;  Software product quality;  Static code analysis;  Technical debt
S109,Read,Accepted,[IC1] - The primary study presents or points to a software artifact that automates a task within at least one TD management activity.,,Technical debt principal assessment through structural metrics,"One of the first steps towards the effective Technical Debt (TD) management is the quantification and continuous monitoring of the TD principal. In the current state-ofresearch and practice the most common ways to assess TD principal are the use of: (a) structural proxies - i.e., most commonly through quality metrics; and (b) monetized proxies - i.e., most commonly through the use of the SQALE (Software Quality Assessment based on Lifecycle Expectations) method. Although both approaches have merit, they seem to rely on different viewpoints of TD and their levels of agreement have not been evaluated so far. Therefore, in this paper, we empirically explore this relation by analyzing data obtained from 20 open source software projects and build a regression model that establishes a relationship between them. The results of the study suggest that a model of seven structural metrics, quantifying different aspects of quality (i.e., coupling, cohesion, complexity, size, and inheritance) can accurately estimate TD principal as appraised by SonarQube. The results of this case study are useful to both academia and industry. In particular, academia can gain knowledge on: (a) the reliability and agreement of TD principal assessment methods and (b) the structural characteristics of software that contribute to the accumulation of TD, whereas practitioners are provided with an alternative evaluation model with reduced number of parameters that can accurately assess TD, through traditional software quality metrics and tools. © 2017 IEEE.",Technical Debt,Tool,"Kosti, M.V. and Ampatzoglou, A. and Chatzigeorgiou, A. and Pallas, G. and Stamelos, I. and Angelis, L.","Proceedings - 43rd Euromicro Conference on Software Engineering and Advanced Applications, SEAA 2017","2,017.00",Conference Paper,10.1109/SEAA.2017.59,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85034442570&doi=10.1109%2fSEAA.2017.59&partnerID=40&md5=33bc950cc86d4b2c844b1fbd780cd665,No,Case study;  Prediction model;  Technical debt
S115,Read,Accepted,[IC1] - The primary study presents or points to a software artifact that automates a task within at least one TD management activity.,,Toward technical debt aware software modeling,"Over the last decade, the technical debt metaphor has gained in populari-ty, and many tools exist today that can calculate the debt associated with a miscella-ny of source code. However, no corpus of studies has investigated the effects that creation and refactoring of conceptual models have on technical debt of correspond-ing code. Our work addresses this fundamental gap by first providing a map of cor-respondences between recognized model smells of UML Class Diagrams and Java source code issues. We then describe a set of empirical studies to calculate the tech-nical debt of generated source code as a result of refactorings performed on their corresponding models. Our results reveal a significant disconnect between model smells and technical debt values of resultant generated source code, and little effect of model refactorings on reducing these values. However, once correspondences be-tween model smells and code issues are defined, model refactoring proves helpful in preventing technical debt from a high abstraction level. We exemplify this scenario by providing an in-depth example, and conclude with a discussion of results.",Technical Debt,Tool,"Rojas, G. and Izurieta, C. and Griffith, I.",CIbSE 2017 - XX Ibero-American Conference on Software Engineering,"2,017.00",Conference Paper,,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85026668812&partnerID=40&md5=11217fc45d4c1240aaf01803a5b1b223,No,Model driven development;  Model smells & refactoring;  Software maintenance;  Software quality;  Technical debt
S116,Read,Accepted,[IC1] - The primary study presents or points to a software artifact that automates a task within at least one TD management activity.,,SonarQube as a tool to identify software metrics and technical debt in the source code through static analysis,"Technical Debt (TD), also known as technical debt design or technical debt code, analyze the consequence that could have a system once it has been designed architecturally, coding or implemented. TD refers to work to be performed rather than software design or coding is considered complete or correct. Static analysis is a technique to identify and analyze software characteristics from source code; through static analysis we can identify elements such as packages, classes, relationships, lines of code (LOC's), bugs, complexity, coding violations and others. In addition, subsystems, components and their relationships supported by tools, algorithms, frameworks to analyze the code were identified. SQALE is a quality and analysis model contains the internal properties expected from the code in the context of the evaluation, it has been used to perform many assessments of software source code, of various sizes in different application domains and programming language. SonarQube is an open source platform to manage the source code quality, this cover seven axes of code quality among which stand: architecture and design, duplications, unit test, complexity, potential bugs, codifications rules, comments, among others; this platform work with over 20 programming languages. This paper, use as input the source code of the software applications written in different programming language for through static analysis identify metrics, characteristics, and technical debt with the aim to improve the quality when writing code, also supported in static analysis identify aspects such as correct apply of quality attributes, standards and best practices of programming that based in ISO 9126 and SQALE ensure the correct software development in terms of design and coding.",Technical Debt,Tool,"Guaman, D. and Sarmiento, P.A.-Q. and Barba-Guamán, L. and Cabrera, P. and Enciso, L.","2017 7th International Workshop on Computer Science and Engineering, WCSE 2017","2,017.00",Conference Paper,,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85027839441&partnerID=40&md5=10c2c2f05475c04186d6fbeb3f45a1f9,No,Quality attributes;  SonarQube;  Source code;  SQALE;  Static analysis;  Technical debt
S123,Read,Accepted,[IC1] - The primary study presents or points to a software artifact that automates a task within at least one TD management activity.,,The magnificent seven: Towards a systematic estimation of technical debt interest,"The interest of Technical Debt is difcult to assess. The negative efects (severity) of Technical Debt might depend on the context of the organization and the estimations might be subjective. There is a need for assessing Technical Debt interest in a more systematic way. Based on the results of previous research, we have developed and used a lightweight tool, AnaConDebt, to assess the severity of the interest of 9 Technical Debt items with the stakeholders in 3 Agile teams. The systematic and semi-automatic assessment of seven factors and their growth has been compared to the stakeholders' intuitive estimations. The results show that the outcome of the tool is very close to the estimation given by the stakeholders. The implications are that, if further data support the hypothesis, the severity of the interest can be systematically assessed by the stakeholders by estimating only seven factors in a cost-efective manner with acceptable results. © 2017 Association for Computing Machinery.",Technical Debt,Tool,"Martini, A. and Bosch, J.",ACM International Conference Proceeding Series,"2,017.00",Conference Paper,10.1145/3120459.3120467,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85029854263&doi=10.1145%2f3120459.3120467&partnerID=40&md5=0b48cfc6fc9934e3d411d3837f526c2d,No,Case study;  Estimation;  Interest;  Technical debt;  Tool
S209,Read,Rejected,[EC2a] - The study provides a broken link,,JCaliper: Search-based technical debt management,"Technical Debt (TD) reflects problems in software maintainability along evolution. TD principal is defined as the effort required for refactoring an existing system to an ideal one (a.k.a. optimal) that suffers from no maintainability problems. One of the open problems in the TD community is that ideal versions of systems do not exist, and there are no methods in the literature for approaching them, even theoretically. To alleviate this problem, in this paper we propose an efficient TD management strategy, by applying Search-Based Software Engineering techniques. In particular, we focus on one specific aspect of TD, namely inefficient software modularity, by properly assigning behavior and state to classes through search space exploration. At the same time, in the context of TD, we: (a) investigate the use of local search algorithms to obtain a near-optimum solution and propose TD repayment actions (i.e., refactorings), and (b) calculate the distance of a design to the corresponding optimal (i.e., a proxy of TD principal). The approach has been implemented in the JCaliper Eclipse plugin enabling a case study, which validates the approach and contrasts it to existing measure of software evolution. © 2019 Association for Computing Machinery.",Technical Debt,Tool,"Kouros, P. and Chaikalis, T. and Arvanitou, E.-M. and Chatzigeorgiou, A. and Ampatzoglou, A. and Amanatidis, T.",Proceedings of the ACM Symposium on Applied Computing,2019,Conference Paper,10.1145/3297280.3297448,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85065676436&doi=10.1145%2f3297280.3297448&partnerID=40&md5=a08af1deeff822ec2413a6e6dd4fbf47,No,Object-oriented Design;  Refactoring;  Software Quality
S133,Read,Accepted,[IC1] - The primary study presents or points to a software artifact that automates a task within at least one TD management activity.,,Recommending when design technical debt should be self-admitted,"Previous research has shown how developers ""self-admit"" technical debt introduced in the source code, commenting why such code represents a workaround or a temporary, incomplete solution. This paper investigates the extent to which previously self-admitted technical debt can be used to provide recommendations to developers when they write new source code, suggesting them when to ""self-admit"" design technical debt, or possibly when to improve the code being written. To achieve this goal, we have developed a machine learning approach named TEDIOUS (TEchnical Debt IdentificatiOn System), which leverages various kinds of method-level features as independent variables, including source code structural metrics, readability metrics and, last but not least, warnings raised by static analysis tools. We assessed TEDIOUS on data from nine open source projects for which there are available tagged self-admitted technical debt instances, also comparing the performances of different machine learners. Results of the study indicate that TEDIOUS achieves, when recommending self-admitted technical debts within a single project, an average precision of about 50% and a recall of 52%. When predicting cross-projects, TEDIOUS improves, achieving an average precision of 67% and a recall of 55%. Last, but not least, we noticed how TEDIOUS leverages readability, size and complexity metrics, as well as some warnings raised by static analysis tools. © 2017 IEEE.",Technical Debt,Tool,"Zampetti, F. and Noiseux, C. and Antoniol, G. and Khomh, F. and Di Penta, M.","Proceedings - 2017 IEEE International Conference on Software Maintenance and Evolution, ICSME 2017","2,017.00",Conference Paper,10.1109/ICSME.2017.44,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85040591802&doi=10.1109%2fICSME.2017.44&partnerID=40&md5=c6b4d39f711b62ac322cc93b626dc5a0,No,Recommender systems;  Self-admitted technical debt;  Static analysis tools
S132,Read,Accepted,[IC1] - The primary study presents or points to a software artifact that automates a task within at least one TD management activity.,,Improving object-oriented design quality: A portfolio- and measurement-based approach,"Current software development trends have shortened release cycles and forced developers to implement short-term solutions that cannot cope with increasing product complexity. This phenomenon of introducing hasty design choices or applying bad design practices becomes something known as technical debt, in particular design debt. To pay of this debt, the literature offers approaches for identifying these design glaws; however, few methods for properly prioritizing investment efforts are available. In this paper, we propose an approach that supports the decision-making process regarding design improvements. It identifies violations of design best practices that are then arranged within a two-dimensional portfolio matrix. This matrix combines the importance of practices of design quality with actual achievement relative to a benchmark suite. To show the application of the approach in a quality-improvement process, we performed a feasibility study on three open-source projects and a benchmark suite containing 50 projects. This study clearly shows that the importance of the design best practices greatly impacts the improvement decisions and must be aligned with the strategic quality goals of the product. ' 2017 Copyright held by the owner/author(s). Publication rights licensed to ACM.",TD Symptoms/Consequences,Tool,"Bräuer, J. and Saft, M. and Plösch, R. and Körner, C.",ACM International Conference Proceeding Series,"2,017.00",Conference Paper,10.1145/3143434.3143454,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85038361515&doi=10.1145%2f3143434.3143454&partnerID=40&md5=01dc8b8e5a3be07454827b3e7d146617,No,Design debt;  Design quality;  Software quality;  Technical debt
S137,Read,Accepted,[IC1] - The primary study presents or points to a software artifact that automates a task within at least one TD management activity.,,What if i Had No Smells?,"What would have happened if I did not have any code smell? This is an interesting question that no previous study, to the best of our knowledge, has tried to answer. In this paper, we present a method for implementing a what-if scenario analysis estimating the number of defective files in the absence of smells. Our industrial case study shows that 20% of the total defective files were likely avoidable by avoiding smells. Such estimation needs to be used with the due care though as it is based on a hypothetical history (i.e., zero number of smells and same process and product change characteristics). Specifically, the number of defective files could even increase for some types of smells. In addition, we note that in some circumstances, accepting code with smells might still be a good option for a company. © 2017 IEEE.",Smells,Theoretical Artifact,"Falessi, D. and Russo, B. and Mullen, K.",International Symposium on Empirical Software Engineering and Measurement,"2,017.00",Conference Paper,10.1109/ESEM.2017.14,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85042350972&doi=10.1109%2fESEM.2017.14&partnerID=40&md5=38b9fedcca05dc49202420a20b3f91e0,No,code smells;  machine learning;  software estimation;  technical debt
S124,Read,Accepted,[IC1] - The primary study presents or points to a software artifact that automates a task within at least one TD management activity.,,Who is producing more technical debt? A personalized assessment of TD principal,"Technical debt (TD) impedes software projects by reducing the velocity of development teams during software evolution. Although TD is usually assessed on either the entire system or on individual software artifacts, it is the actual craftsmanship of developers that causes the accumulation of TD. In the light of extremely high maintenance costs, efficient software project management cannot occur without recognizing the relation between developer characteristics and the tendency to evoke violations that lead to TD. In this paper, we investigate three research questions related to the distribution of TD among the developers of a software project, the types of violations caused by each developer and the relation between developers' maturity and the tendency to accumulate TD. The study has been performed on four widely employed PHP open-source projects. All developers' personal characteristics have been anonymized in the study. © 2017 ACM.",Technical Debt,Survey,"Amanatidis, T. and Ampatzoglou, A. and Chatzigeorgiou, A. and Stamelos, I.",ACM International Conference Proceeding Series,"2,017.00",Conference Paper,10.1145/3120459.3120464,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85029891811&doi=10.1145%2f3120459.3120464&partnerID=40&md5=ba0893f55d34fdee944129c2acf8d5ea,No,Project management;  Software maintenance;  Technical debt
S131,Read,Accepted,[IC1] - The primary study presents or points to a software artifact that automates a task within at least one TD management activity.,,Correlations of software code metrics: An empirical study,"Background: The increasing up-trend of software size brings about challenges related to release planning and maintainability. Foreseeing the growth of software metrics can assist in taking proactive decisions regarding different areas where software metrics play vital roles. For example, source code metrics are used to automatically calculate technical debt related to code quality which may indicate how maintainable a software is. Thus, predicting such metrics can give us an indication of technical debt in the future releases of software. Objective: Estimation or prediction of software metrics can be performed more meaningfully if the relationships between different domains of metrics and relationships between the metrics and different domains are well understood. To understand such relationships, this empirical study has collected 25 metrics classified into four domains from 9572 software revisions of 20 open source projects from 8 well-known companies. Results: We found software size related metrics are most correlated among themselves and with metrics from other domains. Complexity and documentation related metrics are more correlated with size metrics than themselves. Metrics in the duplications domain are observed to be more correlated to themselves on a domain-level. However, a metric to domain level relationship exploration reveals that metrics with most strong correlations are in fact connected to size metrics. The Overall correlation ranking of duplication metrics are least among all domains and metrics. Contribution: Knowledge earned from this research will help to understand inherent relationships between metrics and domains. This knowledge together with metric-level relationships will allow building better predictive models for software code metrics. © 2017 Association for Computing Machinery.",TD Symptoms/Consequences,MSR Studies,"Al Mamun, M.A. and Berger, C. and Hansson, J.",ACM International Conference Proceeding Series,"2,017.00",Conference Paper,10.1145/3143434.3143445,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85038399512&doi=10.1145%2f3143434.3143445&partnerID=40&md5=896b9cf6507046aadb68bf44129fa45d,No,Correlation of Metrics;  Software Code Metrics;  Software Engineering;  Spearman’s Rank Correlation
S186,Read,Accepted,[IC1] - The primary study presents or points to a software artifact that automates a task within at least one TD management activity.,,An architectural smells detection tool for C and C++ projects,"Architectural smells gained great attention in the past few years since they directly affect software quality and increase architectural technical debt. However, while it is straightforward to understand why they are important, it is more difficult to find techniques and tools to detect and remove architectural smells. The purpose of this paper is to introduce an open-source tool for automatic architectural smells detection for C/C++ projects, by creating an abstraction of the project and defining the concept of dependency between elements belonging to the project in order to identify architectural smells. The tool has been validated on some open-source projects with promising results. © 2018 IEEE.",Smells,Tool,"Biaggi, A. and Fontana, F.A. and Roveda, R.","Proceedings - 44th Euromicro Conference on Software Engineering and Advanced Applications, SEAA 2018","2,018.00",Conference Paper,10.1109/SEAA.2018.00074,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85057141088&doi=10.1109%2fSEAA.2018.00074&partnerID=40&md5=d3e84da3c46130ff50c82b1248ab49fc,No,Architectural smells;  Architectural technical debt;  C++;  Software architecture evaluation;  Standard C
S178,Read,Accepted,[IC1] - The primary study presents or points to a software artifact that automates a task within at least one TD management activity.,,Experiences applying automated architecture analysis tool suites,"In this paper, we report our experiences of applying three complementary automated software architecture analysis techniques, supported by a tool suite, called DV8, to 8 industrial projects within a large company. DV8 includes two state-of-the-art architecture-level maintainability metrics-Decoupling Level and Propagation Cost, an architecture flaw detection tool, and an architecture root detection tool. We collected development process data from the project teams as input to these tools, reported the results back to the practitioners, and followed up with telephone conferences and interviews. Our experiences revealed that the metrics scores, quantitative debt analysis, and architecture flaw visualization can effectively bridge the gap between management and development, help them decide if, when, and where to refactor. In particular, the metrics scores, compared against industrial benchmarks, faithfully reflected the practitioners' intuitions about the maintainability of their projects, and enabled them to better understand the maintainability relative to other projects internal to their company, and to other industrial products. The automatically detected architecture flaws and roots enabled the practitioners to precisely pinpoint, visualize, and quantify the “hotspots"" within the systems that are responsible for high maintenance costs. Except for the two smallest projects for which both architecture metrics indicated high maintainability, all other projects are planning or have already begun refactorings to address the problems detected by our analyses. We are working on further automating the tool chain, and transforming the analysis suite into deployable services accessible by all projects within the company. © 2018 Association for Computing Machinery.",TD Symptoms/Consequences,Tool,"Mo, R. and Ramaswamy, S. and Snipes, W. and Kazman, R. and Cai, Y. and Naedele, M.",ASE 2018 - Proceedings of the 33rd ACM/IEEE International Conference on Automated Software Engineering,"2,018.00",Conference Paper,10.1145/3238147.3240467,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85056510223&doi=10.1145%2f3238147.3240467&partnerID=40&md5=8867a05bef4e07b72a881c82e57cd4fc,No,Software Architecture;  Software Maintenance;  Software Quality
S158,Read,Accepted,[IC1] - The primary study presents or points to a software artifact that automates a task within at least one TD management activity.,,Identifying and prioritizing architectural debt through architectural smells: A case study in a large software company,"Architectural technical debt can have a huge impact on software maintainability and evolution. Hence, different architectural violations, detected as architectural smells, need to be identified and refactored. In this paper, we conducted a multiple case-study on several architectural smells detected in four industrial projects. We conducted an in-depth investigation with a questionnaire, interviews and thorough inspection of the code with the practitioners. We evaluated the negative impact of the technical debt detected by the architectural smells, their difficulty to be refactored and the usefulness of the detection tool. The results show that practitioners appreciated the help of automatic detection, and that they prioritize refactoring architectural debt that causes more negative impact despite the higher refactoring effort. © Springer Nature Switzerland AG 2018.",Technical Debt,Tool,"Martini, A. and Fontana, F.A. and Biaggi, A. and Roveda, R.",Lecture Notes in Computer Science (including subseries Lecture Notes in Artificial Intelligence and Lecture Notes in Bioinformatics),"2,018.00",Conference Paper,10.1007/978-3-030-00761-4_21,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85057282031&doi=10.1007%2f978-3-030-00761-4_21&partnerID=40&md5=bbe2cd505b6e19f9dbfb94685625e700,No,
S163,Read,Accepted,[IC1] - The primary study presents or points to a software artifact that automates a task within at least one TD management activity.,,SATD detector: A text-mining-based self-Admitted technical debt detection tool,"In software projects, technical debt metaphor is used to describe the situation where developers and managers have to accept compromises in long-Term software quality to achieve short-Term goals. There are many types of technical debt, and self-Admitted technical debt (SATD) was proposed recently to consider debt that is introduced intentionally (e.g., through temporaryfi x) and admitted by developers themselves. Previous work has shown that SATD can be successfully detected using source code comments. However, most current state-of-The-Art approaches identify SATD comments through pattern matching, which achieve high precision but very low recall. That means they may miss many SATD comments and are not practical enough. In this paper, we propose SATD Detector, a tool that is able to (i) automatically detect SATD comments using text mining and (ii) highlight, list and manage detected comments in an integrated development environment (IDE). This tool consists of a Java library and an Eclipse plug-in. The Java library is the back-end, which provides command-line interfaces and Java APIs to re-Train the text mining model using users' data and automatically detect SATD comments using either the build-in model or a user-specified model. The Eclipse plug-in, which is the front-end, first leverages our pre-Trained composite classifier to detect SATD comments, and then highlights and marks these detected comments in the source code editor of Eclipse. In addition, the Eclipse plug-in provides a view in IDE which collects all detected comments for management. Demo URL: https://youtu.be/sn4gU2qhGm0 Java library download: https://git.io/vNdnY Eclipse plug-in download: https://goo.gl/ZzjBzp. © 2018 Authors.",Technical Debt,Tool,"Liu, Z. and Huang, Q. and Xia, X. and Shihab, E. and Lo, D. and Li, S.",Proceedings - International Conference on Software Engineering,"2,018.00",Conference Paper,10.1145/3183440.3183478,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85049683556&doi=10.1145%2f3183440.3183478&partnerID=40&md5=fc9b4f29011dee78dffc65dcb86362ba,No,Eclipse plug-in;  SATD detection;  Self-Admitted technical debt
S172,Read,Accepted,[IC1] - The primary study presents or points to a software artifact that automates a task within at least one TD management activity.,,Prioritize technical debt in large-scale systems using codescene,"Large-scale systems often contain considerable amounts of code that is overly complicated, hard to understand, and hence expensive to change. An organization cannot address and refactor all of that code at once, nor should they. Ideally, actionable refactoring targets should be prioritized based on the technical debt interest rate to balance the trade-offs between improvements, risk, and new features. This paper examines how CodeScene, a tool for predictive analyses and visualizations, can be used to prioritize technical debt in a large-scale codebase like the Linux Kernel based on the most likely return on code improvements. © 2018 Author.",Technical Debt,Tool,"Tornhill, A.",Proceedings - International Conference on Software Engineering,"2,018.00",Conference Paper,10.1145/3194164.3194187,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85051569623&doi=10.1145%2f3194164.3194187&partnerID=40&md5=3cb07f0d3de4ca39d14feeeb93924ec0,No,
S175,Read,Accepted,[IC1] - The primary study presents or points to a software artifact that automates a task within at least one TD management activity.,,Assessing technical debt in automated tests with codescene,"Test automation promises several advantages such as shorter lead times, higher code quality, and an executable documentation of the system's behavior. However, test automation won't deliver on those promises unless the quality of the automated test code itself is maintained, and to manually inspect the evolution of thousands of tests that change on a daily basis is impractical at best. This paper investigates how CodeScene - a tool for predictive analyses and visualizations - could be used to identify technical debt in automated test code. CodeScene combines repository mining, static code analysis, and machine learning to prioritize potential code improvements based on the most likely return on investment. © 2018 IEEE.",Technical Debt,Tool,"Tornhill, A.","Proceedings - 2018 IEEE 11th International Conference on Software Testing, Verification and Validation Workshops, ICSTW 2018","2,018.00",Conference Paper,10.1109/ICSTW.2018.00039,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85050969959&doi=10.1109%2fICSTW.2018.00039&partnerID=40&md5=14265fd8be7c272ad271e9c8f8990221,No,Code Quality;  Repository Mining;  Technical Debt;  Test Automation;  Vendor Tools
S182,Read,Accepted,[IC1] - The primary study presents or points to a software artifact that automates a task within at least one TD management activity.,,Enhanced feature selection using word embeddings for self-admitted technical debt identification,"Technical debt (TD) is a term used to describe a trade off between code quality and timely software release. Since technical debt has negative impact on software development, identification of such debt is an important task in the software engineering domain. Sometimes, technical debt is annotated in source code comments. This kind of debt is referred to as self-admitted technical debt (SATD). Recently, some studies have focused on automated detection and classification of SATD using natural language processing methods. However, these methods have only used manually annotated data to train their classifiers. In this paper, we present the results of a performed exploratory study for using large corpus of unlabeled code comments, extracted from open source projects on git-hub, to train word embeddings, in order to improve detection of SATD. Our approach aims to enhance the feature selection method by taking advantage of the pre-trained word embeddings to detect similar features in source code comments. The experimental results show a significant improvement in SATD classification. With achieved 82% of correct predictions of SATD, the method seems to be a good candidate to be adopted in practice. © 2018 IEEE.",Technical Debt,Tool,"Flisar, J. and Podgorelec, V.","Proceedings - 44th Euromicro Conference on Software Engineering and Advanced Applications, SEAA 2018","2,018.00",Conference Paper,10.1109/SEAA.2018.00045,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85057152167&doi=10.1109%2fSEAA.2018.00045&partnerID=40&md5=2515f9dad60877d3a0677a95c896d60f,No,Feature selection;  Self-admitted technical debt;  Text classification;  Word embeddings
S152,Read,Accepted,[IC1] - The primary study presents or points to a software artifact that automates a task within at least one TD management activity.,,To adapt or not to adapt? Technical debt and learning driven self-adaptation for managing runtime performance,"Self-adaptive system (SAS) can adapt itself to optimize various key performance indicators in response to the dynamics and uncertainty in environment. In this paper, we present Debt Learning Driven Adaptation (DLDA), an framework that dynamically determines when and whether to adapt the SAS at runtime. DLDA leverages the temporal adaptation debt, a notion derived from the technical debt metaphor, to quantify the time-varying money that the SAS carries in relation to its performance and Service Level Agreements. We designed a temporal net debt driven labeling to label whether it is economically healthier to adapt the SAS (or not) in a circumstance, based on which an online machine learning classifier learns the correlation, and then predicts whether to adapt under the future circumstances. We conducted comprehensive experiments to evaluate DLDA with two different planners, using 5 online machine learning classifiers, and in comparison to 4 state-of-the-art debt-oblivious triggering approaches. The results reveal the effectiveness and superiority of DLDA according to different metrics. © 2018 Association for Computing Machinery.",TD Symptoms/Consequences,Tool,"Chen, T. and Bahsoon, R. and Wang, S. and Yao, X.",ICPE 2018 - Proceedings of the 2018 ACM/SPEC International Conference on Performance Engineering,"2,018.00",Conference Paper,10.1145/3184407.3184413,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85051087850&doi=10.1145%2f3184407.3184413&partnerID=40&md5=c4b0153bcd017d224774532305d422fa,No,Learning;  Performance;  Self-adaptive systems;  Technical debt
S184,Read,Accepted,[IC1] - The primary study presents or points to a software artifact that automates a task within at least one TD management activity.,,Towards an architectural debt index,"Different indexes have been proposed to evaluate software quality and technical debt. Usually these indexes take into account different code level issues and several metrics, well known software metrics or new ones defined ad hoc for a specific purpose. In this paper we propose and define a new index, more oriented to the evaluation of architectural violations. We describe in detail the index, called Architectural Debt Index, that we integrated in a tool developed for architectural smell detection. The index is based on the detection of architectural smells, their criticality and their history. Currently only dependency architectural smells have been considered, but other architectural debt indicators can be considered and integrated in the index computation. © 2018 IEEE.",Technical Debt,Tool,"Roveda, R. and Fontana, F.A. and Pigazzini, I. and Zanoni, M.","Proceedings - 44th Euromicro Conference on Software Engineering and Advanced Applications, SEAA 2018","2,018.00",Conference Paper,10.1109/SEAA.2018.00073,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85049883321&doi=10.1109%2fSEAA.2018.00073&partnerID=40&md5=ecb2fc3329d7ac8e0ac924c9b02289ec,No,Architectural debt index;  Architectural smells;  Severity index;  Technical debt
S146,Read,Accepted,[IC1] - The primary study presents or points to a software artifact that automates a task within at least one TD management activity.,,Challenges in assessing technical debt based on dynamic runtime data,"Existing definitions and metrics of technical debt (TD) tend to focus on static properties of software artifacts, in particular on code measurement. Our experience from software renovation projects is that dynamic aspects - runtime indicators of TD - often play a major role. In this position paper, we present insights and solution ideas gained from numerous software renovation projects at QAware and from a series of interviews held as part of the ProDebt research project. We interviewed ten practitioners from two German software companies in order to understand current requirements and potential solutions to current problems regarding TD. Based on the interview results, we motivate the need for measuring dynamic indicators of TD from the practitioners' perspective, including current practical challenges. We found that the main challenges include a lack of production-ready measurement tools for runtime indicators, the definition of proper metrics and their thresholds, as well as the interpretation of these metrics in order to understand the actual debts and derive countermeasures. Measuring and interpreting dynamic indicators of TD is especially difficult to implement for companies because the related metrics are highly dependent on runtime context and thus difficult to generalize. We also sketch initial solution ideas by presenting examples of dynamic indicators for TD and outline directions for future work. © 2018 IEEE.",Technical Debt,Theoretical Artifact,"Ciolkowski, M. and Guzmán, L. and Trendowicz, A. and Vollmer, A.M.","Proceedings - 44th Euromicro Conference on Software Engineering and Advanced Applications, SEAA 2018","2,018.00",Conference Paper,10.1109/SEAA.2018.00078,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85057190800&doi=10.1109%2fSEAA.2018.00078&partnerID=40&md5=b1128be33cf75c21334c2c614be3d381,No,Dynamic data;  Measurement;  Runtime data;  Technical debt
S190,Read,Accepted,[IC1] - The primary study presents or points to a software artifact that automates a task within at least one TD management activity.,,Technical debt in model transformation specifications,"Model transformations (MT), as with any other software artifact, may contain quality flaws. Even if a transformation is functionally correct, such flaws will impair maintenance activities such as enhancement and porting. The concept of technical debt (TD) models the impact of such flaws as a burden carried by the software which must either be settled in a ‘lump sum’ to eradicate the flaw, or paid in the ongoing additional costs of maintaining the software with the flaw. In this paper we investigate the characteristics of technical debt in model transformations, analysing a range of MT cases in different MT languages, and using measures of quality flaws or ‘bad smells’ for MT, adapted from code measures. Based on these measures we identify significant differences in the level and kinds of technical debt in different MT languages, and we propose ways in which TD can be reduced. © Springer International Publishing AG, part of Springer Nature 2018.",Technical Debt,Theoretical Artifact,"Lano, K. and Kolahdouz-Rahimi, S. and Sharbaf, M. and Alfraihi, H.",Lecture Notes in Computer Science (including subseries Lecture Notes in Artificial Intelligence and Lecture Notes in Bioinformatics),"2,018.00",Conference Paper,10.1007/978-3-319-93317-7_6,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85048817976&doi=10.1007%2f978-3-319-93317-7_6&partnerID=40&md5=8846a70f48ee3059a524fe3f0323068a,No,
S162,Read,Accepted,[IC1] - The primary study presents or points to a software artifact that automates a task within at least one TD management activity.,,Smelly relations: Measuring and understanding database schema quality,"Context: Databases are an integral element of enterprise applications. Similarly to code, database schemas are also prone to smells - best practice violations. Objective: We aim to explore database schema quality, associated characteristics and their relationships with other software artifacts. Method: We present a catalog of 13 database schema smells and elicit developers' perspective through a survey. We extract embedded sql statements and identify database schema smells by employing the DbDeo tool which we developed. We analyze 2925 production-quality systems (357 industrial and 2568 well-engineered open-source projects) and empirically study quality characteristics of their database schemas. In total, we analyze 629 million lines of code containing more than 393 thousand sql statements. Results: We find that the index abuse smell occurs most frequently in database code, that the use of an orm framework doesn't immune the application from database smells, and that some database smells, such as adjacency list, are more prone to occur in industrial projects compared to open-source projects. Our co-occurrence analysis shows that whenever the clone table smell in industrial projects and the values in attribute definition smell in open-source projects get spotted, it is very likely to find other database smells in the project. Conclusion: The awareness and knowledge of database smells are crucial for developing high-quality software systems and can be enhanced by the adoption of better tools helping developers to identify database smells early. © 2018 ACM.",Smells,MSR Studies,"Sharma, T. and Fragkoulis, M. and Rizou, S. and Bruntink, M. and Spinellis, D.",Proceedings - International Conference on Software Engineering,"2,018.00",Conference Paper,10.1145/3183519.3183529,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85049670169&doi=10.1145%2f3183519.3183529&partnerID=40&md5=82140ed9972e734cc9baaa703c63a675,No,Antipatterns;  Code smells;  Database schema smells;  Software maintenance;  Software quality;  Technical debt
S166,Read,Accepted,[IC1] - The primary study presents or points to a software artifact that automates a task within at least one TD management activity.,,Evaluating domain-specific metric thresholds: An empirical study,"Software metrics and thresholds provide means to quantify several quality attributes of software systems. Indeed, they have been used in a wide variety of methods and tools for detecting different sorts of technical debts, such as code smells. Unfortunately, these methods and tools do not take into account characteristics of software domains, as the intrinsic complexity of geo-localization and scientific software systems or the simple protocols employed by messaging applications. Instead, they rely on generic thresholds that are derived from heterogeneous systems. Although derivation of reliable thresholds has long been a concern, we still lack empirical evidence about threshold variation across distinct software domains. To tackle this limitation, this paper investigates whether and how thresholds vary across domains by presenting a large-scale study on 3,107 software systems from 15 domains. We analyzed the derivation and distribution of thresholds based on 8 well-known source code metrics. As a result, we observed that software domain and size are relevant factors to be considered when building benchmarks for threshold derivation. Moreover, we also observed that domain-specific metric thresholds are more appropriated than generic ones for code smell detection. © 2018 ACM.",TD Symptoms/Consequences,MSR Studies,"Mori, A. and Vale, G. and Viggiato, M. and Oliveira, J. and Figueiredo, E. and Cirilo, E. and Jamshidi, P. and Kastner, C.",Proceedings - International Conference on Software Engineering,"2,018.00",Conference Paper,10.1145/3194164.3194173,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85051486330&doi=10.1145%2f3194164.3194173&partnerID=40&md5=4dc45a9f967364a60204d0d376da94bd,No,software domains;  software metrics;  thresholds
S160,Read,Accepted,[IC1] - The primary study presents or points to a software artifact that automates a task within at least one TD management activity.,,Identifying self-admitted technical debt in open source projects using text mining,"Technical debt is a metaphor to describe the situation in which long-term code quality is traded for short-term goals in software projects. Recently, the concept of self-admitted technical debt (SATD) was proposed, which considers debt that is intentionally introduced, e.g., in the form of quick or temporary fixes. Prior work on SATD has shown that source code comments can be used to successfully detect SATD, however, most current state-of-the-art classification approaches of SATD rely on manual inspection of the source code comments. In this paper, we proposed an automated approach to detect SATD in source code comments using text mining. In our approach, we utilize feature selection to select useful features for classifier training, and we combine multiple classifiers from different source projects to build a composite classifier that identifies SATD comments in a target project. We investigate the performance of our approach on 8 open source projects that contain 212,413 comments. Our experimental results show that, on every target project, our approach outperforms the state-of-the-art and the baselines approaches in terms of F1-score. The F1-score achieved by our approach ranges between 0.518 - 0.841, with an average of 0.737, which improves over the state-of-the-art approach proposed by Potdar and Shihab by 499.19%. When compared with the text mining-based baseline approaches, our approach significantly improves the average F1-score by at least 58.49%. When compared with a natural language processing-based baseline, our approach also significantly improves its F1-score by 27.95%. Our proposed approach can be used by project personnel to effectively identify SATD with minimal manual effort. © 2017, Springer Science+Business Media New York.",Technical Debt,MSR Studies,"Huang, Q. and Shihab, E. and Xia, X. and Lo, D. and Li, S.",Empirical Software Engineering,"2,018.00",Article,10.1007/s10664-017-9522-4,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85019111869&doi=10.1007%2fs10664-017-9522-4&partnerID=40&md5=bf81dd210ee56c037ad5dcc46f13b901,No,Source code comments;  Technical debt;  Text mining
S183,Read,Accepted,[IC1] - The primary study presents or points to a software artifact that automates a task within at least one TD management activity.,,Integrating traceability within the IDE to prevent requirements documentation debt,"Documentation issues in software projects have been recently classified as a type of technical debt (TD), a concept that express-es how shortcuts during software development result in additional maintenance and evolution effort. The specific type of TD is termed documentation debt, and is among the most prevalent ones in practice and research. In this study we propose a tool-based approach for preventing documentation TD during requirements engineering, by: (a) integrating requirements specifications into the IDE, and (b) enabling the real-time creation of traces between requirements and code. To this end, we collaborated with a small/medium software company and conducted a qualitative case study to: (a) analyze the current process and identify existing TD types, (b) collect the requirements and implement a tool that aims at preventing the accumulation of documentation TD, and (c) investigate whether the tool successfully meets its goal. The results of the study suggest that the developers are motivated to use the developed tool, since they feel that they can develop, maintain and utilize requirements specifications and traces as part of their daily routine. © 2018 IEEE.",Technical Debt,Tool,"Charalampidou, S. and Ampatzoglou, A. and Chatzigeorgiou, A. and Tsiridis, N.","Proceedings - 44th Euromicro Conference on Software Engineering and Advanced Applications, SEAA 2018","2,018.00",Conference Paper,10.1109/SEAA.2018.00075,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85057170768&doi=10.1109%2fSEAA.2018.00075&partnerID=40&md5=f921537113b9bb124888868d43e6bc93,No,Documentation debt;  Requirements;  Traceability
S237,Read,Accepted,[IC1] - The primary study presents or points to a software artifact that automates a task within at least one TD management activity.,,PageRank and criticality of architectural smells,"Architectural smells represent symptoms of problems at architectural level that can negatively impact internal software qualities and lead to architectural debt. Detecting architectural smells and identifying the most critical ones is the key to prioritize refactoring efforts and prevent software architecture erosion. In this paper we focus our attention on three architectural smells based on dependency issues, called Cyclic Dependency, Unstable Dependency, and Hub-Like Dependency. Moreover, we evaluate the PageRank and Criticality of these smells through the analysis of six projects. PageRank is a measure that estimates whether an architectural smell is located in an important part of the project, where the importance is evaluated according to how many parts of a project depend on the one involved in the architectural smell. We describe a case study on the analysis of the possible relation existing between the PageRank and Criticality of the smells. The results show how the two measures can be both used to locate the architectural smells that need particular inspections and attention. © 2019 ACM.",Smells,Tool,"Fontana, F.A. and Pigazzini, I. and Raibulet, C. and Basciano, S. and Roveda, R.",ACM International Conference Proceeding Series,"2,019.00",Conference Paper,10.1145/3344948.3344982,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85079076291&doi=10.1145%2f3344948.3344982&partnerID=40&md5=98fc4f6167a7d21777046eeb3d9e61b3,No,Architectural debt;  Architectural smells;  Architecture erosion;  Criticality;  PageRank;  Prioritization
S196,Read,Accepted,[IC1] - The primary study presents or points to a software artifact that automates a task within at least one TD management activity.,,Are static analysis violations really fixed? a closer look at realistic usage of sonarqube,"The use of automatic static analysis tools (ASATs) has gained increasing attention in the last few years. Even though available research have already explored ASATs issues and how they are fixed, these studies rely on revisions of the software, instead of mining real usage of these tools and real issue reports. In this paper we contribute with a comprehensive, multi-method study about the usage of SonarQube (a popular static analysis tool), mining 421,976 issues from 246 projects in four different instance of SonarQube: two hosted in open-source communities (Eclipse and Apache) and two hosted in Brazilian government institutions (Brazilian Court of Account (TCU) and Brazilian Federal Police (PF)). We first surveyed team leaders of the analyzed projects and found that they mostly consider ASATs warning messages as relevant for overall software improvement. Second, we found that both Eclipse and TCU employ highly customized instance of SonarQube, with more than one thousand distinct checkers-though just a subset of these checkers actually led to issues' reports. Surprisingly, we found a low resolution rate per project in all organizations-on average, 13% of the issues have been solved in the systems. We conjecture that just a subset of the checkers reveal real design and coding flaws, and this might artificially increase the technical debt of the systems. Nevertheless, considering all systems, there is a central tendency(median) of fixing issues after 18.99 days they had been reported, faster than the period for fixing bugs as reported in previous studies. © 2019 IEEE.",TD Symptoms/Consequences,Tool,"Marcilio, D. and Bonifacio, R. and Monteiro, E. and Canedo, E. and Luz, W. and Pinto, G.",IEEE International Conference on Program Comprehension,"2,019.00",Conference Paper,10.1109/ICPC.2019.00040,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85072313164&doi=10.1109%2fICPC.2019.00040&partnerID=40&md5=6310f4a0fdb1ce38295afe2b19bb03eb,No,Empirical Studies;  Mining Software Repositories;  SonarQube;  Static Analysis
S352,Read,Rejected,[EC2] - The study shows a theoretical artifact or do not provide a link to the artifact's repository;,"After reading the full-text, the links provided pointed to no tool.",A Novel Four-Way Approach Designed with Ensemble Feature Selection for Code Smell Detection,"Purpose: Code smells are residuals of technical debt induced by the developers. They hinder evolution, adaptability and maintenance of the software. Meanwhile, they are very beneficial in indicating the loopholes of problems and bugs in the software. Machine learning has been extensively used to predict Code Smells in research. The current study aims to optimise the prediction using Ensemble Learning and Feature Selection techniques on three open-source Java data sets. Design and Results: The work Compares four varied approaches to detect code smells using four performance measures Accuracy(P1), G-mean1 (P2), G-mean2 (P3), and F-measure (P4). The study found out that values of the performance measures did not degrade it instead of either remained same or increased with feature selection and Ensemble Learning. Random Forest turns out to be the best classifier while Correlation-based Feature selection(BFS) is best amongst Feature Selection techniques. Ensemble Learning aggregators, i.e. ET5C2 (BFS intersection Relief with classifier Random Forest), ET6C2 (BFS union Relief with classifier Random Forest), and ET5C1 (BFS intersection Relief with Bagging) and Majority Voting give best results from all the aggregation combinations studied. Conclusion: Though the results are good, but using Ensemble learning techniques needs a lot of validation for a variety of data sets before it can be standardised. The Ensemble Learning techniques also pose a challenge concerning diversity and reliability and hence needs exhaustive studies. © 2013 IEEE.",Smells,Tool,"Kaur, I. and Kaur, A.",IEEE Access,2021,Article,10.1109/ACCESS.2021.3049823,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85106816941&doi=10.1109%2fACCESS.2021.3049823&partnerID=40&md5=bec13ba44e5f67ee6d5e5bfba285ec34,No,Aggregator;  code smell;  ensemble;  feature selection;  machine learning;  open-source projects and performance measures
S202,Read,Accepted,[IC1] - The primary study presents or points to a software artifact that automates a task within at least one TD management activity.,,Reusing Code from StackOverflow: The Effect on Technical Debt,"Software reuse is a well-established software engineering process that aims at improving development productivity. Although reuse can be performed in a systematic way (e.g., through product lines), in practice, reuse is performed in many cases opportunistically, i.e., copying small code chunks either from the web or in-house developed projects. Knowledge sharing communities and especially StackOverflow constitute the primary source of code-related information for amateur and professional software developers. Despite the obvious benefit of increased productivity, reuse can have a mixed effect on the quality of the resulting code depending on the properties of the reused solutions. An efficient concept for capturing a wide-range of internal software qualities is the metaphor of Technical Debt which expresses the impact of shortcuts in software development on its maintenance costs. In this paper, we present the results of an empirical study on the relation between the existence of reusing code retrieved from StackOverflow on the technical debt of the target system. In particular, we study several open-source projects and identify non-trivial pieces of code that exhibit a perfect or near-perfect match with code provided in the context of answers in StackOverflow. Then, we compare the technical debt density of the reused fragments, obtained as the ratio of inefficiencies identified by SonarQube over the lines of reused code, to the technical debt density of the target codebase. The results provide insights to the potential impact of small-scale code reuse on technical debt and highlight the benefits of assessing code quality before committing changes to a repository. © 2019 IEEE.",TD Symptoms/Consequences,Tool,"Digkas, G. and Nikolaidis, N. and Ampatzoglou, A. and Chatzigeorgiou, A.","Proceedings - 45th Euromicro Conference on Software Engineering and Advanced Applications, SEAA 2019","2,019.00",Conference Paper,10.1109/SEAA.2019.00022,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85075985757&doi=10.1109%2fSEAA.2019.00022&partnerID=40&md5=aceb9e6272c234d5810be8ecfd9b82ed,No,Code Reuse;  Software Quality;  StackOverflow;  Technical Debt
S205,Read,Accepted,[IC1] - The primary study presents or points to a software artifact that automates a task within at least one TD management activity.,,CBR insight: Measure and visualize source code quality,"A critical aspect of software development is creating high-quality source code that is reliable, maintainable, and has limited technical debt. Software development teams generally employ a variety of design techniques, processes, and tools to continually work towards quality code while balancing the overall time and budget demands of the project. The goal of CBR Insight (CBRI) is to provide an objective and understandable measure of software quality that can help guide decisions and direct limited resources during software acquisition, development, and sustainment. CBRI supports the ability of technical and non-technical decision makers to verify that a project's software implementation follows through on promises around developing and sustaining reliable and maintainable software while managing technical debt. © 2019 IEEE.",TD Symptoms/Consequences,Tool,"Ludwig, J. and Cline, D.","Proceedings - 2019 IEEE/ACM International Conference on Technical Debt, TechDebt 2019","2,019.00",Conference Paper,10.1109/TechDebt.2019.00017,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85071159465&doi=10.1109%2fTechDebt.2019.00017&partnerID=40&md5=16c1cdadf787a31208e1820cbf8613ba,No,Architecture;  Maintainability;  Metrics;  Reliability;  Software product quality;  Static code analysis;  Technical debt
S204,Read,Accepted,[IC1] - The primary study presents or points to a software artifact that automates a task within at least one TD management activity.,,SARIF-enabled tooling to encourage gradual technical debt reduction,"SARIF is an emerging standard for representing the results of program analysis tools. This tool demo shows how it can enable integration between static analysis tools and version control systems such as GitHub, and by doing so, encourage developers to reduce technical debt in a gradual non-invasive fashion. © 2019 IEEE.",Technical Debt,Tool,"Anderson, P. and Kot, L. and Gilmore, N. and Vitek, D.","Proceedings - 2019 IEEE/ACM International Conference on Technical Debt, TechDebt 2019","2,019.00",Conference Paper,10.1109/TechDebt.2019.00024,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85071167062&doi=10.1109%2fTechDebt.2019.00024&partnerID=40&md5=e24ac2a63e12aa400678d7ac2749b299,No,Dynamic analysis;  Static analysis;  Technical debt reduction
S217,Read,Accepted,[EC2] - The study shows a theoretical artifact or do not provide a link to the artifact's repository;,,Identifying design and requirement self-admitted technical debt using N-gram IDF,"In software projects, technical debt takes place when a developer adopting a trivial solution containing quick and easy shortcuts to implement over a suitable solution that can take a longer time to solve a problem. This can cause major additional costs leading to negative impacts for software maintenance since those shortcuts might need to be reworked in the future. Detecting technical debt early can help a team cope with those risks. In this paper, we focus on Self-Admitted Technical Debt (SATD) that is a debt intentionally produced by developers. We propose an automated model to identify two most common types of self-admitted technical debt, requirement and design debt, from source code comments. We combine N-gram IDF and auto-sklearn machine learning to build the model. With the empirical evaluation on ten projects, our approach outperform the baseline method by improving the performance over 20% when identifying requirement self-admitted technical debt and achieving an average F1-score of 64% when identifying design self-admitted technical debt. © 2018 IEEE.",Technical Debt,Tool,"Wattanakriengkrai, S. and Maipradit, R. and Hata, H. and Choetkiertikul, M. and Sunetnanta, T. and Matsumoto, K.","Proceedings - 2018 9th International Workshop on Empirical Software Engineering in Practice, IWESEP 2018","2,019.00",Conference Paper,10.1109/IWESEP.2018.00010,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85063955510&doi=10.1109%2fIWESEP.2018.00010&partnerID=40&md5=877dc7facce6dff853f440412e6187dd,No,Automated-machine-learning;  Comment-classification;  N-gram-IDF;  Self-admitted-technical-debt
S223,Read,Accepted,[IC1] - The primary study presents or points to a software artifact that automates a task within at least one TD management activity.,,"TETRA, as a set of techniques and tools for calculating technical debt principal and interest","The paper covers the company's proprietary approach to the assessment of software product quality and measurement of technical debt. In the paper, the authors state that the software product quality is the amount of various technical debts embedded into the product and delivered to end-users. Similar to the fact that any debt can be paid, the software product quality can be efficiently managed and measured by a set of techniques, parameters, and dimensions. The authors share the details of the company proprietary approach to technical debt management done with the help of the Technical DebT Reduction plAtform, TETRA. They share the measurement parameters, tools and major dimension for the assessment. © 2019 IEEE.",Technical Debt,Tool,"Kontsevoi, B. and Soroka, E. and Terekhov, S.","Proceedings - 2019 IEEE/ACM International Conference on Technical Debt, TechDebt 2019","2,019.00",Conference Paper,10.1109/TechDebt.2019.00021,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85071151240&doi=10.1109%2fTechDebt.2019.00021&partnerID=40&md5=45b77370afe3f75d5b3ea33b200ad38d,No,Bug;  Fixing;  Measurements;  Metrics;  Quality;  Software;  Technical debt;  Test;  Testing
S224,Read,Accepted,[IC1] - The primary study presents or points to a software artifact that automates a task within at least one TD management activity.,,Teamscale: Tackle technical debt and control the quality of your software,"Teamscale is a software intelligence platform, that is, it creates transparency on code quality and the underlying software development process. This makes it possible for developers, testers and managers to better understand and control technical debt of their systems. In this paper, we give an overview of Teamscale and how this tool can be used in practice to control and lower technical debt in the long run. We explain which code analyses can be used to identify and address technical debt. Teamscale is available for free for research and teaching purposes at www.teamscale.io. © 2019 IEEE.",Technical Debt,Tool,"Haas, R. and Niedermayr, R. and Juergens, E.","Proceedings - 2019 IEEE/ACM International Conference on Technical Debt, TechDebt 2019","2,019.00",Conference Paper,10.1109/TechDebt.2019.00016,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85071178983&doi=10.1109%2fTechDebt.2019.00016&partnerID=40&md5=25043c1f0b9e0e6dd1b923c6234e5be7,No,Quality Control;  Software Quality;  Technical Debt
S226,Read,Accepted,[IC1] - The primary study presents or points to a software artifact that automates a task within at least one TD management activity.,,How deep is the mud: Fathoming architecture technical debt using designite,"The quality of software architecture is an important concern for any software development team. Architecture smells represent quality issues at architecture granularity. Identifying and refactoring them periodically is a necessity to keep architecture quality high. We present Designite, a software design quality assessment tool, that identifies seven well-known architecture smells. Along with the identification, the tool provides supplementary information such as cause and responsible classes for each identified smell instance to help developers understand and refactor the smell. The tool is relevant and useful in both research and practice context. Software developers may use it to identify technical debt instances and to refactor them. On the other hand, software engineering researchers may use the tool to carry out large-scale empirical studies concerning code smells. © 2019 IEEE.",Technical Debt,Tool,"Sharma, T.","Proceedings - 2019 IEEE/ACM International Conference on Technical Debt, TechDebt 2019","2,019.00",Conference Paper,10.1109/TechDebt.2019.00018,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85071171593&doi=10.1109%2fTechDebt.2019.00018&partnerID=40&md5=aab8bc7c7b9be2188266e8f2d6840f2e,No,Architecture smells;  Code Quality;  Code smells;  Maintainability;  Refactoring;  Technical debt
S232,Read,Accepted,[IC1] - The primary study presents or points to a software artifact that automates a task within at least one TD management activity.,,On the Accuracy of SonarQube Technical Debt Remediation Time,"[Context] The popularity of tools for software quality analysis has increased over the years, with special attention to tools that calculate technical debt based on violations of a set of rules. SonarQube is one of the most used tools and provides an estimation of the time needed to remediate technical debt. However, practitioners are still skeptical about the accuracy of its remediation time estimation. [Objective] In this paper, we analyze the accuracy of SonarQube remediation time on a set of 15 open source Java projects. [Method] We designed and conducted a case study where we asked 65 novice developers to remove rule violations and reduce the technical debt of 15 projects. [Results] The results point out that SonarQube remediation time, compared to the actual time for reducing technical debt, is generally overestimated, and that the most accurate estimation relates to code smells, while the least accurate concerns bugs. [Conclusions] Practitioners and researchers could benefit from the results of this work to understand up to which extent technical debt is overestimated and have a more accurate estimation of the remediation time.? © 2019 IEEE.",Technical Debt,Tool,"Saarimaki, N. and Baldassarre, M.T. and Lenarduzzi, V. and Romano, S.","Proceedings - 45th Euromicro Conference on Software Engineering and Advanced Applications, SEAA 2019","2,019.00",Conference Paper,10.1109/SEAA.2019.00055,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85075990807&doi=10.1109%2fSEAA.2019.00055&partnerID=40&md5=2f05fe27d979e0d3dfeaf5c4072a2de3,No,code smells;  effort estimation;  remediation time;  Technical debt
S240,Read,Accepted,[IC1] - The primary study presents or points to a software artifact that automates a task within at least one TD management activity.,,Automatic Classifying Self-Admitted Technical Debt Using N-Gram IDF,"Technical Debt (TD) introduces a quality problem and increases maintenance cost since it may require improvements in the future. Several studies show that it is possible to automatically detect TD from source code comments that developers intentionally created, so-called self-admitted technical debt (SATD). Those studies proposed to use binary classification technique to predict whether a comment shows SATD. However, SATD has different types (e.g. design SATD and requirement SATD). In this paper, we therefore propose an approach using N-gram Inverse Document Frequency (IDF) and employ a multi-class classification technique to build a model that can identify different types of SATD. From the empirical evaluation on 10 open-source projects, our approach outperforms alternative methods (e.g. using BOW and TF-IDF). Our approach also improves the prediction performance over the baseline benchmark by 33%. © 2019 IEEE.",Technical Debt,Tool,"Wattanakriengkrai, S. and Srisermphoak, N. and Sintoplertchaikul, S. and Choetkiertikul, M. and Ragkhitwetsagul, C. and Sunetnanta, T. and Hata, H. and Matsumoto, K.","Proceedings - Asia-Pacific Software Engineering Conference, APSEC","2,019.00",Conference Paper,10.1109/APSEC48747.2019.00050,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85078087442&doi=10.1109%2fAPSEC48747.2019.00050&partnerID=40&md5=c9b36f217cbe918e926ea52fb8e3529f,No,Multi class Classification;  N-Gram IDF;  Self Admitted Technical Debt
S277,Read,Rejected,[EC2] - The study shows a theoretical artifact or do not provide a link to the artifact's repository;,"After the reading, it does not automate any TD activity",Capture the Feature Flag: Detecting Feature Flags in Open-Source,"Feature flags (a.k.a feature toggles) are a mechanism to keep new features hidden behind a boolean option during development. Flags are used for many purposes, such as A/B testing and turning off a feature more easily in case of failures. While software engineering research on feature flags is burgeoning, examples of software projects using flags rarely come from outside commercial and private projects, stifling academic progress. To address this gap, in this paper we present a novel semi-automated mining software repositories approach to detect feature flags in open-source projects, based on analyzing the projects' commit messages and other project characteristics. With our approach, we search over all open-source GitHub projects, finding multiple thousand plausible and active candidate feature flagging projects. We manually validate projects and assemble a dataset of 100 confirmed feature flagging projects. To demonstrate the benefits of our detection technique, we report on an initial analysis of feature flags in the validated sample of 100 projects, investigating practices that correlate with shorter flag lifespans (typically desirable to reduce technical debt), such as using the issue tracker and having a flag owner. © 2020 ACM.",TD Symptoms/Consequences,Tool,"Meinicke, J. and Hoyos, J. and Vasilescu, B. and Kästner, C.","Proceedings - 2020 IEEE/ACM 17th International Conference on Mining Software Repositories, MSR 2020",2020,Conference Paper,10.1145/3379597.3387463,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85093692563&doi=10.1145%2f3379597.3387463&partnerID=40&md5=b6b31cfb308f3235a2c7b044b5a137f3,No,
S249,Read,Accepted,[IC1] - The primary study presents or points to a software artifact that automates a task within at least one TD management activity.,,Mitigating technical and architectural debt with sonargraph,"Sonargraph is a static analyzer with a focus on software architecture and metrics. The motivation to create Sonargraph came from the assumption that architectural debt (aka structural debt) is the most toxic form of technical debt. Repairing a broken architecture requires global and high-risk changes, while fixing other forms of technical debt mostly involves low-risk local changes. Therefore, the tool enables architects and developers to formally describe their architectural blueprint using a custom DSL (domain specific language). Once defined architectural rules can be checked and enforced in an automated way in all stages of the development process. This guarantees that a software system will never end up as the notorious 'big ball of mud'. Sonargraph currently supports Java, C#, C/C++ and Python and is used by hundreds of organizations worldwide. © 2019 IEEE.",Technical Debt,Tool,"Von Zitzewitz, A.","Proceedings - 2019 IEEE/ACM International Conference on Technical Debt, TechDebt 2019","2,019.00",Conference Paper,10.1109/TechDebt.2019.00022,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85071188204&doi=10.1109%2fTechDebt.2019.00022&partnerID=40&md5=6413dc6b96fef31b99caa3cbdec5c6e7,No,Architectural debt;  Software architecture enforcement;  Software metrics
S250,Read,Accepted,[IC1] - The primary study presents or points to a software artifact that automates a task within at least one TD management activity.,,A Study on Architectural Smells Prediction,"Architectural smells can be detrimental to the system maintainability, evolvability and represent a source of architectural debt. Thus, it is very important to be able to understand how they evolved in the past and to predict their future evolution. In this paper, we evaluate if the existence of architectural smells in the past versions of a project can be used to predict their presence in the future. We analyzed four Java projects in 295 Github releases and we applied for the prediction four different supervised learning models in a repeated cross-validation setting. We found that historical architectural smell information can be used to predict the presence of architectural smells in the future. Hence, practitioners should carefully monitor the evolution of architectural smells and take preventative actions to avoid introducing them and stave off their progressive growth. © 2019 IEEE.",Smells,Tool,"Arcelli Fontana, F. and Avgeriou, P. and Pigazzini, I. and Roveda, R.","Proceedings - 45th Euromicro Conference on Software Engineering and Advanced Applications, SEAA 2019","2,019.00",Conference Paper,10.1109/SEAA.2019.00057,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85075999048&doi=10.1109%2fSEAA.2019.00057&partnerID=40&md5=3a9d32f3dff27ced9892d892d6cc3c7a,No,Architectural smells prediction and evolution;  architectural technical debt
S208,Read,Accepted,[IC1] - The primary study presents or points to a software artifact that automates a task within at least one TD management activity.,,DV8: Automated architecture analysis tool suites,"This paper present our tool suite called DV8. The objective of DV8 is to measure software modularity, detect architecture anti-patterns as technical debts, quantify the maintenance cost of each instance of an anti-pattern, and enable return on investment analyses of architectural debts. Different from other tools, DV8 integrates data from both source code and revision history. We now elaborate on each of DV8's capabilities. © 2019 IEEE.",TD Symptoms/Consequences,Tool,"Cai, Y. and Kazman, R.","Proceedings - 2019 IEEE/ACM International Conference on Technical Debt, TechDebt 2019","2,019.00",Conference Paper,10.1109/TechDebt.2019.00015,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85071149050&doi=10.1109%2fTechDebt.2019.00015&partnerID=40&md5=22f9dfbe637f4a701ab9b991db9e32bf,No,Software Architecture;  Software Maintenance;  Software Quality
S225,Read,Accepted,[IC1] - The primary study presents or points to a software artifact that automates a task within at least one TD management activity.,,CodeArena: Inspecting and improving code quality metrics using minecraft,"To minimize technical debt and increase the maintainability of software, it is essential to make developers aware of what factors influence the maintainability of a codebase. To make the field of code quality and maintenance intuitive to developers, we propose CodeArena, which is an extension to the popular 3D sandbox game called Minecraft. CodeArena converts patterns in a codebase that are considered harmful to monsters in Minecraft, which can then be fought to improve the codebase. This way, the developer can gradually improve the quality of the code, while learning about code quality in an engaging way. © 2019 IEEE.",TD Symptoms/Consequences,Tool,"Baars, S. and Meester, S.","Proceedings - 2019 IEEE/ACM International Conference on Technical Debt, TechDebt 2019","2,019.00",Conference Paper,10.1109/TechDebt.2019.00023,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85071172389&doi=10.1109%2fTechDebt.2019.00023&partnerID=40&md5=1ce7377525db108d721382c8d2cfd969,No,Code Metrics;  Code Quality;  Education;  Gamification;  Maintainability;  Minecraft;  Rascal;  Software Evolution
S228,Read,Accepted,[IC1] - The primary study presents or points to a software artifact that automates a task within at least one TD management activity.,,Towards an autonomous bot for automatic source code refactoring,"Continuous refactoring is necessary to maintain source code quality and to cope with technical debt. Since manual refactoring is inefficient and error-prone, various solutions for automated refactoring have been proposed in the past. However, empirical studies have shown that these solutions are not widely accepted by software developers and most refactorings are still performed manually. For example, developers reported that refactoring tools should support functionality for reviewing changes. They also criticized that introducing such tools would require substantial effort for configuration and integration into the current development environment. In this paper, we present our work towards the Refactoring-Bot, an autonomous bot that integrates into the team like a human developer via the existing version control platform. The bot automatically performs refactorings to resolve code smells and presents the changes to a developer for asynchronous review via pull requests. This way, developers are not interrupted in their workflow and can review the changes at any time with familiar tools. Proposed refactorings can then be integrated into the code base via the push of a button. We elaborate on our vision, discuss design decisions, describe the current state of development, and give an outlook on planned development and research activities. © 2019 IEEE.",TD Symptoms/Consequences,Tool,"Wyrich, M. and Bogner, J.","Proceedings - 2019 IEEE/ACM 1st International Workshop on Bots in Software Engineering, BotSE 2019","2,019.00",Conference Paper,10.1109/BotSE.2019.00015,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85072925071&doi=10.1109%2fBotSE.2019.00015&partnerID=40&md5=0f8442e1490f56458ca00ccc7aa92b66,No,Bot;  Code smells;  Maintainability;  Refactoring;  Software evolution;  Software quality improvement
S212,Read,Accepted,[IC1] - The primary study presents or points to a software artifact that automates a task within at least one TD management activity.,,Identification of Self-Admitted Technical Debt Using Enhanced Feature Selection Based on Word Embedding,"Self-admitted technical debt (SATD) is annotated in source code comments by developers and has been recognized as a great source of discovering flawed software. To reduce manual effort, some recent studies have focused on automated detection of SATD using text classification methods. To train their classifier, these methods need labeled samples, which also require a lot of effort to obtain. We developed a new SATD identification method, which takes advantage of a large corpus of unlabeled code comments, extracted from open source projects, to train a word embedding model. After applying feature selection, the pre-trained word embedding is used for discovering semantically similar features in source code comments to enhance the original feature set. By using such enhanced feature set for classification, our goal was to improve the identification of SATD when compared to existing methods. The proposed feature enhancement method was used with the three most common feature selection methods (CHI, IG, and MI), and three well-known text classification algorithms (NB, SVM, and ME) and was tested on ten open source projects. The experimental results show a significant improvement in SATD identification over the compared methods. With an achieved 82% of correct predictions of SATD, the proposed method seems to be a good candidate to be adopted in practice. © 2013 IEEE.",Technical Debt,Tool,"Flisar, J. and Podgorelec, V.",IEEE Access,"2,019.00",Article,10.1109/ACCESS.2019.2933318,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85071142564&doi=10.1109%2fACCESS.2019.2933318&partnerID=40&md5=07d8d7c4cdc5cdb07cce1aa595c35180,No,Feature enhancement;  feature selection;  self-admitted technical debt;  text classification;  word embedding
S216,Read,Accepted,[IC1] - The primary study presents or points to a software artifact that automates a task within at least one TD management activity.,,Is Self-Admitted Technical Debt a Good Indicator of Architectural Divergences?,"Large software systems tend to be highly complex and often contain unaddressed issues that evolve from bad design practices or architectural implementations that drift from definition. These design flaws can originate from quick fixes, hacks or shortcuts to a solution, hence they can be seen as Technical Debt. Recently, new work has focused on studying source code comments that indicate Technical Debt, i.e., Self-Admitted Technical Debt (SATD). However, it is not known if addressing information left by developers in the form source code comments can give insight about the design flaws in a system and have the potential to provide fixes for bad architectural implementations. This paper investigates the possibility of using SATD comments to resolve architectural divergences. We leverage a data set of previously classified SATD comments to trace them to the architectural divergences of a large open source system, namely ArgoUML. We extract its conceptual and concrete architectures based on available design documentation and source code, and contrast both to expose divergences, trace them to SATD comments, and investigate their resolution. We found 7 high-level divergences in ArgoUML and 22 others among its subsystems, observing that merely 4 out of 29 (14%) divergences can be directly traced to SATD. Although using SATD as an indicator of architectural divergences is viable, the effort of doing so is time-intensive, and in general, will not lend to a significant reduction of architectural flaws in a software system. © 2019 IEEE.",Technical Debt,Tool,"Sierra, G. and Tahmid, A. and Shihab, E. and Tsantalis, N.","SANER 2019 - Proceedings of the 2019 IEEE 26th International Conference on Software Analysis, Evolution, and Reengineering","2,019.00",Conference Paper,10.1109/SANER.2019.8667999,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85064167604&doi=10.1109%2fSANER.2019.8667999&partnerID=40&md5=00e712d60a9c3464eac77d48241f7b48,No,Architecture Recovery;  Self-Admitted Technical Debt;  Software Architecture;  Software Re-Engineering
S241,Read,Accepted,[IC1] - The primary study presents or points to a software artifact that automates a task within at least one TD management activity.,,Understanding automated and human-based technical debt identification approaches-a two-phase study,"Context: The technical debt (TD) concept inspires the development of useful methods and tools that support TD identification and management. However, there is a lack of evidence on how different TD identification tools could be complementary and, also, how human-based identification compares with them. Objective: To understand how to effectively elicit TD from humans, to investigate several types of tools for TD identification, and to understand the developers’ point of view about TD indicators and items reported by tools. Method: We asked developers to identify TD items from a real software project. We also collected the output of three tools to automatically identify TD and compared the results in terms of their locations in the source code. Then, we collected developers’ opinions on the identification process through a focus group. Results: Aggregation seems to be an appropriate way to combine TD reported by developers. The tools used cannot help in identifying many important TD types, so involving humans is necessary. Developers reported that the tools would help them to identify TD faster or more accurately and that project priorities and current development activities are important to be considered together, along with the values of principal and interest, when deciding to pay off a debt. Conclusion: This work contributes to the TD landscape, which depicts an understanding between different TD types and how they are best discovered. © 2019, The Author(s).",Technical Debt,Tool,"Spínola, R.O. and Zazworka, N. and Vetro, A. and Shull, F. and Seaman, C.",Journal of the Brazilian Computer Society,"2,019.00",Article,10.1186/s13173-019-0087-5,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85066956327&doi=10.1186%2fs13173-019-0087-5&partnerID=40&md5=e1adbe6d7c21493e4672d5a742ecd865,No,Automated technical debt identification;  Human-based technical debt identification;  Technical debt
S245,Read,Accepted,[IC1] - The primary study presents or points to a software artifact that automates a task within at least one TD management activity.,,Neural network-based detection of self-Admitted technical debt: From performance to explainability,"Technical debt is a metaphor to reflect the tradeoff software engineers make between short-Term benefits and long-Term stability. Self-Admitted technical debt (SATD), a variant of technical debt, has been proposed to identify debt that is intentionally introduced during software development, e.g., temporary fixes and workarounds. Previous studies have leveraged human-summarized patterns (which represent n-gram phrases that can be used to identify SATD) or text-mining techniques to detect SATD in source code comments. However, several characteristics of SATD features in code comments, such as vocabulary diversity, project uniqueness, length, and semantic variations, pose a big challenge to the accuracy of pattern or traditional text-mining-based SATD detection, especially for cross-project deployment. Furthermore, although traditional text-mining-based method outperforms pattern-based method in prediction accuracy, the text features it uses are less intuitive than human-summarized patterns, which makes the prediction results hard to explain. To improve the accuracy of SATD prediction, especially for cross-project prediction, we propose a Convolutional Neural Network (CNN) based approach for classifying code comments as SATD or non-SATD. To improve the explainability of our model's prediction results, we exploit the computational structure of CNNs to identify key phrases and patterns in code comments that are most relevant to SATD. We have conducted an extensive set of experiments with 62,566 code comments from 10 open-source projects and a user study with 150 comments of another three projects. Our evaluation confirms the effectiveness of different aspects of our approach and its superior performance, generalizability, adaptability, and explainability over current state-of-The-Art traditional text-mining-based methods for SATD classification. © 2019 Association for Computing Machinery. All rights reserved.",Technical Debt,Tool,"Ren, X. and Xing, Z. and Xia, X. and Lo, D. and Wang, X. and Grundy, J.",ACM Transactions on Software Engineering and Methodology,"2,019.00",Article,10.1145/3324916,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85075020632&doi=10.1145%2f3324916&partnerID=40&md5=999bb85d4d49055dd77ca73552f91fe7,No,Convolutional neural network;  cross project prediction;  Model adaptability;  model explainability;  Model generalizability;  Self-Admitted technical debt
S19,Read,Rejected,[EC2] - The study shows a theoretical artifact or do not provide a link to the artifact's repository;,"Afte the full reading, the study does not point to a tool. Moreover, the proposed tool is not available on any repository",A Decision-Support System Approach to Economics-Driven Modularity Evaluation,"Modularity debt is the most difficult kind of technical debt to quantify and manage. Modularity decay, thus modularity debt, causes huge losses over time in terms of reduced ability to provide new functionality and fix bugs, operational failures, and even canceled projects. As modularity debt accumulates over time, software system managers are often faced with a challenging task of deciding when and whether to refactor, for example, choosing to improve modularity or not. While the costs of refactoring are significant and immediate, their benefits are largely invisible, intangible, and long term. Existing research lacks effective methods to quantify the costs and benefits of refactoring to support refactoring decision making. In this chapter, we present a decision-support system (DSS) approach to the modularity debt management. Using such a system, managers would be able to play out various ""what-if"" scenarios to make informed decisions regarding refactoring. Our DSS approach is built on a scientific foundation for explicitly manifesting the economic implications of software refactoring activities so that the costs and benefits of such activities can be understood, analyzed, and predicted. We discuss our contributions and current progress in developing the building blocks and the underpinning framework, an integrated economics-driven modularization evaluation framework, for the modularity debt management decision-support system (MDM-DSS). © 2014 Elsevier Inc. All rights reserved.",Technical Debt,Tool,"Cai, Y. and Kazman, R. and Silva, C.V.A. and Xiao, L. and Chen, H.-M.",Economics-Driven Software Architecture,2014,Book Chapter,10.1016/B978-0-12-410464-8.00006-4,https://www.scopus.com/inward/record.uri?eid=2-s2.0-84921686423&doi=10.1016%2fB978-0-12-410464-8.00006-4&partnerID=40&md5=a111cacf63ad314250f3906e6478f944,No,Complexity Metrics;  Effort Measures;  Real options;  Refactoring;  Software Architecture;  Software Modularity;  Technical Debt
S246,Read,Accepted,[IC1] - The primary study presents or points to a software artifact that automates a task within at least one TD management activity.,,VisminerTD: a tool for automatic identification and interactive monitoring of the evolution of technical debt items,"Technical debt (TD) contextualizes problems faced during software evolution considering the tasks that are not carried out adequately during software development. Software TD is a type of debt that brings a short-term benefit, but which may have to be paid with interest later on in the software development life cycle. Its presence brings risks to the project and can reduce its quality. It is worthwhile to have automatic mechanisms to monitor it, as TD monitoring requires the analysis of large amounts of complex data. Therefore, the combination of software metrics and code comment analysis, in the identification, and information visualization techniques, in monitoring, present themselves as a promising strategy to manage TD. This work presents VisminerTD, a tool that allows the automatic identification and interactive monitoring of the evolution of TD items by combining software metrics, code comment analysis, and information visualization. To evaluate its applicability, a feasibility study was carried out considering JUnit 4 and Apache Ant software projects. The results indicated that VisminerTD can support software development teams in monitoring TD items. In addition, a second case study was performed to assess the feasibility of the proposed tool regarding its usefulness, ease of use, and self-predicted future use. The results provided positive evidence on the use of the proposed tool, indicating (i) that it can be useful in supporting TD Identification and TD monitoring activities and (ii) that it can bring gains in terms of comprehensiveness and efficacy when evaluating the desirable time to identify and monitor different types of debt. Given the current scenario characterized by limited options of tools that combine different information to support automatic identification and monitoring of the evolution of TD items in software projects, VisminerTD can approximate the state-of-the-art and the state-of-the-practice in the TD area, contributing to a wider dissemination of the concept. © 2019, The Author(s).",Technical Debt,Tool,"Mendes, T.S. and Gomes, F.G.S. and Gonçalves, D.P. and Mendonça, M.G. and Novais, R.L. and Spínola, R.O.",Journal of the Brazilian Computer Society,"2,019.00",Article,10.1186/s13173-018-0083-1,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85060256649&doi=10.1186%2fs13173-018-0083-1&partnerID=40&md5=c21c544db4400d0adf9f90a1f2fe7b5a,No,Software evolution;  Software visualization;  Technical debt;  Technical debt identification;  Technical debt monitoring
S248,Read,Accepted,[IC1] - The primary study presents or points to a software artifact that automates a task within at least one TD management activity.,,The technical debt dataset,"Technical Debt analysis is increasing in popularity as nowadays researchers and industry are adopting various tools for static code analysis to evaluate the quality of their code. Despite this, empirical studies on software projects are expensive because of the time needed to analyze the projects. In addition, the results are dificult to compare as studies commonly consider different projects. In this work, we propose the Technical Debt Dataset, a curated set of project measurement data from 33 Java projects from the Apache Software Foundation. In the Technical Debt Dataset, we analyzed all commits from separately defined time frames with SonarQube to collect Technical Debt information and with Ptidej to detect code smells. Moreover, we extracted all available commit information from the git logs, the refactoring applied with Refactoring Miner, and fault information reported in the issue trackers (Jira). Using this information, we executed the SZZ algorithm to identify the fault-inducing and - fixing commits. We analyzed 78K commits from the selected 33 projects, detecting 1.8M SonarQube issues, 62K code smells, 28K faults and 57K refactorings. The project analysis took more than 200 days. In this paper, we describe the data retrieval pipeline together with the tools used for the analysis. The dataset is made available through CSV files and an SQLite database to facilitate queries on the data. The Technical Debt Dataset aims to open up diverse opportunities for Technical Debt research, enabling researchers to compare results on common projects. © 2019 Association for Computing Machinery.",Technical Debt,Tool,"Lenarduzzi, V. and Saarimäki, N. and Taibi, D.",ACM International Conference Proceeding Series,"2,019.00",Conference Paper,10.1145/3345629.3345630,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85076086059&doi=10.1145%2f3345629.3345630&partnerID=40&md5=bdfaeb0f9a84ed38cc34121b48587893,No,Dataset;  Faults;  Mining software repository;  Software quality;  SonarQube;  SZZ;  Technical debt
S221,Read,Rejected,[EC2] - The study shows a theoretical artifact or do not provide a link to the artifact's repository;,"After the full reading, the study seems more a related work than a primary study. It was included in the related works table",Architectural smells detected by tools: A catalogue proposal,"Architectural smells can negatively impact on different software qualities and can represent a relevant source of architectural debt. Several architectural smells have been defined by different researchers. Moreover, both academia and industry proposed several tools for software quality analysis, but it is not always clear to understand which tools provide also support for architectural smells detection and if the tools developed for this specific purpose are effectively available or not. In this paper we propose a catalogue of architectural smells for which, at least one tool able to detect the smell exists. We outline the main differences in the detection techniques exploited by the tools and we propose a classification of these architectural smells according to the violation of three design principles. © 2019 IEEE.",Technical Debt,Tool,"Azadi, U. and Fontana, F.A. and Taibi, D.","Proceedings - 2019 IEEE/ACM International Conference on Technical Debt, TechDebt 2019",2019,Conference Paper,10.1109/TechDebt.2019.00027,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85069684857&doi=10.1109%2fTechDebt.2019.00027&partnerID=40&md5=bbb87e11dd15f7c9c0f3c9f16e1a6000,No,Architectural Debt;  Architectural Smells;  Architectural Smells Catalogue;  Architectural Smells Detection
S206,Read,Accepted,[IC1] - The primary study presents or points to a software artifact that automates a task within at least one TD management activity.,,Software Architecture Social Debt: Managing the Incommunicability Factor,"Architectural technical debt is the additional project cost connected to technical issues nested in software architectures. Similarly, many practitioners have already experienced that there exists within software architectures a form of social debt, that is, the additional project cost connected to sociotechnical and organizational issues evident in or related to software architectures. This paper illustrates four recurrent antipatterns or community smells connected to such architectural social debt and outlines a means to measure the additional project cost connected to their underlying cause: decision incommunicability. Evaluating the results in multiple focus groups, this paper concludes that studying social debt and community smells at the architecture level may prove vital to rid software development communities of critical organizational flaws incurring considerable additional cost. © 2014 IEEE.",TD Symptoms/Consequences,Theoretical Artifact,"Tamburri, D.A.",IEEE Transactions on Computational Social Systems,"2,019.00",Article,10.1109/TCSS.2018.2886433,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85061655975&doi=10.1109%2fTCSS.2018.2886433&partnerID=40&md5=e6693e173e86e6f5ee46cff0ae2f0a06,No,Social debt;  social debt cost estimation;  social debt in software architecting;  technical debt
S235,Read,Accepted,[IC1] - The primary study presents or points to a software artifact that automates a task within at least one TD management activity.,,Towards surgically-precise technical debt estimation: Early results and research roadmap,"The concept of technical debt has been explored from many perspectives but its precise estimation is still under heavy empirical and experimental inquiry. We aim to understand whether, by harnessing approximate, data-driven, machine-learning approaches it is possible to improve the current techniques for technical debt estimation, as represented by a top industry quality analysis tool such as SonarQube. For the sake of simplicity, we focus on relatively simple regression modelling techniques and apply them to modelling the additional project cost connected to the sub-optimal conditions existing in the projects under study. Our results shows that current techniques can be improved towards a more precise estimation of technical debt and the case study shows promising results towards the identification of more accurate estimation of technical debt. © 2019 Association for Computing Machinery.",Technical Debt,Theoretical Artifact,"Lenarduzzi, V. and Martini, A. and Taibi, D. and Tamburri, D.A.","MaLTeSQuE 2019 - Proceedings of the 3rd ACM SIGSOFT International Workshop on Machine Learning Techniques for Software Quality Evaluation, co-located with ESEC/FSE 2019","2,019.00",Conference Paper,10.1145/3340482.3342747,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85076086180&doi=10.1145%2f3340482.3342747&partnerID=40&md5=226757cee7c7d2f7fdaf63be77e79886,No,Empirical Study;  Machine Learning;  Technical Debt
S200,Read,Accepted,[EC2] - The study shows a theoretical artifact or do not provide a link to the artifact's repository;,,Investigating Instability Architectural Smells Evolution: An Exploratory Case Study,"Architectural smells may substantially increase maintenance effort and thus require extra attention for potential refactoring. While we currently understand this concept and have identified different types of such smells, we have not yet studied their evolution in depth. This is necessary to inform their prioritisation and refactoring. This study analyses the evolution of individual architectural smell instances over time, and the characteristics that define these instances. Three different types of architectural smells are taken into consideration and mined from a total of 524 versions across 14 different projects. The results show how different smell types differ in multiple aspects, such as their growth rate, the importance of the affected elements over time in the dependency network of the system, and the time each instance affects the system. They also cast valuable insights on what aspects are the most important to consider during prioritisation and refactoring activities. © 2019 IEEE.",Smells,MSR Studies,"Sas, D. and Avgeriou, P. and Arcelli Fontana, F.","Proceedings - 2019 IEEE International Conference on Software Maintenance and Evolution, ICSME 2019","2,019.00",Conference Paper,10.1109/ICSME.2019.00090,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85077211646&doi=10.1109%2fICSME.2019.00090&partnerID=40&md5=1e9e0b24f0719965ce52d9b76a0d2df2,No,architectural smells;  architectural smells evolution;  architectural technical debt;  cyclic dependencies;  technical debt
S229,Read,Accepted,[IC1] - The primary study presents or points to a software artifact that automates a task within at least one TD management activity.,,Are architectural smells independent from code smells? An empirical study,"Background. Architectural smells and code smells are symptoms of bad code or design that can cause different quality problems, such as faults, technical debt, or difficulties with maintenance and evolution. Some studies show that code smells and architectural smells often appear together in the same file. The correlation between code smells and architectural smells, however, is not clear yet; some studies on a limited set of projects have claimed that architectural smells can be derived from code smells, while other studies claim the opposite. Objective. The goal of this work is to understand whether architectural smells are independent from code smells or can be derived from a code smell or from one category of them. Method. We conducted a case study analyzing the correlations among 19 code smells, six categories of code smells, and four architectural smells. Results. The results show that architectural smells are correlated with code smells only in a very low number of occurrences and therefore cannot be derived from code smells. Conclusion. Architectural smells are independent from code smells, and therefore deserve special attention by researchers, who should investigate their actual harmfulness, and practitioners, who should consider whether and when to remove them. © 2019 Elsevier Inc.",Smells,MSR Studies,"Arcelli Fontana, F. and Lenarduzzi, V. and Roveda, R. and Taibi, D.",Journal of Systems and Software,"2,019.00",Article,10.1016/j.jss.2019.04.066,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85064869442&doi=10.1016%2fj.jss.2019.04.066&partnerID=40&md5=8334052a5794276a00b59c0c89ab5a37,No,Architectural smells;  Code smells;  Empirical analysis;  Technical debt
S214,Read,Accepted,[IC1] - The primary study presents or points to a software artifact that automates a task within at least one TD management activity.,,Evolution of technical debt: An exploratory study,"Context: Technical debt is known to impact maintainability of software. As source code files grow in size, maintainability becomes more challenging. Therefore, it is expected that the density of technical debt in larger files would be reduced for the sake of maintainability. Objective: This exploratory study investigates whether a newly introduced metric ‘technical debt density trend’ helps to better understand and explain the evolution of technical debt. The ‘technical debt density trend’ metric is the slope of the line of two successive ‘technical debt density’ measures corresponding to the ‘lines of code’ values of two consecutive revisions of a source code file. Method: This study has used 11,822 commits or revisions of 4,013 Java source files from 21 open source projects. For the technical debt measure, SonarQube tool is used with 138 code smells. Results: This study finds that ‘technical debt density trend’ metric has interesting characteristics that make it particularly attractive to understand the pattern of accrual and repayment of technical debt by breaking down a technical debt measure into multiple components, e.g., ‘technical debt density’ can be broken down into two components showing mean density corresponding to revisions that accrue technical debt and mean density corresponding to revisions that repay technical debt. The use of ‘technical debt density trend’ metric helps us understand the evolution of technical debt with greater insights. Copyright © 2019 for this paper by its authors.",Technical Debt,MSR Studies,"Mamun, M.A.A. and Martini, A. and Staron, M. and Berger, C. and Hansson, J.",CEUR Workshop Proceedings,"2,019.00",Conference Paper,,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85074108547&partnerID=40&md5=5d1793f1196b1120954ded5ca0f5d436,No,Code debt;  Code smells;  Slope of technical debt density;  Software metrics;  Technical debt;  Technical debt density;  Technical debt density trend
S218,Read,Accepted,[IC1] - The primary study presents or points to a software artifact that automates a task within at least one TD management activity.,,On the diffuseness of code technical debt in open source projects,"Background. Companies commonly invest majorBackground. Companies commonly invest major effort into removing, respectively not introducing, technical debt issues detected by static analysis tools such as SonarQube, Cast, or Coverity. These tools classify technical debt issues into categories according to severity, and developers commonly pay attention to not introducing issues with a high level of severity that could generate bugs or make software maintenance more difficult. Objective. In this work, we aim to understand the diffuseness of Technical Debt (TD) issues and the speed with which developers remove them from the code if they introduced such an issue. The goal is to understand which type of TD is more diffused and how much attention is paid by the developers, as well as to investigate whether TD issues with a higher level of severity are resolved faster than those with a lower level of severity. We conducted a case study across 78K commits of 33 Java projects from the Apache Software Foundation Ecosystem to investigate the distribution of 1.4M TD items. Results. TD items introduced into the code are mostly related to code smells (issues that can increase the maintenance effort). Moreover, developers commonly remove the most severe issues faster than less severe ones. However, the time needed to resolve issues increases when the level of severity increases (minor issues are removed faster that blocker ones). Conclusion. One possible answer to the unexpected issue of resolution time might be that severity is not correctly defined by the tools. Another possible answer is that the rules at an intermediate severity level could be the ones that technically require more time to be removed. The classification of TD items, including their severity and type, require thorough investigation from a research point of view.effort into removing, respectively not introducing, technical debtissues detected by static analysis tools such as SonarQube, Cast, or Coverity. These tools classify technical debt issues intocategories according to severity, and developers commonly payattention to not introducing issues with a high level of severitythat could generate bugs or make software maintenance moredifficult. Objective. In this work, we aim to understand the diffuseness ofTechnical Debt (TD) issues and the speed with which developersremove them from the code if they introduced such an issue. The goal is to understand which type of TD is more diffusedand how much attention is paid by the developers, as well asto investigate whether TD issues with a higher level of severityare resolved faster than those with a lower level of severity. Weconducted a case study across 78K commits of 33 Java projectsfrom the Apache Software Foundation Ecosystem to investigatethe distribution of 1.4M TD items. Results. TD items introduced into the code are mostly relatedto code smells (issues that can increase the maintenance effort). Moreover, developers commonly remove the most severe issuesfaster than less severe ones. However, the time needed to resolveissues increases when the level of severity increases (minor issuesare removed faster that blocker ones). Conclusion. One possible answer to the unexpected issue ofresolution time might be that severity is not correctly definedby the tools. Another possible answer is that the rules at anintermediate severity level could be the ones that technicallyrequire more time to be removed. The classification of TD items, including their severity and type, require thorough investigationfrom a research point of view. © 2019 IEEE.",Technical Debt,MSR Studies,"Lenarduzzi, V. and Saarimaki, N. and Taibi, D.","Proceedings - 2019 IEEE/ACM International Conference on Technical Debt, TechDebt 2019","2,019.00",Conference Paper,10.1109/TechDebt.2019.00028,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85064864413&doi=10.1109%2fTechDebt.2019.00028&partnerID=40&md5=5ecf686d362b504daff0ae69036e9d3b,No,SonarQube;  Technical Debt;  Violations
S244,Read,Accepted,[IC1] - The primary study presents or points to a software artifact that automates a task within at least one TD management activity.,,Influence of Developer Factors on Code Quality: A Data Study,"Automatic source-code inspection tools help to assess, monitor and improve code quality. Since these tools only examine the software project's codebase, they overlook other possible factors that may impact code quality and the assessment of the technical debt (TD). Our initial hypothesis is that human factors associated with the software developers, like coding expertise, communication skills, and experience in the project have some measurable impact on the code quality. In this exploratory study, we test this hypothesis on two large open source repositories, using TD as a code quality metric and the data that may be inferred from the version control systems. The preliminary results of our statistical analysis suggest that the level of participation of the developers and their experience in the project have a positive correlation with the amount of TD that they introduce. On the contrary, communication skills have barely any impact on TD. © 2019 IEEE.",Technical Debt,MSR Studies,"Salamea, M.J. and Farre, C.","Proceedings - Companion of the 19th IEEE International Conference on Software Quality, Reliability and Security, QRS-C 2019","2,019.00",Conference Paper,10.1109/QRS-C.2019.00035,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85073879722&doi=10.1109%2fQRS-C.2019.00035&partnerID=40&md5=938b482a6da6fbe7401a8dd93f317e48,No,code quality;  data mining;  human factors;  technical debt
S263,Read,Accepted,[IC1] - The primary study presents or points to a software artifact that automates a task within at least one TD management activity.,,Sen4Smells: A tool for ranking sensitive smells for an architecture debt index,"Technical debt indexes are metrics for assessing the quality of a software system. Both academic and commercial tools have begun to provide computations of such indexes based on design violations and smells (e.g., cycles among system elements). When computing a debt index for a given project, a common use case is that engineers look at the index values for spotting design issues that negatively affect system evolution and quality. In this context, those smells being critical for the system architecture should be promptly identified soastoe valuate proper remediation actions. However, the interpretation of an index value in terms of problematic smells is usually a manual and labor-intensive task for engineers. To help with this task, we propose a tool called Sen4Smells that performs an automated sensitivity analysis for a given debt index based on the evolution of both the index values and the corresponding smells across (past) system versions. The Sen4Smells output is a ranking of smells that, due to their variations or instability, are major contributors to the debt index, and thus, can impact on architecture quality. Sen4Smells is designed as a pipeline that combines information from existing tools for smell detection, predefined d ebt i ndex f ormulas, and the Sobol method for sensitivity analysis. As a demonstration of the tool functionality, we briefly present implementations for the Arcan and Sonargraph tools with their respective debt indexes. ©2020 IEEE",Smells,Tool,"Diaz-Pace, J.A. and Tommasel, A. and Pigazzini, I. and Fontana, F.A.","2020 IEEE Congreso Bienal de Argentina, ARGENCON 2020 - 2020 IEEE Biennial Congress of Argentina, ARGENCON 2020","2,020.00",Conference Paper,10.1109/ARGENCON49523.2020.9505535,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85114053246&doi=10.1109%2fARGENCON49523.2020.9505535&partnerID=40&md5=b7663f90a70fe4d0c71a69b149b305a3,No,Architectural smells;  Debt index;  Sensitivity analysis;  System evolution;  tool support
S305,Read,Rejected,[EC1] - The primary study is out of the scope of this work;,"After the full reading, this study is also a related work;",A Systematic-Oriented Process for Tool Selection: The Case of Green and Technical Debt Tools in Architecture Reconstruction,"Well-established methods in software engineering research, such as Systematic Literature Reviews, Systematic Mappings and Case Studies are effective research methods to explore emerging areas, since they are systematic and replicable, and produce reusable result avoiding bias. Frequently, software engineers have to evaluate and select CASE (Computer Aided Software Engineering) tools that address trending issues with a non-systematic and replicable processes. This work addresses this problem by tailoring the ISO/IEC 14102:2008 to a systematic-oriented process for the evaluation of software engineering CASE tools in order to embrace the advantages of software engineering systematic methods in the exploration of new areas or emerging issues. This tailored ISO/IEC 14102:2008 standard prescribes a process for the preparation, design and conduction of the software engineering CASE tools evaluation and selection. This process is founded in the application of systematic methods and the generation of a pre-established assets to ensure the reusability of knowledge. In this paper, this tailored process has been applied to address two great emerging concerns in architectural reconstruction: technical debt and energy consumption. As result of this adoption, this paper details the reporting analysis and the set of reusable assets that have been generated during the evaluation process. Specifically, this contribution presents a set of tables, statistics and a decision-making tree of the selected tools for technical debt and energy consumption analysis in architecture reconstruction. © 2020, Springer Nature Switzerland AG.",Technical Debt,Tool,"Guamán, D. and Pérez, J. and Garbajosa, J. and Rodríguez, G.",Lecture Notes in Computer Science (including subseries Lecture Notes in Artificial Intelligence and Lecture Notes in Bioinformatics),2020,Conference Paper,10.1007/978-3-030-64148-1_15,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85097641266&doi=10.1007%2f978-3-030-64148-1_15&partnerID=40&md5=4cffd3a5c28bad9335c70f08126324d4,No,Architecture reconstruction;  Green software;  ISO/IEC14102:2008;  Systematic process;  Technical debt;  Tools
S271,Read,Accepted,[IC1] - The primary study presents or points to a software artifact that automates a task within at least one TD management activity.,,Towards microservice smells detection,"With the adoption of microservices architectural styles, practitioners started noticing increasing pitfalls in managing and maintaining such architectures, with the risk of introducing architectural debt. Previous studies identified different microservice smells (also named anti-patterns) that harm microservices architectures. However, according to our knowledge, there are no tools that can automatically detect microservice smells, so their identification is left to the experience of the developer. In this paper, we extend an existing tool developed for the detection of architectural smells to explore microservices architecture through the detection of three microservice smells: Cyclic Dependencies, Hard-Coded Endpoints, and Shared Persistence. We detected the smells on five open-source projects implemented with microservices and manually validated the precision of the detection results. This work aims to open new perspectives on facing and studying architectural debt in the field of microservices architectures. © 2020 ACM.",Smells,Tool,"Pigazzini, I. and Fontana, F.A. and Lenarduzzi, V. and Taibi, D.","Proceedings - 2020 IEEE/ACM International Conference on Technical Debt, TechDebt 2020","2,020.00",Conference Paper,10.1145/3387906.3388625,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85091307934&doi=10.1145%2f3387906.3388625&partnerID=40&md5=66d57fe748dec22c598f26369d10e8c8,No,anti-patterns;  microservice bad smells detection;  microservices
S292,Read,Accepted,[IC1] - The primary study presents or points to a software artifact that automates a task within at least one TD management activity.,,Towards an Approach to Identify Obsolete Features based on Importance and Technical Debt,"Many of today's software systems are maintained over years or even decades. To ensure that software remains useful, new features have to be added or old features have to be adapted to respond to new or changed requirements. As time goes on, some of the features become obsolete, i.e., are not needed anymore. Typically, these features are not removed because of various reasons, e.g., because removing them might be considered too costly, the costs of keeping unused features is considered low, or because of the ""sunk cost fallacy"", i.e., that a feature is considered worth to keep because of the previously invested resources (time, money or effort) to build it. The consequences of keeping unused source code can impact maintainability, technical debt, performance, and extensibility of the system. This can lead to lower development productivity and to a reduced innovation ability, consequently reducing competitiveness on the market. This paper aims to present an approach to identify features based on their value and on costs for keeping or removing them. © 2020 IEEE.",Technical Debt,Tool,"Janes, A. and Lenarduzzi, V.","Proceedings - 46th Euromicro Conference on Software Engineering and Advanced Applications, SEAA 2020","2,020.00",Conference Paper,10.1109/SEAA51224.2020.00070,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85096543973&doi=10.1109%2fSEAA51224.2020.00070&partnerID=40&md5=f9f98afa6c08cecf5f434e613df8738b,No,Feature importance;  Maintenance;  Technical Debt
S295,Read,Accepted,[IC1] - The primary study presents or points to a software artifact that automates a task within at least one TD management activity.,,"Comparing Maintainability Index, SIG Method, and SQALE for Technical Debt Identification","There are many definitions of software Technical Debt (TD) that were proposed over time. While many techniques to measure TD emerged in recent times, there is still not a clear understanding about how different techniques compare when applied to software projects. The goal of this paper is to shed some light on this aspect, by comparing three techniques about TD identification that were proposed over time: (i) the Maintainability Index (MI), (ii) SIG TD models, and (iii) SQALE analysis. Considering 20 open source Python libraries, we compare the TD measurements time series in terms of trends and evolution according to different sets of releases (major, minor, and micro), to see if the perception of practitioners about TD evolution could be impacted. While all methods report generally growing trends of TD over time, there are different patterns. SQALE reports more periods of steady states compared to MI and SIG TD. MI is the method that reports more repayments of TD compared to the other methods. SIG TD and MI are the models that show more similarity in the way TD evolves, while SQALE and MI are less similar. The implications are that each method gives slightly a different perception about TD evolution. © 2020 Peter Strečanský et al.",Technical Debt,Tool,"Strečanský, P. and Chren, S. and Rossi, B.",Scientific Programming,"2,020.00",Article,10.1155/2020/2976564,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85089306504&doi=10.1155%2f2020%2f2976564&partnerID=40&md5=3edcf276fefc59def5d9c64479ece8f5,No,
S300,Read,Accepted,[IC1] - The primary study presents or points to a software artifact that automates a task within at least one TD management activity.,,Self-Admitted Technical Debt classification using LSTM neural network,"Context: In software development, new functionalities and bug fixes are required to ensure a better user experience. Sometimes developers need to implement quick changes to meet deadlines rather than a better solution that would take longer. These easy choices, known as Technical Debts, can cause long-term negative impacts because they can bring extra effort to the team in the future. One way to detect technical debts is through source code comments. Developers often insert comments in which they admit that there is a need to improve that part of the code later. This is known as Self-Admitted Technical Debt (SATD). Objective: Evaluate a Long short-term memory (LSTM) neural network model to identify design and requirement SATDs from comments in source code. Method: We performed a controlled experiment to evaluate the quality of the model compared with two language models from literature in a labeled dataset. Results: Our model results outperformed the other models in precision, improving average precision in approximately 8% compared to auto-sklearn and 19% compared to maximum entropy approach, however, the LSTM model achieved worse results in recall and f-measure. Conclusion: We found that the LSTM model can classify with better precision but needs a larger training, so it can improve on the detection of negative cases. © Springer Nature Switzerland AG 2020.",Technical Debt,Tool,"Santos, R.M. and Junior, M.C.R. and de Mendonça Neto, M.G.",Advances in Intelligent Systems and Computing,"2,020.00",Conference Paper,10.1007/978-3-030-43020-7_93,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85085726790&doi=10.1007%2f978-3-030-43020-7_93&partnerID=40&md5=0275fc6a4cad37548d71c148f023c80e,No,Long short-term memory;  Mining software repositories;  Neural networks;  Source code comments;  Technical debt
S373,Read,Rejected,[IC1] - The primary study presents or points to a software artifact that automates a task within at least one TD management activity.,"After reading, the study does not automate any task of TDM",Data balancing improves self-admitted technical debt detection,"A high imbalance exists between technical debt and non-technical debt source code comments. Such imbalance affects Self-Admitted Technical Debt (SATD) detection performance, and existing literature lacks empirical evidence on the choice of balancing technique. In this work, we evaluate the impact of multiple balancing techniques, including Data level, Classifier level, and Hybrid, for SATD detection in Within-Project and Cross-Project setup. Our results show that the Data level balancing technique SMOTE or Classifier level Ensemble approaches Random Forest or XGBoost are reasonable choices depending on whether the goal is to maximize Precision, Recall, F1, or AUC-ROC. We compared our best-performing model with the previous SATD detection benchmark (cost-sensitive Convolution Neural Network). Interestingly the top-performing XGBoost with SMOTE sampling improved the Within-project F1 score by 10% but fell short in Cross-Project set up by 9%. This supports the higher generalization capability of deep learning in Cross-Project SATD detection, yet while working within individual projects, classical machine learning algorithms can deliver better performance. We also evaluate and quantify the impact of duplicate source code comments in SATD detection performance. Finally, we employ SHAP and discuss the interpreted SATD features. We have included the replication package1 and shared a web-based SATD prediction tool2 with the balancing techniques in this study. © 2021 IEEE.",Technical Debt,Tool,"Sridharan, M. and Mantyla, M. and Rantala, L. and Claes, M.","Proceedings - 2021 IEEE/ACM 18th International Conference on Mining Software Repositories, MSR 2021",2021,Conference Paper,10.1109/MSR52588.2021.00048,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85113608396&doi=10.1109%2fMSR52588.2021.00048&partnerID=40&md5=8372a320829643fa3dbaaf4903e3d57e,No,Classification;  Cost-sensitive technique;  Data imbalance;  Data sampling techniques;  Ensemble techniques;  Self-Admitted Technical Debt
S378,Read,Rejected,[IC1] - The primary study presents or points to a software artifact that automates a task within at least one TD management activity.,"After reading, the study does not provide any software artifact",Classification of Technical Debts in Software Development Using Text Analytics,"Technical debt refers to the technical trade-offs made by the software teams at the time of development of the software to fasten the delivery process. These trade-offs lead to a higher system maintenance cost, and it is difficult to often enhance the application. In some cases, enhancements can result in the entire modules being rewritten. So, in order to reduce the debt from the system, it is required to identify the debt and the project cycle where most of the debts occur. To automatically address this problem, this work uses the machine learning and text analytics model. Random forest and support vector machine (SVM) algorithms extract features from incident tracker documents and effectively classify the technical debts. The proposed technical debt classification model is made sustainable to handle the growing volumes of project documents by executing a distributed framework. The performance of both the models is examined, and it is found that SVM outperforms the other. © 2021, Springer Nature Switzerland AG.",Technical Debt,Tool,"Rajalakshmi, V. and Sendhilkumar, S. and Mahalakshmi, G.S.",EAI/Springer Innovations in Communication and Computing,2021,Conference Paper,10.1007/978-3-030-49795-8_31,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85097843589&doi=10.1007%2f978-3-030-49795-8_31&partnerID=40&md5=601568d9f1b5bda19f7cebe1bee3c2f8,No,Software quality;  Sustainable classification;  Technical debt;  Text analytics
S309,Read,Accepted,[EC2] - The study shows a theoretical artifact or do not provide a link to the artifact's repository;,,Skuld: A self-learning tool for impact-driven technical debt management,"As the development progresses, software projects tend to accumulate Technical Debt and become harder to maintain. Multiple tools exist with the mission to help practitioners to better manage Technical Debt. Despite this progress, there is a lack of tools providing actionable and self-learned suggestions to practitioners aimed at mitigating the impact of Technical Debt in real projects. We aim to create a data-driven, lightweight, and self-learning tool positioning highly impactful refactoring proposals on a Jira backlog. Bearing this goal in mind, the first two authors have founded a startup, called Skuld.ai, with the vision of becoming the go-to software renovation company. In this tool paper, we present the software architecture and demonstrate the main functionalities of our tool. It has been showcased to practitioners, receiving positive feedback. Currently, its release to the market is underway thanks to an industry-research institute collaboration with Fraunhofer IESE to incorporate self-learning technical debt capabilities. © 2020 ACM.",Technical Debt,Tool,"Pujols, J.B. and Bas, P. and Martínez-Fernandez, S. and Martini, A. and Trendowicz, A.","Proceedings - 2020 IEEE/ACM International Conference on Technical Debt, TechDebt 2020","2,020.00",Conference Paper,10.1145/3387906.3388626,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85093105894&doi=10.1145%2f3387906.3388626&partnerID=40&md5=83627c4ada6e9c3692c820ae1da75bbf,No,data-driven development;  project management;  technical debt;  tool
S315,Read,Accepted,[IC1] - The primary study presents or points to a software artifact that automates a task within at least one TD management activity.,,"Prevalence, Contents and Automatic Detection of KL-SATD","When developers use different keywords such as TODO and FIXME in source code comments to describe self-admitted technical debt (SATD), we refer it as Keyword-Labeled SATD (KL-SATD). We study KL-SATD from 33 software repositories with 13,588 KL-SATD comments. We find that the median percentage of KL-SATD comments among all comments is only 1,52%. We find that KL-SATD comment contents include words expressing code changes and uncertainty, such as remove, fix, maybe and probably. This makes them different compared to other comments. KL-SATD comment contents are similar to manually labeled SATD comments of prior work. Our machine learning classifier using logistic Lasso regression has good performance in detecting KL-SATD comments (AUC-ROC 0.88). Finally, we demonstrate that using machine learning we can identify comments that are currently missing but which should have a SATD keyword in them. Automating SATD identification of comments that lack SATD keywords can save time and effort by replacing manual identification of comments. Using KL-SATD offers a potential to bootstrap a complete SATD detector. © 2020 IEEE.",Technical Debt,Tool,"Rantala, L. and Mantyla, M. and Lo, D.","Proceedings - 46th Euromicro Conference on Software Engineering and Advanced Applications, SEAA 2020","2,020.00",Conference Paper,10.1109/SEAA51224.2020.00069,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85096567372&doi=10.1109%2fSEAA51224.2020.00069&partnerID=40&md5=fa864c8485e6cb62bd4f1b41b258269e,No,data mining;  Natural language processing;  self-admitted technical debt
S338,Read,Accepted,[IC1] - The primary study presents or points to a software artifact that automates a task within at least one TD management activity.,,Towards Better Technical Debt Detection with NLP and Machine Learning Methods,"Technical debt (TD) is an economical term used to depict non-optimal choices made in the software development process. It occurs usually when developers take shortcuts instead of following agreed upon development practices, and unchecked growth of technical debt can start to incur negative effects for software development processes.Technical debt detection and management is mainly done manually, and this is both slow and costly way of detecting technical debt. Automatic detection would solve this issue, but even state-of-the-art tools of today do not accurately detect the appearance of technical debt. Therefore, increasing the accuracy of automatic classification is of high importance, so that we could eliminate significant portion from the costs relating to technical debt detection.This research aims to solve the problem in detection accuracy by bringing in together static code analysis and natural language processing. This combination of techniques will allow more accurate detection of technical debt, when compared to them being used separately from each other. Research also aims to discover themes and topics from written developer messages that can be linked to technical debt. These can help us to understand technical debt from developers' viewpoint. Finally, we will build an open-source tool/plugin that can be used to accurately detect technical debt using both static analysis and natural language processing methods. © 2020 ACM.",Technical Debt,Tool,"Rantala, L.","Proceedings - 2020 ACM/IEEE 42nd International Conference on Software Engineering: Companion, ICSE-Companion 2020","2,020.00",Conference Paper,10.1145/3377812.3381404,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85098553455&doi=10.1145%2f3377812.3381404&partnerID=40&md5=49bd90bdd795d70e30576d4806605075,No,machine learning;  natural language processing;  technical debt
S278,Read,Accepted,[IC1] - The primary study presents or points to a software artifact that automates a task within at least one TD management activity.,,AdaBoost-based Refused Bequest Code Smell Detection with Synthetic Instances,"Software requirements are constantly changing. Consequently, the development process is frequently under time pressure, which results in technical debt. To illustrate the symptoms of technical debt, 22 code smells have been introduced to indicate the poor design in code fragment, among which refused bequest is one of the most harmful smells and with high diffuseness. However, refused bequest is rarely taken into account because there is a lack of dataset. Moreover, it is difficult to design the detection rules for refused bequest compared with other popular smells.In this paper, we propose a machine-learning-based refused bequest smell detection framework SEADART, which features the utilization of a set of synthetic smelly instances. Specifically, SEADART comprises three components: (1) a smell generation approach, and (2) a model training strategy, and (3) an AdaBoost-based detection model. We evaluate the performance of the proposed framework. The evaluation results suggest that the generated smelly instances are reliable, and the trained AdaBoost model significantly outperforms the state-of-the-art over a real-world dataset. © 2020 IEEE.",Smells,Tool,"Chen, H. and Ren, Z. and Qiao, L. and Zhou, Z. and Gao, G. and Ma, Y. and Jiang, H.","Proceedings - 2020 7th International Conference on Dependable Systems and Their Applications, DSA 2020","2,020.00",Conference Paper,10.1109/DSA51864.2020.00019,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85100534946&doi=10.1109%2fDSA51864.2020.00019&partnerID=40&md5=1ac523109d4b9a851a92583ee12dfda7,No,AdaBoost;  Code Smell;  Refused Bequest;  Technical Debt
S267,Read,Accepted,[IC1] - The primary study presents or points to a software artifact that automates a task within at least one TD management activity.,,Learning to detect community smells in open source software projects,"Community smells are symptoms of organizational and social issues within the software development community that often lead to additional project costs. Recent studies identified a variety of community smells and defined them as sub-optimal patterns connected to organizational-social structures in the software development community. To early detect and discover existence of potential community smells in a software project, we introduce, in this paper, a novel machine learning-based detection approach, named CSDETECTOR, that learns from various existing bad community development practices to provide automated support in detecting such community smells. In particular, our approach learns from a set of organizational-social symptoms that characterize the existence of potential instances of community smells in a software project. We built a detection model using Decision Tree by adopting the C4.5 classifier to identify eight commonly occurring community smells in software projects. To evaluate the performance of our approach, we conduct an empirical study on a benchmark of 74 open source projects from Github. Our statistical results show a high performance of CSDETECTOR, achieving an average accuracy of 96% and AUC of 0.94. Moreover, our results indicate that the CSDETECTOR outperforms two recent state-of-the-art techniques in terms of detection accuracy. Finally, we investigate the most influential community-related metrics to identify each community smell type. We found that the number of commits and developers per time zone, the number of developers per community, and the social network betweenness and closeness centrality are the most influential community characteristics. © 2020",Smells,Tool,"Almarimi, N. and Ouni, A. and Mkaouer, M.W.",Knowledge-Based Systems,"2,020.00",Article,10.1016/j.knosys.2020.106201,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85087589480&doi=10.1016%2fj.knosys.2020.106201&partnerID=40&md5=b7b6d2f689174f334f3e916fb88d52cc,No,Community smells detection;  Machine learning;  Social debt;  Socio-technical metrics
S264,Read,Accepted,[IC1] - The primary study presents or points to a software artifact that automates a task within at least one TD management activity.,,Overview of an automated framework to measure and track the quality level of a product,"Product owners need to comprehend the product quality level, in a synthetic and intuitive way to facilitate the decision of accepting or rejecting the iteration. This article presents the basis of an automated framework to measure and monitor the quality level of a software product, within each iteration. This framework is based on the Product Quality Evaluation Method (PQEM), which was designed by the authors and it allows the evaluation of the quality characteristics of a software product, using the Goal-Question-Metric approach, the ISO/IEC 25010, ISO/IEC 25023, the extension made of test coverage concept to quality coverage applied to each quality characteristic, and technical debt and waste. Within the automated framework, the measurement is semi-automatic which is shown in the illustrative example. The development of the framework will begin shortly, and it is expected to carry on new measurements on new iterations of an application. © 2020 IEEE",TD Symptoms/Consequences,Tool,"Falco, M. and Scott, E. and Robiolo, G.","2020 IEEE Congreso Bienal de Argentina, ARGENCON 2020 - 2020 IEEE Biennial Congress of Argentina, ARGENCON 2020","2,020.00",Conference Paper,10.1109/ARGENCON49523.2020.9505405,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85114027846&doi=10.1109%2fARGENCON49523.2020.9505405&partnerID=40&md5=1e57babb6d5cefa0e1f92750bb06a7c1,No,Automated framework;  PQEM;  Quality attributes;  Quality characteristics;  Quality management;  Quality measurement
S265,Read,Accepted,[IC1] - The primary study presents or points to a software artifact that automates a task within at least one TD management activity.,,Software Architecture Reconstruction via a Genetic Algorithm: Applying the Move Class Refactoring,"Modularity is one of the four key principles of software design and architecture. According to this principle, software should be organized into modules that are tightly linked internally (high cohesion), whereas at the same time as independent from other modules as possible (low coupling). However, in practice, this principle is violated due to poor architecting design decisions, lack of time, or coding shortcuts, leading to a phenomenon termed as architectural technical debt (ATD). To alleviate this problem (lack of architectural modularity), the most common solution is the application of a software refactoring, namely Move Class - i.e., moving classes (the core artifact in object-oriented systems) from one module to another. To identify Move Class refactoring opportunities, we employ a search-based optimization process, relying on optimization metrics, through which optimal moves are derived. Given the extensive search space required for applying a brute-force search strategy, in this paper, we propose the use of a genetic algorithm that re-arranges existing software classes into existing or new modules (software packages in Java, or folders in C++). To validate the usefulness of the proposed refactorings, we performed an industrial case study on three projects (from the Aviation, Healthcare, and Manufacturing application domains). The results of the study indicate that the proposed architecture reconstruction is able to improve modularity, improving both coupling and cohesion. The obtained results can be useful to practitioners through an open source tool; whereas at the same point, they open interesting future work directions. © 2020 ACM.",TD Symptoms/Consequences,Tool,"Maikantis, T. and Tsintzira, A.-A. and Ampatzoglou, A. and Arvanitou, E.-M. and Chatzigeorgiou, A. and Stamelos, I. and Bibi, S. and Deligiannis, I.",ACM International Conference Proceeding Series,"2,020.00",Conference Paper,10.1145/3437120.3437292,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85102359191&doi=10.1145%2f3437120.3437292&partnerID=40&md5=836766510b99549b842921843a79bc57,No,
S121,Read,Rejected,[EC1] - The primary study is out of the scope of this work;,"After full-reading, was not possible to fit the artificat in a TD activity",CodeCritics applied to database schema: Challenges and first results,"Relational databases (DB) play a critical role in many information systems. For different reasons, their schemas gather not only tables and columns but also views, triggers or stored functions (i.e., fragments of code describing treatments). As for any other code-related artefact, software quality in a DB schema helps avoiding future bugs. However, few tools exist to analyse DB quality and prevent the introduction of technical debt. Moreover, these tools suffer from limitations like the difficulty to deal with some entities (e.g., functions) or dependencies between entities. This paper presents research issues related to assessing the software quality of a DB schema by adapting existing source code analysis research to database schemas. We present preliminary results that have been validated through the implementation of DBCritics, a prototype tool to perform static analysis on the SQL source code of a database schema. DBCritics addresses the limitations of existing DB quality tools based on an internal representation considering all entities of the database and their relationships. © 2017 IEEE.",TD Symptoms/Consequences,Tool,"Delplanque, J. and Etien, A. and Auverlot, O. and Mens, T. and Anquetil, N. and Ducasse, S.","SANER 2017 - 24th IEEE International Conference on Software Analysis, Evolution, and Reengineering",2017,Conference Paper,10.1109/SANER.2017.7884648,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85018421262&doi=10.1109%2fSANER.2017.7884648&partnerID=40&md5=a0196be2e4882647ef000fce90cd5a93,No,database critics;  database software quality;  design smells;  quality assessment
S179,Read,Rejected,[EC2] - The study shows a theoretical artifact or do not provide a link to the artifact's repository;,"Afeter checking the study, the proposed tool is not available. ",Specification and automatic checking of architecture constraints on object oriented programs,"Context: Architecture constraints are specifications of conditions to which an architecture model must adhere in order to satisfy an architecture decision imposed by a given design principle. These constraints can be specified with predicate languages like OCL at design time and checked on design artifacts. Objective: Many works in the literature studied the importance of checking these constraints to guarantee quality on design models, and to prevent technical debt and maintenance difficulties. In this paper, we propose a process whose ultimate goal is to enable the checking of these constraints in the implementation stage. Method: The proposed process takes as input a textual specification of an architecture constraint specified at design stage. It translates this specification into meta-programs and then it uses them with aspect-oriented programming to check constraints at the implementation stage and at run-time on object-oriented programs. Results: We experimented an implementation of this process on a set of 12 architecture constraints. The results of this experimentation showed that our process is able to statically and dynamically detect architecture constraint violations on toy object-oriented applications, but also on real-world ones. Conclusion: The automatic checking of architecture constraints is important at source code level and at runtime. It avoids the disappearance of architecture decision knowledge in implementation artifacts, and facilitates later their maintenance. © 2018",TD Symptoms/Consequences,Tool,"Kallel, S. and Tibermacine, C. and Kallel, S. and Kacem, A.H. and Dony, C.",Information and Software Technology,2018,Article,10.1016/j.infsof.2018.05.002,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85047100794&doi=10.1016%2fj.infsof.2018.05.002&partnerID=40&md5=6be88672a2d1a589d23b6c9480810ee1,No,AOP;  Architecture constraint;  Aspectj;  Java reflect;  Meta-program;  Object constraint language
S324,Read,Rejected,[EC2] - The study shows a theoretical artifact or do not provide a link to the artifact's repository;,"After full-reading, the paper does not point to an artifact",Detecting and Explaining Self-Admitted Technical Debts with Attention-based Neural Networks,"Self-Admitted Technical Debt (SATD) is a sub-type of technical debt. It is introduced to represent such technical debts that are intentionally introduced by developers in the process of software development. While being able to gain short-term benefits, the introduction of SATDs often requires to be paid back later with a higher cost, e.g., introducing bugs to the software or increasing the complexity of the software. To cope with these issues, our community has proposed various machine learning-based approaches to detect SATDs. These approaches, however, are either not generic that usually require manual feature engineering efforts or do not provide promising means to explain the predicted outcomes. To that end, we propose to the community a novel approach, namely HATD (Hybrid Attention-based method for self-admitted Technical Debt detection), to detect and explain SATDs using attention-based neural networks. Through extensive experiments on 445, 365 comments in 20 projects, we show that HATD is effective in detecting SATDs on both in-the-lab and in-the-wild datasets under both within-project and cross-project settings. HATD also outperforms the state-of-the-art approaches in detecting and explaining SATDs. © 2020 ACM.",Technical Debt,Tool,"Wang, X. and Liu, J. and Li, L. and Chen, X. and Liu, X. and Wu, H.","Proceedings - 2020 35th IEEE/ACM International Conference on Automated Software Engineering, ASE 2020",2020,Conference Paper,10.1145/3324884.3416583,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85099183000&doi=10.1145%2f3324884.3416583&partnerID=40&md5=2489e9e83a6d8c5749c20581aec0ce51,No,Attention-based Neural Networks;  SATD;  Self-Admitted Technical Debt;  Word Embedding
S268,Read,Accepted,[IC1] - The primary study presents or points to a software artifact that automates a task within at least one TD management activity.,,On the Influence of UML Class Diagrams Refactoring on Code Debt: A Family of Replicated Empirical Studies,"Context: System modeling usually precedes coding activities during software development. Addressing model smells in the upfront can avoid their propagation to the source code. Technical debt (TD) affects several software development phases, including design, but little is still known about it at the modeling level. Goal: Investigate whether applying refactoring procedures in UML class diagrams improves the quality of the automatically generated code in terms of TD (code debt) reduction. Method: We perform three replications of an empirical study following the same protocol used in the original study, but with variations on the: (1) round- trip engineering tool, (2) code issue identification tool, and (3) analyzed class diagram. Each study considered two sets of refactoring tasks. The first applied successive model refactoring sessions in a class diagram and analyzed their resulting automatically generated code. The second applied successive code refactoring sessions and analyzed their resulting automatically generated model. Results: There is a weak relationship between the analyzed model smells and code issues. Round-trip engineering tools influence the presence of code issues. Lastly, code issues identification tools mostly consider code formatting problems, in detriment of design issues smells. Conclusion: Results confirm the findings of the original study and motivate further investigation on the correspondence between model smells and code issues to prevent code debt at the model level. © 2020 IEEE.",TD Symptoms/Consequences,Tool,"Freire, S. and Passos, A. and Mendonca, M. and Sant'Anna, C. and Spinola, R.O.","Proceedings - 46th Euromicro Conference on Software Engineering and Advanced Applications, SEAA 2020","2,020.00",Conference Paper,10.1109/SEAA51224.2020.00064,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85096539467&doi=10.1109%2fSEAA51224.2020.00064&partnerID=40&md5=f85c05a5f929fe895a05dcf83d1d0c0d,No,code issues;  family of studies;  model smell;  technical debt
S273,Read,Accepted,[IC1] - The primary study presents or points to a software artifact that automates a task within at least one TD management activity.,,Automating detection of occurrences of postgresql database design problems,"SQL is a very resilient and widely used software language. In case of building a SQL database, one has to design schemas of the database so that the database management system (DBMS) can enforce these. The result of designing a database schema is a technical artifact, which may have technical debt. The debt makes it more difficult to understand, maintain, extend, and reuse the artifact. Smells are the signs of technical debt. Many database design smells manifest the same problems as code smells. It could also be that a database schema makes incorrect statements about the domain of the database or lacks necessary elements, i.e., is incomplete. Thus, database schemas can have numerous problems and finding these is a prerequisite of improving the schemas. The paper introduces a catalog of open-source SQL queries that have been designed for finding the occurrences of design problems in PostgreSQL databases (https://github.com/erki77/database-design-queries). Most of the queries help us to detect the occurrences of database design smells. The queries are for a specific although popular DBMS. However, most of the problems that occurrences these help us to find can appear in any SQL database, regardless of the used DBMS. © Springer Nature Switzerland AG 2020.",TD Symptoms/Consequences,Tool,"Eessaar, E.",Communications in Computer and Information Science,"2,020.00",Conference Paper,10.1007/978-3-030-57672-1_14,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85089717473&doi=10.1007%2f978-3-030-57672-1_14&partnerID=40&md5=a953510f6449d88b3fe2a4a3246aec1e,No,Automated quality assessment;  Database design;  Design smell;  SQL;  Technical debt
S294,Read,Accepted,[IC1] - The primary study presents or points to a software artifact that automates a task within at least one TD management activity.,,Piranha: Reducing feature flag debt at Uber,"Feature flags are commonly used in mobile app development and can introduce technical debt related to deleting their usage from the codebase. This can adversely affect the overall reliability of the apps and increase their maintenance complexity. Reducing this debt without imposing additional overheads on the developers necessitates the design of novel tools and automated workflows. In this paper, we describe the design and implementation of Piranha, an automated code refactoring tool which is used to automatically generate differential revisions (a.k.a diffs) to delete code corresponding to stale feature flags. Piranha takes as input the name of the flag, expected treatment behavior, and the name of the flag's author. It analyzes the ASTs of the program to generate appropriate refactorings which are packaged into a diff. The diff is assigned to the author of the flag for further processing, who can land it after performing any additional refactorings. We have implemented Piranha to delete code in Objective-C, Java, and Swift programs, and deployed it to handle stale flags in multiple Uber apps. We present our experiences with the deployment of Piranha from Dec 2017 to May 2019, including the following highlights: (a) generated code cleanup diffs for 1381 flags (17% of total flags), (b) 65% of the diffs landed without any changes, (c) over 85% of the generated diffs compile and pass tests successfully, (d) around 80% of the diffs affect more than one file, (e) developers process more than 88% of the generated diffs, (f) 75% of the generated diffs are processed within a week, and (g) Piranha diffs have been interacted with by ∼200 developers across Uber. Piranha is available as open source at https://github.com/uber/ piranha. © 2020 IEEE Computer Society. All rights reserved.",TD Symptoms/Consequences,Tool,"Ramanathan, M.K. and Clapp, L. and Barik, R. and Sridharan, M.",Proceedings - International Conference on Software Engineering,"2,020.00",Conference Paper,10.1145/3377813.3381350,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85092548989&doi=10.1145%2f3377813.3381350&partnerID=40&md5=b484d75492bbe3ff8113c96dee58922c,No,
S370,Read,Rejected,[EC1] - The primary study is out of the scope of this work;,"After reviewing the papers, it does not seems to fit in the SMS",Carrot and Stick approaches revisited when managing Technical Debt in an educational context,"Technical Debt management is an important aspect in the training of Software Engineering students. In this paper we study the effect of two assessment strategies in an educational context: One based on penalisation, the other based on rewards. Both are applied to assignments where the students develop a project focusing on keeping a low technical debt level, and obtaining a high quality code. We describe the design, tools and context of the strategies applied. SonarQube, a tool commonly used in production environments, is used for measuring the metrics. The penalisation strategy is based on a SonarQube quality gate. The reward strategy is based on a contest, where an automatic judge tool is devised to provide an online leaderboard with a classification based on the SonarQube metrics. An empirical study is conducted to determine which of the strategies works better to help the students/trainees keep the Technical Debt low. Statistically significant results are obtained in 5 of the 8 analysed metrics, showing that the reward strategy works much better. The effect size of the executed statistical tests is analysed, resulting in medium and large effect size in the majority of the analysed metrics. © 2021 IEEE.",Technical Debt,Tool,"Crespo, Y. and Gonzalez-Escribano, A. and Piattini, M.","Proceedings - 2021 IEEE/ACM International Conference on Technical Debt, TechDebt 2021",2021,Conference Paper,10.1109/TechDebt52882.2021.00020,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85114775451&doi=10.1109%2fTechDebt52882.2021.00020&partnerID=40&md5=d1cc581a86df228744f28ce2e488eb67,No,Empirical Study;  Software Development;  Teaching and Training Technical Debt Topics;  Technical Debt
S287,Read,Accepted,[IC1] - The primary study presents or points to a software artifact that automates a task within at least one TD management activity.,,Predicting technical debt from commit contents: reproduction and extension with automated feature selection,"Self-admitted technical debt refers to sub-optimal development solutions that are expressed in written code comments or commits. We reproduce and improve on a prior work by Yan et al. (2018) on detecting commits that introduce self-admitted technical debt. We use multiple natural language processing methods: Bag-of-Words, topic modeling, and word embedding vectors. We study 5 open-source projects. Our NLP approach uses logistic Lasso regression from Glmnet to automatically select best predictor words. A manually labeled dataset from prior work that identified self-admitted technical debt from code level commits serves as ground truth. Our approach achieves + 0.15 better area under the ROC curve performance than a prior work, when comparing only commit message features, and + 0.03 better result overall when replacing manually selected features with automatically selected words. In both cases, the improvement was statistically significant (p < 0.0001). Our work has four main contributions, which are comparing different NLP techniques for SATD detection, improved results over previous work, showing how to generate generalizable predictor words when using multiple repositories, and producing a list of words correlating with SATD. As a concrete result, we release a list of the predictor words that correlate positively with SATD, as well as our used datasets and scripts to enable replication studies and to aid in the creation of future classifiers. © 2020, The Author(s).",Technical Debt,Tool,"Rantala, L. and Mäntylä, M.",Software Quality Journal,"2,020.00",Article,10.1007/s11219-020-09520-3,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85087511768&doi=10.1007%2fs11219-020-09520-3&partnerID=40&md5=3825cb06f748a2af90903823c08d80f6,No,Data mining;  Latent Dirichlet allocation;  Logistic regression;  Natural language processing;  Topic modeling;  Word embeddings
S289,Read,Accepted,[IC1] - The primary study presents or points to a software artifact that automates a task within at least one TD management activity.,,Does migrating a monolithic system to microservices decrease the technical debt?,"Background: The migration from a monolithic system to microservices requires a deep refactoring of the system. Therefore, such a migration usually has a big economic impact and companies tend to postpone several activities during this process, mainly to speed up the migration itself, but also because of the demand for releasing new features. Objective: We monitored the technical debt of an SME while it migrated from a legacy monolithic system to an ecosystem of microservices. Our goal was to analyze changes in the code technical debt before and after the migration to microservices. Method: We conducted a case study analyzing more than four years of the history of a twelve-year-old project (280K Lines of Code) where two teams extracted five business processes from the monolithic system as microservices. For the study, we first analyzed the technical debt with SonarQube and then performed a qualitative study with company members to understand the perceived quality of the system and the motivation for possibly postponed activities. Results: The migration to microservices helped to reduce the technical debt in the long run. Despite an initial spike in the technical debt due to the development of the new microservice, after a relatively short period of time the technical debt tended to grow slower than in the monolithic system. © 2020 Elsevier Inc.",Technical Debt,Tool,"Lenarduzzi, V. and Lomio, F. and Saarimäki, N. and Taibi, D.",Journal of Systems and Software,"2,020.00",Review,10.1016/j.jss.2020.110710,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85087383887&doi=10.1016%2fj.jss.2020.110710&partnerID=40&md5=eecb57d0a427b954cb57b950789b0963,No,Architectural debt;  Code quality;  Microservices;  Refactoring;  Technical debt
S412,Read,Rejected,[EC2] - The study shows a theoretical artifact or do not provide a link to the artifact's repository;,"After reading the paper, the tool was not available",A Decision Support System for Managing Technical Debt: Towards a Systemic Perspective,"Maintaining a software system in operation requires resources to keep it reasonably bug-free, appropriate for the business needs, and still changeable. However, it is challenging to evaluate resource allocation strategies while considering both current and future needs. This paper presents a decision support system, using technical debt concepts, built based on the system dynamics approach that aims to assist decision-makers in evaluating different maintenance investment strategies. The tool can help evaluate future impacts by simulating possible scenarios, generating knowledge and insights for decision-makers, and helping to communicate them among different stakeholders. © 2021 ACM.",Technical Debt,Tool,"Franco, E. and Hirama, K. and Armenia, S. and Skripnikova, T. and Betzin, S.",ACM International Conference Proceeding Series,2021,Conference Paper,10.1145/3474624.3477062,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85117112665&doi=10.1145%2f3474624.3477062&partnerID=40&md5=9833e5b8412400f8ca6dcee9adc014b3,No,decision support system;  resource allocation;  software maintenance;  system dynamics;  Technical debt management
S297,Read,Accepted,[EC1] - The primary study is out of the scope of this work;,,"Software archinaut: A tool to understand architecture, identify technical debt hotspots and manage evolution","In this paper we present Software Archinaut-a tool used to help identify technical debt hotspots in an architecture, and manage the evolution of the architecture once these hotspots are discovered. Archinaut is a platform that integrates analyses from different tools. It supports three main usage scenarios: 1) understanding the architecture, 2) identifying technical debt hotspots, and 3) monitoring and controlling the evolution of the architecture. We illustrate these scenarios by using Apache Kafka as an example. © 2020 ACM.",Technical Debt,Tool,"Cervantes, H. and Kazman, R.","Proceedings - 2020 IEEE/ACM International Conference on Technical Debt, TechDebt 2020","2,020.00",Conference Paper,10.1145/3387906.3388633,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85093086937&doi=10.1145%2f3387906.3388633&partnerID=40&md5=9e1238b901cc571285ecfefbe8099385,No,architecture erosion;  hotspots;  software architecture;  technical debt
S301,Read,Accepted,[IC1] - The primary study presents or points to a software artifact that automates a task within at least one TD management activity.,,Long term-short memory neural networks and word2vec for self-admitted technical debt detection,"Context: In software development, new functionalities and bug fixes are required to ensure a better user experience and to preserve software value for a longer period. Sometimes developers need to implement quick changes to meet deadlines rather than a better solution that would take longer. These easy choices, known as Technical Debt, can cause long-term negative impacts because they can bring extra effort to the team in the future. Technical debts must be managed and detected so that the team can evaluate the best way to deal with them and avoid more serious problems. One way to detect technical debts is through source code comments. Developers often insert comments in which they admit that there is a need to improve that part of the code later. This is known as Self-Admitted Technical Debt (SATD). Objective: Evaluate a Long short-term memory (LSTM) neural network model combined with Word2vec for word embedding to identify design and requirement SATDs from comments in source code. Method: We performed a controlled experiment to evaluate the quality of the model compared with two language models from literature and LSTM without word embedding in a labelled dataset. Results: The results showed that the LSTM model with Word2vec have improved in recall and f-measure. The LSTM model without word embedding achieves greater recall, but perform worse in precision and f-measure. Conclusion: Overall, we found that the LSTM model and word2vec can outperform other models. Copyright © 2020 by SCITEPRESS – Science and Technology Publications, Lda. All rights reserved",Technical Debt,Tool,"Santos, R.M. and Santos, I.M. and Rodrigues, M.C., Júnior and de Mendonça Neto, M.G.",ICEIS 2020 - Proceedings of the 22nd International Conference on Enterprise Information Systems,"2,020.00",Conference Paper,,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85091400625&partnerID=40&md5=f5f3ef9ca14d043c9945715ac9022a3f,No,Deep Learning;  Long Short-term Memory;  Mining Software Repositories;  Neural Networks;  Self-admitted Technical Debt;  Word Embedding
S307,Read,Accepted,[IC1] - The primary study presents or points to a software artifact that automates a task within at least one TD management activity.,,Are SonarQube Rules Inducing Bugs?,"The popularity of tools for analyzing Technical Debt, and particularly the popularity of SonarQube, is increasing rapidly. SonarQube proposes a set of coding rules, which represent something wrong in the code that will soon be reflected in a fault or will increase maintenance effort. However, our local companies were not confident in the usefulness of the rules proposed by SonarQube and contracted us to investigate the fault-proneness of these rules. In this work we aim at understanding which SonarQube rules are actually fault-prone and to understand which machine learning models can be adopted to accurately identify fault-prone rules. We designed and conducted an empirical study on 21 well-known mature open-source projects. We applied the SZZ algorithm to label the fault-inducing commits. We analyzed the fault-proneness by comparing the classification power of seven machine learning models. Among the 202 rules defined for Java by SonarQube, only 25 can be considered to have relatively low fault-proneness. Moreover, violations considered as 'bugs' by SonarQube were generally not fault-prone and, consequently, the fault-prediction power of the model proposed by SonarQube is extremely low. The rules applied by SonarQube for calculating technical debt should be thoroughly investigated and their harmfulness needs to be further confirmed. Therefore, companies should carefully consider which rules they really need to apply, especially if their goal is to reduce fault-proneness. © 2020 IEEE.",Technical Debt,Tool,"Lenarduzzi, V. and Lomio, F. and Huttunen, H. and Taibi, D.","SANER 2020 - Proceedings of the 2020 IEEE 27th International Conference on Software Analysis, Evolution, and Reengineering","2,020.00",Conference Paper,10.1109/SANER48275.2020.9054821,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85083565109&doi=10.1109%2fSANER48275.2020.9054821&partnerID=40&md5=b02e9d84c6eb93fb5ccd9db67d59ae6b,No,architectural smells;  code smells;  coding style;  machine learning;  SonarQube;  static analysis;  Technical Debt
S310,Read,Accepted,[IC1] - The primary study presents or points to a software artifact that automates a task within at least one TD management activity.,,On the relationship between self-admitted technical debt removals and technical debt measures,"The technical debt (TD) in a software project refers to the adoption of an inadequate solution from its design to the source code. When developers admit the presence of technical debt in the source code, through comments or commit messages, it is called self-admitted technical debt (SATD). This aspect of TD has been the subject of numerous research studies, which have investigated its distribution, the impact on software quality, and removal. Therefore, this work focuses on the relationship between SATD and TD values. In particular, the study aims to compare the admitted technical debt with respect to its objective measure. In fact, the trends of TD values during SATD removals have been studied. This was done thanks to the use of an SATD dataset and their related removals in four open source projects. Instead, the SonarQube tool was used to measure TD values. Thanks to this work, it turned out that SATD removals in a few cases correspond to an effective reduction of TD values, while in numerous cases, the classes indicated are removed. © 2020 by the authors. Licensee MDPI, Basel, Switzerland.",Technical Debt,Tool,"Aversano, L. and Iammarino, M. and Carapella, M. and Vecchio, A.D. and Nardi, L.",Algorithms,"2,020.00",Review,10.3390/A13070168,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85115401194&doi=10.3390%2fA13070168&partnerID=40&md5=a8f01368e1ef5c76a8c1c712dab274e5,No,Self-admitted technical debt;  Software evolution;  Software maintenance;  Software measures;  Software quality;  Technical debt
S319,Read,Accepted,[IC1] - The primary study presents or points to a software artifact that automates a task within at least one TD management activity.,,Automated Identification of On-hold Self-Admitted Technical Debt,"Modern software is developed under considerable time pressure, which implies that developers more often than not have to resort to compromises when it comes to code that is well written and code that just does the job. This has led over the past decades to the concept of 'technical debt', a short-Term hack that potentially generates long-Term maintenance problems. Self-Admitted technical debt (SATD) is a particular form of technical debt: developers consciously perform the hack but also document it in the code by adding comments as a reminder (or as an admission of guilt). We focus on a specific type of SATD, namely 'On-hold' SATD, in which developers document in their comments the need to halt an implementation task due to conditions outside of their scope of work (e.g., an open issue must be closed before a function can be implemented).We present an approach, based on regular expressions and machine learning, which is able to detect issues referenced in code comments, and to automatically classify the detected instances as either 'On-hold' (the issue is referenced to indicate the need to wait for its resolution before completing a task), or as 'cross-reference', (the issue is referenced to document the code, for example to explain the rationale behind an implementation choice). Our approach also mines the issue tracker of the projects to check if the On-hold SATD instances are 'superfluous' and can be removed (i.e., the referenced issue has been closed, but the SATD is still in the code). Our evaluation confirms that our approach can indeed identify relevant instances of On-hold SATD. We illustrate its usefulness by identifying superfluous On-hold SATD instances in open source projects as confirmed by the original developers. © 2020 IEEE.",Technical Debt,Tool,"Maipradit, R. and Lin, B. and Nagy, C. and Bavota, G. and Lanza, M. and Hata, H. and Matsumoto, K.","Proceedings - 20th IEEE International Working Conference on Source Code Analysis and Manipulation, SCAM 2020","2,020.00",Conference Paper,10.1109/SCAM51674.2020.00011,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85097642624&doi=10.1109%2fSCAM51674.2020.00011&partnerID=40&md5=546e6224a37a8c2f83e5f1025cdcc7d1,No,empirical software engineering;  issue;  Self-Admitted technical debt
S323,Read,Accepted,[IC1] - The primary study presents or points to a software artifact that automates a task within at least one TD management activity.,,E-Debitum: Managing Software Energy Debt,"This paper extends previous work on the concept of a new software energy metric: Energy Debt. This metric is a reflection on the implied cost, in terms of energy consumption over time, of choosing an energy flawed software implementation over a more robust and efficient, yet time consuming, approach.This paper presents the implementation a SonarQube tool called E-Debitum which calculates the energy debt of Android applications throughout their versions. This plugin uses a robust, well defined, and extendable smell catalog based on current green software literature, with each smell defining the potential energy savings. To conclude, an experimental validation of E-Debitum was executed on 3 popular Android applications with various releases, showing how their energy debt fluctuated throughout releases. © 2020 ACM.",Technical Debt,Tool,"Maia, D. and Couto, M. and Saraiva, J. and Pereira, R.","Proceedings - 2020 35th IEEE/ACM International Conference on Automated Software Engineering Workshops, ASEW 2020","2,020.00",Conference Paper,10.1145/3417113.3422999,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85100624675&doi=10.1145%2f3417113.3422999&partnerID=40&md5=cd2a665d92fc09add78d5787db3f436b,No,Code Analysis;  Energy Debt;  Green Software
S334,Read,Accepted,[IC1] - The primary study presents or points to a software artifact that automates a task within at least one TD management activity.,,Evaluating the agreement among technical debt measurement tools: building an empirical benchmark of technical debt liabilities,"Software teams are often asked to deliver new features within strict deadlines leading developers to deliberately or inadvertently serve “not quite right code” compromising software quality and maintainability. This non-ideal state of software is efficiently captured by the Technical Debt (TD) metaphor, which reflects the additional effort that has to be spent to maintain software. Although several tools are available for assessing TD, each tool essentially checks software against a particular ruleset. The use of different rulesets can often be beneficial as it leads to the identification of a wider set of problems; however, for the common usage scenario where developers or researchers rely on a single tool, diverse estimates of TD and the identification of different mitigation actions limits the credibility and applicability of the findings. The objective of this study is two-fold: First, we evaluate the degree of agreement among leading TD assessment tools. Second, we propose a framework to capture the diversity of the examined tools with the aim of identifying few “reference assessments” (or class/file profiles) representing characteristic cases of classes/files with respect to their level of TD. By extracting sets of classes/files exhibiting similarity to a selected profile (e.g., that of high TD levels in all employed tools) we establish a basis that can be used either for prioritization of maintenance activities or for training more sophisticated TD identification techniques. The proposed framework is illustrated through a case study on fifty (50) open source projects and two programming languages (Java and JavaScript) employing three leading TD tools. © 2020, Springer Science+Business Media, LLC, part of Springer Nature.",Technical Debt,Tool,"Amanatidis, T. and Mittas, N. and Moschou, A. and Chatzigeorgiou, A. and Ampatzoglou, A. and Angelis, L.",Empirical Software Engineering,"2,020.00",Article,10.1007/s10664-020-09869-w,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85089866317&doi=10.1007%2fs10664-020-09869-w&partnerID=40&md5=ee93b3ecc34f5ffaaae104bc56db8b5b,No,Archetypal analysis;  Empirical benchmark;  Inter-rater agreement;  Software quality;  Technical debt
S308,Read,Accepted,[IC1] - The primary study presents or points to a software artifact that automates a task within at least one TD management activity.,,On energy debt: Managing consumption on evolving software,"This paper introduces the concept of energy debt: a new metric, reflecting the implied cost in terms of energy consumption over time, of choosing a flawed implementation of a software system rather than a more robust, yet possibly time consuming, approach. A flawed implementation is considered to contain code smells, known to have a negative influence on the energy consumption. Similar to technical debt, if energy debt is not properly addressed, it can accumulate an energy ""interest"". This interest will keep increasing as new versions of the software are released, and eventually reach a point where the interest will be higher than the initial energy debt. Addressing the issues/smells at such a point can remove energy debt, at the cost of having already consumed a significant amount of energy which can translate into high costs. We present all underlying concepts of energy debt, bridging the connection with the existing concept of technical debt and show how to compute the energy debt through a motivational example. © 2020 ACM.",Smells,Theoretical Artifact,"Couto, M. and Maia, D. and Saraiva, J. and Pereira, R.","Proceedings - 2020 IEEE/ACM International Conference on Technical Debt, TechDebt 2020","2,020.00",Conference Paper,10.1145/3387906.3388628,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85093108300&doi=10.1145%2f3387906.3388628&partnerID=40&md5=24ce41911c559074e1d270881047678f,No,code analysis;  energy debt;  green software
S43,Read,Rejected,[EC2a] - The study provides a broken link,"After checking the repository, the link provided is unavailable.",Towards Assessing Software Architecture Quality by Exploiting Code Smell Relations,"We can evaluate software architecture quality using a plethora of metrics proposed in the literature, but interpreting and exploiting in the right way these metrics is not always a simple task. This is true for both fixing the right metric threshold values and determining the actions to be taken to improve the quality of the system. Instead of metrics, we can detect code or architectural anomalies that give us useful hints on the possible architecture degradation. In this paper, we focus our attention on the detection of code smells and in particular on their relations and co-occurrences, with the aim to evaluate technical debt in an architectural context. We start from the assumption that certain patterns of code anomalies tend to be better indicators of architectural degradation than simple metrics evaluation. © 2015 IEEE.",Smells,Theoretical Artifact,"Fontana, F.A. and Ferme, V. and Zanoni, M.","Proceedings - 2nd International Workshop on Software Architecture and Metrics, SAM 2015",2015,Conference Paper,10.1109/SAM.2015.8,https://www.scopus.com/inward/record.uri?eid=2-s2.0-84946903258&doi=10.1109%2fSAM.2015.8&partnerID=40&md5=71990503c72077102aa92ccd3254defa,No,
S253,Read,Accepted,[IC1] - The primary study presents or points to a software artifact that automates a task within at least one TD management activity.,,Longitudinal evaluation of open-source software maintainability,"We present a longitudinal study on the long-term evolution of maintainability in open-source software. Quality assessment remains at the forefront of both software research and practice, with many models and assessment methodologies proposed and used over time. Some of them helped create and shape standards such as ISO 9126 and 25010, which are well established today. Both describe software quality in terms of characteristics such as reliability, security or maintainability. An important body of research exists linking these characteristics with software metrics, and proposing ways to automate quality assessment by aggregating software metric values into higher-level quality models. We employ the Maintainability Index, technical debt ratio and a maintainability model based on the ARiSA Compendium. Our study covers the entire 18 year development history and all released versions for three complex, open-source applications. We determine the maintainability for each version using the proposed models, we compare obtained results and use manual source code examination to put them into context. We examine the common development patterns of the target applications and study the relation between refactoring and maintainability. Finally, we study the strengths and weaknesses of each maintainability model using manual source code examination as the baseline. © Copyright 2020 by SCITEPRESS - Science and Technology Publications, Lda. All rights reserved.",TD Symptoms/Consequences,Theoretical Artifact,"Molnar, A.J. and Motogna, S.",ENASE 2020 - Proceedings of the 15th International Conference on Evaluation of Novel Approaches to Software Engineering,"2,020.00",Conference Paper,,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85088398239&partnerID=40&md5=e2031cd75d7404508db917f09e233874,No,Maintainability Index;  Software Maintainability;  Software Metrics;  Software Quality;  Technical Debt;  Technical Debt Ratio
S222,Read,Rejected,[EC2] - The study shows a theoretical artifact or do not provide a link to the artifact's repository;,The study did not point to their own solution and  it was not enough information to extract about Sonarqube.,The delta maintainability model: Measuring maintainability of fine-grained code changes,"Existing maintainability models are used to identify technical debt of software systems. Targeting entire codebases, such models lack the ability to determine shortcomings of smaller, fine-grained changes. This paper proposes a new maintainability model-the Delta Maintainability Model (DMM)-to measure fine-grained code changes, such as commits, by adapting and extending the SIG Maintainability Model. DMM categorizes changed lines of code into low and high risk, and then uses the proportion of low risk change to calculate a delta score. The goal of the DMM is twofold: first, producing meaningful and actionable scores; second, compare and rank the maintainability of fine-grained modifications. We report on an initial study of the model, with the goal of understanding if the adapted measurements from the SIG Maintainability Model suit the fine-grained scope of the DMM. In a manual inspection process for 100 commits, 67 cases matched the expert judgment. Furthermore, we report an exploratory empirical study on a data set of DMM scores on 3,017 issue-fixing commits of four open source and four closed source systems. Results show that the scores of DMM can be used to compare and rank commits, providing developers with a means to do root cause analysis on activities that impacted maintainability and, thus, address technical debt at a finer granularity. © 2019 IEEE.",TD Symptoms/Consequences,Theoretical Artifact,"Di Biase, M. and Rastogi, A. and Bruntink, M. and Van Deursen, A.","Proceedings - 2019 IEEE/ACM International Conference on Technical Debt, TechDebt 2019",2019,Conference Paper,10.1109/TechDebt.2019.00030,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85071160808&doi=10.1109%2fTechDebt.2019.00030&partnerID=40&md5=fccf26be249509efe4ed01855aebcbd6,No,Commits;  Fine grained;  Maintainability;  Model;  Technical debt
S272,Read,Accepted,[IC1] - The primary study presents or points to a software artifact that automates a task within at least one TD management activity.,,Towards a model-based fuzzy software quality metrics,"Code smells and Technical debt are two common notions that are often referred to for quantifying codebase quality. Quality metrics based on such notions often reply on rigid thresholds and are insensitive to the project unique context, such as development technologies, team size, and the desired code qualities. This challenge often manifest itself in inadequate quantification of code qualities and potentially numerous false positives cases. This paper presents a novel approach that formulates code quality metrics with thresholds that are derived from software design models. This method results in metrics that, instead of adopting rigid thresholds, formulates unique and evolving thresholds specific to each code module. This paper presents the novel methodology and introduces some novel code quality formulas. To evaluate the proposed formulas, we evaluate them against open source codebase developed by experienced software engineers. The results suggest that the proposed methodology results in code quality quantification that provides more adequate characterization. Copyright © 2020 by SCITEPRESS - Science and Technology Publications, Lda. All rights reserved.",TD Symptoms/Consequences,Theoretical Artifact,"Masmali, O. and Badreddin, O.",MODELSWARD 2020 - Proceedings of the 8th International Conference on Model-Driven Engineering and Software Development,"2,020.00",Conference Paper,,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85082984319&partnerID=40&md5=645f7f40db94d212d73d3e488b1ed313,No,Code Smells;  Model Driven Engineering;  Software Design;  Software Quality Metrics;  UML Class Diagram
S266,Read,Accepted,[IC1] - The primary study presents or points to a software artifact that automates a task within at least one TD management activity.,,A comparison of quality flaws and technical debt in model transformation specifications,"The quality of model transformations (MT) has high impact on model-driven engineering (MDE) software development approaches, because of the central role played by transformations in MDE for refining, migrating, refactoring and other operations on models. For programming languages, a popular paradigm for code quality is the concept of technical debt (TD), which uses the analogy that quality flaws in code are a debt burden carried by the software, which must either be ‘redeemed’ by expending specific effort to remove its flaws, or be tolerated, with ongoing additional costs to maintenance due to the flaws. Whilst the analysis and management of quality flaws and TD in programming languages has been investigated in depth over several years, less research on the topic has been carried out for model transformations. In this paper we investigate the characteristics of quality flaws and technical debt in model transformation languages, based upon systematic analysis of over 100 transformation cases in four leading MT languages. Based on quality flaw indicators for TD, we identify significant differences in the level and kinds of technical debt in different MT languages, and we propose ways in which TD in MT can be reduced and managed. © 2020 Elsevier Inc.",Technical Debt,Theoretical Artifact,"Kolahdouz-Rahimi, S. and Lano, K. and Sharbaf, M. and Karimi, M. and Alfraihi, H.",Journal of Systems and Software,"2,020.00",Article,10.1016/j.jss.2020.110684,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85086381665&doi=10.1016%2fj.jss.2020.110684&partnerID=40&md5=992a7eee002a59b3a9df05cff256dfc8,No,Model transformations;  Software quality;  Technical debt
S299,Read,Accepted,[IC1] - The primary study presents or points to a software artifact that automates a task within at least one TD management activity.,,ATDx: Building an architectural technical debt index,"Architectural technical debt (ATD) in software-intensive systems refers to the architecture design decisions which work as expedient in the short term, but later negatively impact system evolvability and maintainability. Over the years numerous approaches have been proposed to detect particular types of ATD at a refined level of granularity via source code analysis. Nevertheless, how to gain an encompassing overview of the ATD present in a software-intensive system is still an open question. In this study, we present a multi-step approach designed to build an ATD index (ATDx), which provides insights into a set of ATD dimensions building upon existing architectural rules by leveraging statistical analysis. The ATDx approach can be adopted by researchers and practitioners alike in order to gain a better understanding of the nature of the ATD present in software-intensive systems, and provides a systematic framework to implement concrete instances of ATDx according to specific project and organizational needs. © Copyright 2020 by SCITEPRESS - Science and Technology Publications, Lda. All rights reserved.",Technical Debt,Theoretical Artifact,"Verdecchia, R. and Lago, P. and Malavolta, I. and Ozkaya, I.",ENASE 2020 - Proceedings of the 15th International Conference on Evaluation of Novel Approaches to Software Engineering,"2,020.00",Conference Paper,,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85088371511&partnerID=40&md5=67c072aaf34651a2198536437f189b10,No,Software Analytics;  Software Architecture;  Software Maintenance;  Software Metrics;  Technical Debt
S303,Read,Accepted,[IC1] - The primary study presents or points to a software artifact that automates a task within at least one TD management activity.,,The quest for introducing technical debt management in a large-scale industrial company,"The long lifetime and the evolving nature of industrial products make them subject to technical debt management at different levels such as architecture and code. Although the classical steps to perform technical debt management are known, in a study that we have been performing in a large-scale industrial company as our client, we realized that finding a starting point, which leads to the desired outcome, is in fact a major challenge. This paper elaborates on various causes that we have identified for this challenge, and discusses our stepwise approach to address them so that the software quality can be improved. We believe that our experiences can be beneficial for both practitioners and researchers to gain more insight into applying quality improvement in practice as well as indicating open areas for further research. © Springer Nature Switzerland AG 2020.",Technical Debt,Theoretical Artifact,"Malakuti, S. and Ostroumov, S.",Lecture Notes in Computer Science (including subseries Lecture Notes in Artificial Intelligence and Lecture Notes in Bioinformatics),"2,020.00",Conference Paper,10.1007/978-3-030-58923-3_20,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85091525091&doi=10.1007%2f978-3-030-58923-3_20&partnerID=40&md5=114b4708e0e4a23497b00a3598a6931b,No,Quality improvement;  Software architecture;  Source code analysis;  Technical debt management
S75,Read,Rejected,[EC1] - The primary study is out of the scope of this work;,"After analysing the paper, it does not point to a artifact.",Modeling Design Flaw Evolution Using Complex Systems,"By modelling a software project as a complex system, its internal structure can be analyzed in order to asses its design quality. As a software system is being developed, the quality of its internal structure is evolving too, not always for the better. Flaws in the internal structure are usually indicators of code that is hard to understand, maintain and, in many cases, they are pointers of accumulated technical debt. While there are already methods and tools that enable design flaw detection, they only look at a snapshot of the code, they do not analyze how the design flaw evolved over time. We propose an approach which enhances design flaw detection with history information, in order to: (i) find patterns in the evolution of a design flaw, which could then be used to predict future activity, (ii) improve detection by eliminating false negatives, (iii) improve the recommendation system to provide better refactoring advices and a better ranking of design flaws, in order to address the most critical first. © 2015 IEEE.",TD Symptoms/Consequences,Theoretical Artifact,"Ganea, G. and Marinescu, R.","Proceedings - 17th International Symposium on Symbolic and Numeric Algorithms for Scientific Computing, SYNASC 2015",2016,Conference Paper,10.1109/SYNASC.2015.70,https://www.scopus.com/inward/record.uri?eid=2-s2.0-84964842081&doi=10.1109%2fSYNASC.2015.70&partnerID=40&md5=e41231dfa38db5b54f41ccffcf59799d,No,
S80,Read,Rejected,[EC2] - The study shows a theoretical artifact or do not provide a link to the artifact's repository;,"After reading to paper, the paper does not point to any artifact",Elasticity debt: A debt-aware approach to reason about elasticity decisions in the cloud,"Cloud elasticity provides the underlying primitives to dynamically acquire and release shared computational resources on demand. Therefore, elasticity constantly takes adaptation decisions to adjust the resource provisioning constrained by quality of service and operating costs minimization. However, dynamic trade-offs for resource provisioning rarely consider the value of the adaptation decisions under uncertainty. Part of the problem stems from the lack of a utility-driven model to reason about it. In this paper, we introduce the concept of elasticity debt as an approach to reason about elasticity decisions from a utility-driven perspective, where we apply the technical debt metaphor in the context of cloud elasticity. Moreover, we extended CloudSim as a proof of concept to show that a debt-aware elasticity decision-making can achieve a higher utility over time. We provide an elasticity conceptual model that links the key factors to consider when adapting resource provisioning and the potential debts incurred by these decisions. We propose a new perspective to value elasticity decisions in the uncertain cloud environment by introducing a technical debt perspective. Copyright © 2016 ACM.",TD Symptoms/Consequences,Theoretical Artifact,"Mera-Gómez, C. and Bahsoon, R. and Buyya, R.","Proceedings - 9th IEEE/ACM International Conference on Utility and Cloud Computing, UCC 2016",2016,Conference Paper,10.1145/2996890.2996904,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85009105922&doi=10.1145%2f2996890.2996904&partnerID=40&md5=28a22eccd6c9055a6d4f177a4d0a92c9,No,Auto-scaling;  Cloud computing;  Elasticity;  Technical debt
S99,Read,Rejected,[IC1] - The primary study presents or points to a software artifact that automates a task within at least one TD management activity.,"The study is a book, which the only chapter that points to TD is the firts one. In that, none artifact is pointed.",Trends in software testing,"This book is focused on the advancements in the field of software testing and the innovative practices that the industry is adopting. Considering the widely varied nature of software testing, the book addresses contemporary aspects that are important for both academia and industry. There are dedicated chapters on seamless high-efficiency frameworks, automation on regression testing, software by search, and system evolution management. There are a host of mathematical models that are promising for software quality improvement by model-based testing. There are three chapters addressing this concern. Students and researchers in particular will find these chapters useful for their mathematical strength and rigor. Other topics covered include uncertainty in testing, software security testing, testing as a service, test technical debt (or test debt), disruption caused by digital advancement (social media, cloud computing, mobile application and data analytics), and challenges and benefits of outsourcing. The book will be of interest to students, researchers as well as professionals in the software industry. © Springer Science+Business Media Singapore 2017.",TD Symptoms/Consequences,Theoretical Artifact,"Mohanty, H. and Mohanty, J.R. and Balakrishnan, A.",Trends in Software Testing,2016,Book,10.1007/978-981-10-1415-4,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85018861589&doi=10.1007%2f978-981-10-1415-4&partnerID=40&md5=92e67a809225ac1e55afaca63036b674,No,
S339,Read,Accepted,[IC1] - The primary study presents or points to a software artifact that automates a task within at least one TD management activity.,,Metamodel deprecation to manage technical debt in model co-evolution,"Model-Driven Engineering helps formalize problem-domains by using metamodels. Modeling ecosystems consisting of purposely designed editors, transformations, and code generators are defined on top of the metamodels. Analogously to other software forms, metamodels can evolve - -consequently, the validity of existing artifacts might be compromised. Coupled evolution provides techniques for restoring artifacts' validity in response to metamodel evolution. In this paper, we propose using deprecation in metamodeling to mitigate the difficulties in performing a class of adaptations that must be operated manually. Technical debt in co-evolution can be regarded as the outcome of procrastinating the migration of artifacts and, thus, must be reduced if not eliminated. Tool support for the adoption of deprecation and technical debt is used to demonstrate the feasibility of the methods. © 2020 ACM.",Technical Debt,Theoretical Artifact,"Iovino, L. and Di Salle, A. and Di Ruscio, D. and Pierantonio, A.","Proceedings - 23rd ACM/IEEE International Conference on Model Driven Engineering Languages and Systems, MODELS-C 2020 - Companion Proceedings","2,020.00",Conference Paper,10.1145/3417990.3419625,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85096759626&doi=10.1145%2f3417990.3419625&partnerID=40&md5=13b25b6e6f2400e47b26b391478a101f,No,Deprecation;  MDE;  Metamodeling;  Technical debt
S155,Read,Rejected,[EC2] - The study shows a theoretical artifact or do not provide a link to the artifact's repository;,"After reading the paper, it does not point to any artifact",On the value of a prioritization scheme for resolving Self-admitted technical debt,"Programmers tend to leave incomplete, temporary workarounds and buggy codes that require rework in software development and such pitfall is referred to as Self-admitted Technical Debt (SATD). Previous studies have shown that SATD negatively affects software project and incurs high maintenance overheads. In this study, we introduce a prioritization scheme comprising mainly of identification, examination and rework effort estimation of prioritized tasks in order to make a final decision prior to software release. Using the proposed prioritization scheme, we perform an exploratory analysis on four open source projects to investigate how SATD can be minimized. Four prominent causes of SATD are identified, namely code smells (23.2%), complicated and complex tasks (22.0%), inadequate code testing (21.2%) and unexpected code performance (17.4%). Results show that, among all the types of SATD, design debts on average are highly prone to software bugs across the four projects analysed. Our findings show that a rework effort of approximately 10 to 25 commented LOC per SATD source file is needed to address the highly prioritized SATD (vital few) tasks. The proposed prioritization scheme is a novel technique that will aid in decision making prior to software release in an attempt to minimize high maintenance overheads. © 2017 Elsevier Inc.",Technical Debt,Theoretical Artifact,"Mensah, S. and Keung, J. and Svajlenko, J. and Bennin, K.E. and Mi, Q.",Journal of Systems and Software,2018,Article,10.1016/j.jss.2017.09.026,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85031008685&doi=10.1016%2fj.jss.2017.09.026&partnerID=40&md5=38bde174d903e196f4c42505e21c36f7,No,Open source projects;  Prioritization scheme;  Self-admitted technical debt;  Source code comment;  Textual indicators
S311,Read,Accepted,[IC1] - The primary study presents or points to a software artifact that automates a task within at least one TD management activity.,,Technical debt in procedural model transformation languages,"Model transformations (MT) are a significant element of model-based and model-driven engineering approaches. Hence their quality is important for their effectiveness for use in such developments. The concept of technical debt (TD) estimates the impact of quality flaws on the maintenance costs of software artefacts. In this paper we define a quality model for model transformation languages, and define TD indicators for MT based on this model. We apply the indicators to evaluate the TD levels in 40 transformation cases in three procedural MT languages: QVT-O, Kermeta and EGL, and compare these levels with results for the declarative QVT-R language. © 2020 Elsevier Ltd",TD Symptoms/Consequences,Theoretical Artifact,"Kolahdouz-Rahimi, S. and Lano, K. and Karimi, M.",Journal of Computer Languages,"2,020.00",Article,10.1016/j.cola.2020.100971,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85084730744&doi=10.1016%2fj.cola.2020.100971&partnerID=40&md5=6fad329fa92147822749067acaf07681,No,Model transformations;  Software quality;  Technical debt
S230,Read,Rejected,[IC1] - The primary study presents or points to a software artifact that automates a task within at least one TD management activity.,"After reading, it does not point to an artifact",Increasing awareness for potential technical debt in the engineering of production systems,"Engineers from the production systems domain have to cope with various challenges. These include interdisciplinarity, an ever increasing complexity, and time pressure. Due to these factors, engineers oftentimes choose suboptimal solutions, thus causing so-called Technical Debt (TD). No matter whether this TD is taken consciously or unconsciously, engineers need to become aware of their decisions' potential repercussions as early as possible. This paper presents a conceptual framework that helps engineers to identify conformance violations and inconsistencies based on formal knowledge bases. This increases awareness for potential TD. We hereby emphasize the importance of interdisciplinary inconsistencies, which are especially hard to keep track of. The framework also aims to assess the criticality of TD and thus supports decision making in the engineering of production systems. © 2019 IEEE.",Technical Debt,Theoretical Artifact,"Ocker, F. and Seitz, M. and Oligschlager, M. and Zou, M. and Vogel-Heuser, B.",IEEE International Conference on Industrial Informatics (INDIN),2019,Conference Paper,10.1109/INDIN41052.2019.8972268,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85079037616&doi=10.1109%2fINDIN41052.2019.8972268&partnerID=40&md5=4ebc11efc715b2407d6eb04973163f1c,No,Identification;  Intelligent supervision;  Mechatronic systems;  Production systems;  Systems engineering;  Technical debt
S281,Read,Accepted,[IC1] - The primary study presents or points to a software artifact that automates a task within at least one TD management activity.,,How junior developers deal with their technical debt?,"Technical debt is a metaphor that measures the additional effort needed to continue to add more features in a software due to its inherent decrease in code quality. Most software systems suffer from technical debt at some point so that dedicated tools and metrics have been developed to monitor such debt. Alongside tools, appropriate engineering practices must be put in place by the development team to keep that debt at an acceptable level. In this empirical study, we observed and surveyed Scrum development teams composed of experienced students in order to understand their quality-related processes on a year-long academic project. We found that (1) students do use static analysis tools of many forms, but their actual usage is limited due to time pressure; (2) retrospective and non-constraining feedback on code quality has little to no effect, even when given regularly during the course of the project; and (3) junior developers value composite quality indicators (e.g., maintainability, reliability in SonarQube), even if they do not fully understand their meaning. From our findings, we propose a series of recommendations, both technical and methodological, on how to train junior developers to understand and manage technical debt. © 2020 ACM.",Technical Debt,Survey,"Gilson, F. and Morales-Trujillo, M. and Mathews, M.","Proceedings - 2020 IEEE/ACM International Conference on Technical Debt, TechDebt 2020","2,020.00",Conference Paper,10.1145/3387906.3388624,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85093085706&doi=10.1145%2f3387906.3388624&partnerID=40&md5=63079a2815fc72749c121a7100842536,No,empirical study;  software quality metrics;  static code analysis
S286,Read,Accepted,[IC1] - The primary study presents or points to a software artifact that automates a task within at least one TD management activity.,,How long do junior developers take to remove technical debt items?,"Background. Software engineering is one of the engineering fields with the highest inflow of junior engineers. Tools that utilize source code analysis to provide feedback on internal software quality, i.e. Technical Debt (TD), are valuable to junior developers who can learn and improve their coding skills with minimal consultations with senior colleagues. Objective. We aim at understating which SonarQube TD items junior developers prioritize during the refactoring and how long they take to refactor them. Method. We designed a case study with replicated design and we conducted it with 185 junior developers in two countries, that developed 23 projects with different programming languages and architectures. Results. Junior developers focus homogeneously on different types of TD items. Moreover, they can refactor items in a fraction of the estimated time, never spending more than 50% of the time estimated by SonarQube. Conclusion. Junior Developers appreciate the usage of SonarQube and considered as a useful tool. Companies might ask junior developers to quickly clean their code. © 2020 IEEE Computer Society. All rights reserved.",Technical Debt,Survey,"Lenarduzzi, V. and Mandić, V. and Katin, A. and Taibi, D.",International Symposium on Empirical Software Engineering and Measurement,"2,020.00",Conference Paper,10.1145/3382494.3422169,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85095828765&doi=10.1145%2f3382494.3422169&partnerID=40&md5=201eb0948742fc5fe6b15371987b312d,No,Empirical Study;  Junior Developers;  Remediation Time;  SonarQube;  Technical Debt
S269,Read,Accepted,[IC1] - The primary study presents or points to a software artifact that automates a task within at least one TD management activity.,,An empirical study on the evolution of design smells,"The evolution of software systems often leads to its architectural degradation due to the presence of design problems. In the literature, design smells have been defined as indicators of such problems. In particular, the presence of design smells could indicate the use of constructs that are harmful to system maintenance activities. In this work, an investigation on the nature and presence of design smells has been performed. An empirical study has been conducted considering the complete history of eight software systems, commit by commit. The detection of instances of multiple design smell types has been performed at each commit, and the analysis of the relationships between the detected smells and the maintenance activities, specifically due to refactoring activities, has been investigated. The proposed study evidenced that classes affected by design smells are more subject to change, especially when multiple smells are detected in the same classes. Moreover, it emerged that in some cases these smells are removed, and this occurs involving more smells at the same time. Finally, results indicate that smells removals are not correlated to the refactoring activities. © 2020 by the authors. Licensee MDPI, Basel, Switzerland.",Smells,MSR Studies,"Aversano, L. and Carpenito, U. and Iammarino, M.",Information (Switzerland),"2,020.00",Article,10.3390/INFO11070348,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85089286248&doi=10.3390%2fINFO11070348&partnerID=40&md5=0cf0e5639194a53310ad2749d9709770,No,Design smells;  Software evolution;  Software maintenance;  Technical debt
S274,Read,Accepted,[IC1] - The primary study presents or points to a software artifact that automates a task within at least one TD management activity.,,On the Diffusion and Impact of Code Smells in Web Applications,"Web applications (web apps) have become one of the largest parts of the current software market over years. Modern web apps offer several business benefits over other traditional and standalone applications. Mainly, cross-platform compatibility and data integration are some of the critical features that encouraged businesses to shift towards the adoption of Web apps. Web apps are evolving rapidly to acquire new features, correct errors or adapt to new environment changes especially with the volatile context of the web development. These ongoing amends often affect software quality due to poor coding and bad design practices, known as code smells or anti-patterns. The presence of code smells in a software project is widely considered as form of technical debt and makes the software harder to understand, maintain and evolve, besides leading to failures and unforeseen costs. Therefore, it is critical for web apps to monitor the existence and spread of such anti-patterns. In this paper, we specifically target web apps built with PHP being the most used server-side programming language. We conduct the first empirical study to investigate the diffuseness of code smells in Web apps and their relationship with the change proneness of affected code. We detect 12 types of common code smells across a total of 223 releases of 5 popular and long-lived open-source web apps. The key findings of our study include: 1) complex and large classes and methods are frequently committed in PHP files, 2) smelly files are more prone to change than non-smelly files, and 3) Too Many Methods and High Coupling are the most associated smells with files change-proneness. © 2020, Springer Nature Switzerland AG.",Smells,MSR Studies,"Bessghaier, N. and Ouni, A. and Mkaouer, M.W.",Lecture Notes in Computer Science (including subseries Lecture Notes in Artificial Intelligence and Lecture Notes in Bioinformatics),"2,020.00",Conference Paper,10.1007/978-3-030-59592-0_5,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85091578396&doi=10.1007%2f978-3-030-59592-0_5&partnerID=40&md5=eebc2b319b836ee2c8ab719d9903da76,No,Change proneness;  Code smells;  Diffuseness;  PHP;  Web applications
S313,Read,Rejected,[EC1] - The primary study is out of the scope of this work;,"After reading the paper, it does not explain for what tools are used.",Continuous Debt Valuation Approach (CoDVA) for Technical Debt Prioritization,"This paper proposes a technical debt prioritization technique to be used throughout software development lifecycle. Our method stresses a broader perspective of the product, so the focus is kept on optimizing the software artifacts supporting the complete flow of the value for the customer (including e.g. test environment or deployment pipelines). Many technical debt approaches are focused on static code analysis and misconsider business aspects as a separate activity. On the contrary, our method, based on the New Solution Selling Process, strongly advocates for a business perspective. It facilitates technical debt valuation against a predicted product roadmap by a close alignment with a structured sales process and the advancement of sales opportunities. Taking into account prediction of sales, progress of conversations with potential clients and bids, probability that a given functionality will be prioritized for the development, this approach may serve as a reference point for measuring business value of technical debt continuously. This valuation serves as a relative comparison of technical debt items enabling prioritization of effort to pay off technical debt. The method was evaluated on a release of a wireless telecommunication system. The results confirm that the suggested priorities may address the most profitable product areas from the company's perspective and ultimately optimize the value for customers. © 2020 IEEE.",Technical Debt,Theoretical Artifact,"Stochel, M.G. and Cholda, P. and Wawrowski, M.R.","Proceedings - 46th Euromicro Conference on Software Engineering and Advanced Applications, SEAA 2020",2020,Conference Paper,10.1109/SEAA51224.2020.00066,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85096543675&doi=10.1109%2fSEAA51224.2020.00066&partnerID=40&md5=24edd1e10bfa8e52017c356b486050fa,No,Prioritization and Valuation;  Software Development;  Software Engineering;  Software Maintenance and Evolution;  Technical Debt Management
S325,Read,Rejected,[EC1] - The primary study is out of the scope of this work;,"After reading the paper, it does uses or points to any tools, indeed, it analyses (manually) the presence of TD in Deep Learning Projects",Is Using Deep Learning Frameworks Free? Characterizing Technical Debt in Deep Learning Frameworks,"Developers of deep learning applications (shortened as application developers) commonly use deep learning frameworks in their projects. However, due to time pressure, market competition, and cost reduction, developers of deep learning frameworks (shortened as framework developers) often have to sacrifice software quality to satisfy a shorter completion time. This practice leads to technical debt in deep learning frameworks, which results in the increasing burden to both the application developers and the framework developers in future development.In this paper, we analyze the comments indicating technical debt (self-Admitted technical debt) in 7 of the most popular open-source deep learning frameworks. Although framework developers are aware of such technical debt, typically the application developers are not. We find that: 1) there is a significant number of technical debt in all the studied deep learning frameworks. 2) there is design debt, defect debt, documentation debt, test debt, requirement debt, compatibility debt, and algorithm debt in deep learning frameworks. 3) the majority of the technical debt in deep learning framework is design debt (24.07%-65.27%), followed by requirement debt (7.09%-31.48%) and algorithm debt (5.62%-20.67%). In some projects, compatibility debt accounts for more than 10%. These findings illustrate that technical debt is common in deep learning frameworks, and many types of technical debt also impact the deep learning applications. Based on our findings, we highlight future research directions and provide recommendations for practitioners. © 2020 ACM.",Technical Debt,Theoretical Artifact,"Liu, J. and Huang, Q. and Xia, X. and Shihab, E. and Lo, D. and Li, S.","Proceedings - 2020 ACM/IEEE 42nd International Conference on Software Engineering: Software Engineering in Society, ICSE-SEIS 2020",2020,Conference Paper,,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85099127778&partnerID=40&md5=dac34d4ff4a9a1fc3ce75d4ecefd5799,No,• Software and its engineering → Software evolution; Maintaining software
S326,Read,Rejected,[EC1] - The primary study is out of the scope of this work;,"After reading, the study does not point to any artifact",A Composed Technical Debt Identification Methodology to Predict Software Vulnerabilities,"Technical debt (TD), its impact on development and its consequences such as defects and vulnerabilities, are of common interest and great importance to software researchers and practitioners. Although there exist many studies investigating TD, the majority of them focuses on identifying and detecting TD from a single stage of development. There are also studies that analyze vulnerabilities focusing on some phases of the life cycle. Moreover, several approaches have investigated the relationship between TD and vulnerabilities, however, the generalizability and validity of findings are limited due to small dataset. In this study, we aim to identify TD through multiple phases of development, and to automatically measure it through data and text mining techniques to form a comprehensive feature model. We plan to utilize neural network based classifiers that will incorporate evolutionary changes on TD measures into predicting vulnerabilities. Our approach will be empirically assessed on open source and industrial projects. © 2020 ACM.",Technical Debt,Theoretical Artifact,"Halepmollasi, R.","Proceedings - 2020 ACM/IEEE 42nd International Conference on Software Engineering: Companion, ICSE-Companion 2020",2020,Conference Paper,10.1145/3377812.3381396,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85098550296&doi=10.1145%2f3377812.3381396&partnerID=40&md5=0eb1b6c877ef8f74621ed6fa10a0bb17,No,feature engineering;  machine learning;  software security;  technical debt
S290,Read,Accepted,[IC1] - The primary study presents or points to a software artifact that automates a task within at least one TD management activity.,,Does code review really remove coding convention violations?,"Many software developers perceive technical debt as the biggest problems in their projects. They also perceive code reviews as the most important process to increase code quality. As inconsistent coding style is one source of technical debt, it is no surprise that coding convention violations can lead to patch rejection during code review. However, as most research has focused on developer's perception, it is not clear whether code reviews actually prevent the introduction of coding convention violations and the corresponding technical debt.Therefore, we investigated how coding convention violations are introduced, addressed, and removed during code review by developers. To do this, we analysed 16, 442 code review requests from four projects of the Eclipse community for the introduction of convention violations. Our result shows that convention violations accumulate as code size increases despite changes being reviewed. We also manually investigated 1, 268 code review requests in which convention violations disappear and observed that only a minority of them have been removed because a convention violation has been flagged in a review comment. The investigation results also highlight that one can speed up the code review process by adopting tools for code convention violation detection. © 2020 IEEE.",TD Symptoms/Consequences,MSR Studies,"Han, D. and Ragkhitwetsagul, C. and Krinke, J. and Paixao, M. and Rosa, G.","Proceedings - 20th IEEE International Working Conference on Source Code Analysis and Manipulation, SCAM 2020","2,020.00",Conference Paper,10.1109/SCAM51674.2020.00010,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85097645032&doi=10.1109%2fSCAM51674.2020.00010&partnerID=40&md5=063191f10de56ef0abc56a9de481b58e,No,code review;  coding conventions;  coding style
S293,Read,Accepted,[IC1] - The primary study presents or points to a software artifact that automates a task within at least one TD management activity.,,An empirical study on self-fixed technical debt,"Technical Debt (TD) can be paid back either by those that incurred it or by others. We call the former self-fixed TD, and it is particularly effective, as developers are experts in their own code and are best-suited to fix the corresponding TD issues. To what extent is TD self-fixed, which types of TD are more likely to be self-fixed and is the remediation time of self-fixed TD shorter than non-self-fixed TD? This paper attempts to answer these questions. It reports on an empirical study that analyzes the self-fixed issues of five types of TD (i.e., Code, Defect, Design, Documentation and Test), captured via static analysis, in more than 17,000 commits from 20 Python projects of the Apache Software Foundation. The results show that more than two thirds of the issues are self-fixed and that the self-fixing rate is negatively correlated with the number of commits, developers and project size. Furthermore, the survival time of self-fixed issues is generally shorter than non-self-fixed issues. Moreover, the majority of Defect Debt tends to be self-fixed and has a shorter survival time, while Test Debt and Design Debt are likely to be fixed by other developers. These results can benefit both researchers and practitioners by aiding the prioritization of TD remediation activities within development teams, and by informing the development of TD management tools. © 2020 ACM.",Technical Debt,MSR Studies,"Tan, J. and Feitosa, D. and Avgeriou, P.","Proceedings - 2020 IEEE/ACM International Conference on Technical Debt, TechDebt 2020","2,020.00",Conference Paper,10.1145/3387906.3388621,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85093087345&doi=10.1145%2f3387906.3388621&partnerID=40&md5=95fe39ec2933e1609ad4d2bc60cf020b,No,python;  self-fixed issues;  static analysis;  technical debt
S302,Read,Accepted,[IC1] - The primary study presents or points to a software artifact that automates a task within at least one TD management activity.,,On the temporality of introducing code technical debt,"Code Technical Debt (TD) is intentionally or unintentionally created when developers introduce inefficiencies in the codebase. This can be attributed to various reasons such as heavy work-load, tight delivery schedule, unawareness of good practices, etc. To shed light into the context that leads to technical debt accumulation, in this paper we investigate: (a) the temporality of code technical debt introduction in new methods, i.e., whether the introduction of technical debt is stable across the lifespan of the project, or if its evolution presents spikes; and (b) the relation of technical debt introduction and the development team’s workload in a given period. To answer these questions, we perform a case study on twenty-seven Apache projects, and inspect the number of Technical Debt Items introduced in 6-month sliding temporal windows. The results of the study suggest that: (a) overall, the number of Technical Debt Items introduced through new code is a stable metric, although it presents some spikes; and (b) the number of commits performed is not strongly correlated to the number of introduced Technical Debt Items. © Springer Nature Switzerland AG 2020.",Technical Debt,MSR Studies,"Digkas, G. and Ampatzoglou, A. and Chatzigeorgiou, A. and Avgeriou, P.",Communications in Computer and Information Science,"2,020.00",Conference Paper,10.1007/978-3-030-58793-2_6,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85091180065&doi=10.1007%2f978-3-030-58793-2_6&partnerID=40&md5=06638e323507183e6067c9986a8b1653,No,Case study;  Metrics fluctuation;  New code debt;  Technical debt temporality
S314,Read,Accepted,[IC1] - The primary study presents or points to a software artifact that automates a task within at least one TD management activity.,,"Refactoring, Bug Fixing, and New Development Effect on Technical Debt: An Industrial Case Study","Code evolution, whether related to the development of new features, bug fixing, or refactoring, inevitably changes the quality of the code. One particular type of such change is the accumulation of Technical Debt (TD) resulting from sub-optimal design decisions. Traditionally, refactoring is one of the means that has been acknowledged to help to keep TD under control. Developers refactor their code to improve its maintainability and to repay TD (e.g., by removing existing code smells and anti-patterns in the source code). While the accumulation of the TD and the effect of refactoring on TD have been studied before, there is a lack of empirical evidence from industrial projects on how the different types of code changes affect the TD and whether specific refactoring operations are more effective for repaying TD. To fill this gap, we conducted an empirical study on an industrial project and investigated how Refactoring, Bug Fixing, and New Development affect the TD. We have analyzed 2, 286 commits in total to identify which activities reduced, kept the same, or even increased the TD, further delving into specific refactoring operations to assess their impact. Our results suggest that TD in the studied project is mainly introduced in the development of new features (estimated in 72.8 hours). Counterintuitively, from the commits tagged as refactoring, only 22.90% repay TD (estimated to repay 8.30 hours of the TD). Moreover, while some types of refactoring operations (e.g., Extract Method), help repaying TD, other refactoring operations (e.g., Move Class) are highly prone to introduce more TD. © 2020 IEEE.",Technical Debt,MSR Studies,"Zabardast, E. and Gonzalez-Huerta, J. and Smite, D.","Proceedings - 46th Euromicro Conference on Software Engineering and Advanced Applications, SEAA 2020","2,020.00",Conference Paper,10.1109/SEAA51224.2020.00068,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85096620525&doi=10.1109%2fSEAA51224.2020.00068&partnerID=40&md5=008ff097bd5a747912e1f31f69da1bc9,No,Bug Fixing;  Case Study;  Empirical Study;  Industrial Study;  New Development;  Refactoring;  Technical Debt
S316,Read,Accepted,[IC1] - The primary study presents or points to a software artifact that automates a task within at least one TD management activity.,,Investigating the Relationship between Co-occurring Technical Debt in Python,"Technical debt (TD) reflects issues that may negatively affect software maintenance and evolution. There is currently little evidence on how the different types of TD co-occur; for example, how code smells and design smells affect the same part of the system. This paper investigates how different types of TD co-occur, as well as the time period of the co-occurrence. To that end, we analyzed the co-occurring associations between five types of TD, captured in 42 SonarQube rules, in 3862 files of 20 Python projects from the Apache Software Foundation. We found that this phenomenon is dominant, affecting more than 90% of Python files. We also found that Documentation Debt and Test Debt appear in the majority of the files, although it seems to be mostly by coincidence. Finally, we noticed that co-occurrence of TD seems to happen very quickly: co-occurring issues tend to be introduced within the same week. But once it does happen, it is hard to get rid of. These results can benefit both researchers and practitioners by: aiding the prioritization of TD remediation; leading to novel tools for detecting co-occurring TD and warning potential issues; shedding further light on the explanation of how TD is introduced and can be mitigated. © 2020 IEEE.",Technical Debt,MSR Studies,"Tan, J. and Feitosa, D. and Avgeriou, P.","Proceedings - 46th Euromicro Conference on Software Engineering and Advanced Applications, SEAA 2020","2,020.00",Conference Paper,10.1109/SEAA51224.2020.00082,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85096564858&doi=10.1109%2fSEAA51224.2020.00082&partnerID=40&md5=0d623893e99c7dfa1ade4d9e4ecbdeca,No,Apache Software Foundation;  co-occurrence;  Python;  technical debt
S318,Read,Accepted,[IC1] - The primary study presents or points to a software artifact that automates a task within at least one TD management activity.,,CODE reuse in practice: Benefiting or harming technical debt,"During the last years the TD community is striving to offer methods and tools for reducing the amount of TD, but also understand the underlying concepts. One popular practice that still has not been investigated in the context of TD, is software reuse. The aim of this paper is to investigate the relation between white-box code reuse and TD principal and interest. In particular, we target at unveiling if the reuse of code can lead to software with better levels of TD. To achieve this goal, we performed a case study on approximately 400 OSS systems, comprised of 897 thousand classes, and compare the levels of TD for reused and natively-written classes. The results of the study suggest that reused code usually has less TD interest; however, the amount of principal in them is higher. A synthesized view of the aforementioned results suggest that software engineers shall opt to reuse code when necessary, since apart from the established reuse benefits (i.e., cost savings, increased productivity, etc.) are also getting benefits in terms of maintenance. Apart from understanding the phenomenon per se, the results of this study provide various implications to research and practice. © 2020 Elsevier Inc.",Technical Debt,MSR Studies,"Feitosa, D. and Ampatzoglou, A. and Gkortzis, A. and Bibi, S. and Chatzigeorgiou, A.",Journal of Systems and Software,"2,020.00",Article,10.1016/j.jss.2020.110618,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85085600238&doi=10.1016%2fj.jss.2020.110618&partnerID=40&md5=d1aeb8bef87fa072c6e747cdc8606cbf,No,Case study;  Reuse;  Technical debt
S327,Read,Accepted,[IC1] - The primary study presents or points to a software artifact that automates a task within at least one TD management activity.,,Long-term evaluation of technical debt in open-source software,"Background: A consistent body of research and practice have identified that technical debt provides valuable and actionable insight into the design and implementation deficiencies of complex software systems. Existing software tools enable characterizing and measuring the amount of technical debt at selective granularity levels; by providing a computational model, they enable stakeholders to measure and ultimately control this phenomenon. Aims: In this paper we aim to study the evolution and characteristics of technical debt in open-source software. For this, we carry out a longitudinal study that covers the entire development history of several complex applications. The goal is to improve our understanding of how the amount and composition of technical debt changes in evolving software. We also study how new technical debt is introduced in software, as well as identify how developers handle its accumulation over the long term. Method: We carried out our evaluation using three complex, open-source Java applications. All 110 released versions, covering more than 10 years of development history for each application were analyzed using SonarQube. We studied how the amount, composition and history of technical debt changed during development, compared our results across the studied applications and present our most important findings. Results: For each application, we identified key versions during which large amounts of technical debt were added, removed or both. This had significantly more impact when compared to the lines of code or class count increases that generally occurred during development. However, within each version, we found high correlation between file lines of code and technical debt. We observed that the Pareto principle was satisfied for the studied applications, as 20% of issue types generated around 80% of total technical debt. Interestingly, there was a large degree of overlap between the issues that generated most of the debt across the studied applications. Conclusions: Early application versions showed greater fluctuation in the amount of existing technical debt. We found application size to be an unreliable predictor for the quantity of technical debt. Most debt was introduced in applications as part of milestone releases that expanded their feature set; likewise, we identified releases where extensive refactoring significantly reduced the level of debt. We also discovered that technical debt issues persist for a long time in source code, and their removal did not appear to be prioritized according to type or severity. © 2020 IEEE Computer Society. All rights reserved.",Technical Debt,MSR Studies,"Molnar, A.-J. and Motogna, S.",International Symposium on Empirical Software Engineering and Measurement,"2,020.00",Conference Paper,10.1145/3382494.3410673,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85095841703&doi=10.1145%2f3382494.3410673&partnerID=40&md5=34f2768b2605e8e2966dddc41f524fbe,No,Open-source;  Software evolution;  Software maintenance;  Static analysis;  Technical debt
S329,Read,Accepted,[IC1] - The primary study presents or points to a software artifact that automates a task within at least one TD management activity.,,Anticipating Identification of Technical Debt Items in Model-Driven Software Projects,"Model-driven development (MDD) and Technical Debt (TD) are software engineering approaches that look for promoting the quality of systems under development. Most research on TD focuses on application code as primary TD sources. In an MDD project, however, dealing with technical debt only on the source code may not be an adequate strategy because MDD projects should focus their software building efforts on models. Besides, in MDD projects, code generation is often done at a later stage than creating models, then dealing with TD only in source code can lead to unnecessary interest payments due to unmanaged debts, such as model and source codes artifacts desynchronization. Recent works concluded that MDD project codes are not technical debt free, making it necessary to investigate the possibility and benefits of applying TD identification techniques in earlier stages of the development process, such as in modeling phases. The use of TD concept in an MDD context is also known as Model-Driven Technical Debt (MDTD). This paper intends to analyze whether it is possible to use source code technical debt detection strategies to identify TD on code-generating models in the context of model-driven development projects. A catalog of nine different model technical debt items for platform-independent code-generating models was specified. An evaluation was performed to observe the effectiveness of the proposed catalog compared to existing source code identification techniques found in the literature. Through three different open source software projects, more than 78 thousand lines of code were investigated. Results revealed that, although the catalog items present different precision rates, it is possible to identify these model-driven technical debts before source code is generated. We hope that sharing this catalog version provides future contributions and improvements. © 2020 ACM.",Technical Debt,MSR Studies,"Gomes, R.A. and Pinheiro, L.B.L. and MacIel, R.S.P.",ACM International Conference Proceeding Series,"2,020.00",Conference Paper,10.1145/3422392.3422434,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85099361121&doi=10.1145%2f3422392.3422434&partnerID=40&md5=2d37c6fb124f501c43d7507cd03ae6d5,No,code smell;  model smell;  model-driven development;  models;  technical debt
S191,Read,Rejected,[IC1] - The primary study presents or points to a software artifact that automates a task within at least one TD management activity.,"After the reading of this paper, it does not specify what exactly the tool does",A taste of the software industry perception of technical debt and its management in Brazil,"Technical debt (TD) is receiving more and more attention in software engineering. Although it was initially used as a communication tool for technical and non-technical stakeholders, nowadays this concept supports the improvement of software’s internal quality. Despite the increasing number of studies regarding TD and its management, only a few are concerned with the industry. Therefore, this primary study aims to characterize TD and its management under the perspective of Brazilian software organizations using their practitioners as proxies. A survey was performed with 58 practitioners, representing about 12 organizations and 30 software projects. The analysis of 37 valid questionnaires indicates that TD is still unknown to a considerable fraction of the participants, and only a small group of organizations adopt TD management activities in their projects. The survey package is available and can be used to support further investigations on TD management in Brazilian and other software organizations. © 2018 Conferencia Iberoamericana de Software Engineering - CIbSE. All Rights Reserved.",Technical Debt,Survey,"Da Silva, V.M. and Junior, H.J. and Travassos, G.H.","Avances en Ingenieria de Software a Nivel Iberoamericano, CIbSE 2018",2018,Conference Paper,,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85054104315&partnerID=40&md5=c701097ce8f736ed4519419fb3e0a07d,No,Experimental software engineering;  Survey;  Technical debt
S330,Read,Accepted,[IC1] - The primary study presents or points to a software artifact that automates a task within at least one TD management activity.,,On the diffuseness of technical debt items and accuracy of remediation time when using SonarQube,"Context. Among the static analysis tools available, SonarQube is one of the most used. SonarQube detects Technical Debt (TD) items—i.e., violations of coding rules—and then estimates TD as the time needed to remedy TD items. However, practitioners are still skeptical about the accuracy of remediation time estimated by the tool. Objective. In this paper, we analyze both diffuseness of TD items and accuracy of remediation time, estimated by SonarQube, to fix TD items on a set of 21 open-source Java projects. Method. We designed and conducted a case study where we asked 81 junior developers to fix TD items and reduce the TD of 21 projects. Results. We observed that TD items are diffused in the analyzed projects and most items are code smells. Moreover, the results point out that the remediation time estimated by SonarQube is inaccurate and, as compared to the actual time spent to fix TD items, is in most cases overestimated. Conclusions. The results of our study are promising for practitioners and researchers. The former can make more aware decisions during project execution and resource management, the latter can use this study as a starting point for improving TD estimation models. © 2020",Technical Debt,MSR Studies,"Baldassarre, M.T. and Lenarduzzi, V. and Romano, S. and Saarimäki, N.",Information and Software Technology,"2,020.00",Article,10.1016/j.infsof.2020.106377,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85088664918&doi=10.1016%2fj.infsof.2020.106377&partnerID=40&md5=4df408d610ac5bacdaf9baf6816d7607,No,Case study;  Effort estimation;  Remediation time;  Sonarqube;  Technical debt
S283,Read,Rejected,[EC1] - The primary study is out of the scope of this work;,The study just cites a tool without explain exacltly what it does,On Coherence in Technical Debt Research : Awareness of the Risks Stemming from the Metaphorical Origin and Relevant Remediation Strategies,"In this survey paper on the recent research, the authors evaluate consistency of the use of technical debt terminology and its convergence with the agreed-upon conceptual model. This consistency is important from the perspective of decision makers, who may delay or even abandon investment in a given area of the product, unless the benefits from repaying a specific technical debt are clear enough. Additionally, the paper discusses a degree in which the metaphorical origins of the technical debt term are still present and influence the research. The analysis is focused on the selected conference papers and offers a view on the inherent dynamics behind shaping the technical debt concept and its conceptual model. Besides, by discussing aspects related to cognitive linguistics, this study provides the means to understand this dynamics and equip the reader with suggestions to decrease ambiguity in the research.The results of the research lead to the following conclusions: 1. Ambiguity stemming from the origin of metaphorical expression of technical debt still exists in the research and there is a need to decrease it by e.g. framing, clarification, and explicit limitation of the research field. 2. Tool designers, such as SonarQube, are not bound by the research results and lead to more confusion in defining technical debt. 3. Risk Management models should be applied to enable technical debt management by decision makers. Thus, Architecture Tradeoff Analysis Method and other Quality Attribute Models may serve as good references to expand the current technical debt model. Even though some ambiguity is still present, the technical debt concept as a software development artifact and agreed-upon conceptual model provide a consistent approach for interpretation and analysis of technical debt phenomenon. Notably, code smells can be mapped to a list of symptoms of technical debt items. © 2020 IEEE.",Technical Debt,Survey,"Stochel, M.G. and Cholda, P. and Wawrowski, M.R.","Proceedings - 46th Euromicro Conference on Software Engineering and Advanced Applications, SEAA 2020",2020,Conference Paper,10.1109/SEAA51224.2020.00067,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85096516131&doi=10.1109%2fSEAA51224.2020.00067&partnerID=40&md5=d59bc4f007f40f1cc1c6926e21efe08e,No,Architectural Smell;  Architectural Technical Debt;  Cognitive Linguistics;  Design Smell;  Metaphor;  Smell;  Software Architecture;  Software Economics;  Software Engineering;  Software Maintenance and Evolution;  Technical Debt;  Technical Debt Metaphor;  Technical Debt Research
S285,Read,Rejected,[IC1] - The primary study presents or points to a software artifact that automates a task within at least one TD management activity.,"After the reading of this paper, it does not specify what exactly the tool does",A taste of the software industry perception of technical debt and its management in Uruguay: A survey in software industry,"Background: Technical debt (TD) has been an important focus of attention in recent years by the scientific community and the software industry. TD is a concept for expressing the lack of internal software quality that directly affects its capacity to evolve. Some studies have focused on the TD industry perspective. Aims: To characterize how the software industry professionals in Uruguay understand, perceive, and adopt technical debt management (TDM) activities. Method: To replicate a Brazilian survey with the Uruguayan software industry and compare their findings. Results: From 259 respondents, many indicated any awareness of the TD concept due to the faced difficult to realize how to associate such a concept with actual software issues. Therefore, it is possible to observe a considerable variability in the importance of TDM among the respondents. However, a small part of the respondents declares to carry out TDM activities in their organizations. A list of software technologies declared as used by practitioners was produced and can be useful to support TDM activities. Conclusions: The TD concept and its management are not common yet in Uruguay. There are indications of TD unawareness and difficulties in the conduction of some TDM activities considered as very important by the practitioners. There is a need for more effort aiming to disseminate the TD knowledge and to provide software technologies to support the adoption of TDM in Uruguay. It is likely other software engineering communities face similar issues. Therefore, further investigations in these communities can be of interest. © 2020 IEEE Computer Society. All rights reserved.",Technical Debt,Survey,"Apa, C. and Solari, M. and Vallespir, D. and Travassos, G.H.",International Symposium on Empirical Software Engineering and Measurement,2020,Conference Paper,10.1145/3382494.3421463,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85095857699&doi=10.1145%2f3382494.3421463&partnerID=40&md5=00b84d8ae649809fea636f48fbc4b1d1,No,Empirical software engineering;  Experimental software engineering;  Survey;  Technical debt
S332,Read,Accepted,[IC1] - The primary study presents or points to a software artifact that automates a task within at least one TD management activity.,,Technical debt forecasting: An empirical study on open-source repositories,"Technical debt (TD) is commonly used to indicate additional costs caused by quality compromises that can yield short-term benefits in the software development process, but may negatively affect the long-term quality of software products. Predicting the future value of TD could facilitate decision-making tasks regarding software maintenance and assist developers and project managers in taking proactive actions regarding TD repayment. However, no notable contributions exist in the field of TD forecasting, indicating that it is a scarcely investigated field. To this end, in the present paper, we empirically evaluate the ability of machine learning (ML) methods to model and predict TD evolution. More specifically, an extensive study is conducted, based on a dataset that we constructed by obtaining weekly snapshots of fifteen open source software projects over three years and using two popular static analysis tools to extract software-related metrics that can act as TD predictors. Subsequently, based on the identified TD predictors, a set of TD forecasting models are produced using popular ML algorithms and validated for various forecasting horizons. The results of our analysis indicate that linear Regularization models are able to fit and provide meaningful forecasts of TD evolution for shorter forecasting horizons, while the non-linear Random Forest regression performs better than the linear models for longer forecasting horizons. In most of the cases, the future TD value is captured with a sufficient level of accuracy. These models can be used to facilitate planning for software evolution budget and time allocation. The approach presented in this paper provides a basis for predictive TD analysis, suitable for projects with a relatively long history. To the best of our knowledge, this is the first study that investigates the feasibility of using ML models for forecasting TD. © 2020 Elsevier Inc.",Technical Debt,MSR Studies,"Tsoukalas, D. and Kehagias, D. and Siavvas, M. and Chatzigeorgiou, A.",Journal of Systems and Software,"2,020.00",Article,10.1016/j.jss.2020.110777,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85089668454&doi=10.1016%2fj.jss.2020.110777&partnerID=40&md5=c5865fd97e7d4d15984d4e88ce60aad3,No,Empirical study;  Machine learning;  Technical debt;  Technical debt forecasting
S384,Read,Accepted,[IC1] - The primary study presents or points to a software artifact that automates a task within at least one TD management activity.,,ATDx: A tool for providing a data-driven overview of architectural technical debt in software-intensive systems,"Architectural technical debt (ATD) in software-intensive systems is mostly invisible to software developers, can be widespread throughout entire code-bases, and its remediation cost is often steep. In recent years, numerous approaches have been proposed to identify, keep track, and ultimately manage ATD. The variety of approaches available opens a new problem, namely how to gain an encompassing overview of the ATD identified in a software-intensive system. With this paper we make available the ATDx tool, an implementation of ATDx written in Python, designed in a plug-in fashion. ATDx is an approach designed to provide a data-driven, intuitive, and actionable overview of the ATD present in a portfolio of software projects. ATDx is based on third-party source code analysis tools, architectural issue severity calculation via clustering, and aggregation of measurements into different architectural technical debt dimensions. The ATDx tool allows users to automatically run the ATDx analysis, generate reports containing the ATDx analysis results, and is integrated with GitHub. In addition to the tool, we provide two already implemented plugins, allowing users to run the ATDx tool out-of-the-box. GitHub repository: https://github.com/S2-group/ATDx Video: https://youtu.be/ULT9fgxuB7E © 2021 Copyright for this paper by its authors. Use permitted under Creative Commons License Attribution 4.0 International (CC BY 4.0).",Technical Debt,Tool,"Ospina, S. and Verdecchia, R. and Malavolta, I. and Lago, P.",CEUR Workshop Proceedings,"2,021.00",Conference Paper,,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85117850664&partnerID=40&md5=ec083cccd8995030bb503d8e44957683,No,Index;  Software Architecture;  Software Engineering;  Technical Debt;  Tool
S353,Read,Accepted,[IC1] - The primary study presents or points to a software artifact that automates a task within at least one TD management activity.,,Determining Enterprise Architecture Smells from Software Architecture Smells,"Software Architectural Smells (SA smells) are design problems in the internal structure and behavior of an SA. These can be seen as a specific category under the umbrella concept of Technical Debt (TD). TD is a central concept in software development projects and having the means to detect and measure the smells is important to understand impairments they may cause. However, TD is only limited to the technical aspects and does not describe smells found on an enterprise level. Enterprise Architecture Debt (EAD) expands the concepts of TD beyond the technical aspects such that it covers the debts that can be found in all layers of an Enterprise Architecture (EA). EA smells give a measurement for EAD, by providing means for detecting the smell, hence enabling a method to quantify the level of debt. The goal of this paper is to find EA smells derived from existing SA smells. This has resulted in three new EA smells that could be used as measurements for the quality of an EA. They can also be used in the future as a basis for automatic EA smell detection. © 2021 IEEE.",Smells,Tool,"Tieu, B. and Hacks, S.","Proceedings - 2021 IEEE 23rd Conference on Business Informatics, CBI 2021 - Main Papers","2,021.00",Conference Paper,10.1109/CBI52690.2021.10064,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85119822953&doi=10.1109%2fCBI52690.2021.10064&partnerID=40&md5=a9151534468f2d00c10677fa6c62191b,No,
S356,Read,Accepted,[IC1] - The primary study presents or points to a software artifact that automates a task within at least one TD management activity.,,Experiences on Managing Technical Debt with Code Smells and AntiPatterns,"Technical debt has become a common metaphor for the accumulation of software design and implementation choices that seek fast initial gains but that are under par and counterproductive in the long run. However, as a metaphor, technical debt does not offer actionable advice on how to get rid of it. To get to a practical level in solving problems, more focused mechanisms are needed. Commonly used approaches for this include identifying code smells as quick indications of possible problems in the codebase and detecting the presence of AntiPatterns that refer to overt, recurring problems in design. There are known remedies for both code smells and AntiPatterns. In paper, our goal is to show how to effectively use common tools and the existing body of knowledge on code smells and AntiPatterns to detect technical debt and pay it back. We present two main results: (i) How a combination of static code analysis and manual inspection was used to detect code smells in a codebase leading to the discovery of AntiPatterns; and (ii) How AntiPatterns were used to identify, characterize, and fix problems in the software. The experiences stem from a private company and its long-lasting software product development effort. © 2021 IEEE.",Smells,Tool,"Lahti, J.R. and Tuovinen, A.-P. and Mikkonen, T.","Proceedings - 2021 IEEE/ACM International Conference on Technical Debt, TechDebt 2021","2,021.00",Conference Paper,10.1109/TechDebt52882.2021.00013,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85114816722&doi=10.1109%2fTechDebt52882.2021.00013&partnerID=40&md5=1e7008fde41d2f2fd0a2da13370b21a9,No,AntiPatterns;  case study;  code refactoring;  code smells;  software maintenance;  Technical debt
S122,Read,Rejected,[IC1] - The primary study presents or points to a software artifact that automates a task within at least one TD management activity.,"After checking the respository, no software artifact was pointed",Assessing code smell interest probability: A case study,"An important parameter in deciding to eliminate technical debt (TD) is the probability of a module to generate interest along software evolution. In this study, we explore code smells, which according to practitioners are the most commonly occurring type of TD in industry, by assessing the associated interest probability. As a proxy of smell interest probability we use the frequency of smell occurrences and the change proneness of the modules in which they are identified. To achieve this goal we present a case study on 47,751 methods extracted from two well-known open source projects. The results of the case study suggest that: (a) modules in which ""code smells"" are concentrated are more change-prone than smell-free modules, (b) there are specific types of ""code smells"" that are concentrated in the most change-prone modules, and (c) interest probability of code clones seems to be higher than the other two examined code smells. These results can be useful for both researchers and practitioners, in the sense that the former can focus their research on resolving ""code smells"" that produce more interest, and the latter can improve accordingly the prioritization of their repayment strategy and their training. © 2017 Association for Computing Machinery.",Smells,MSR Studies,"Charalampidou, S. and Ampatzoglou, A. and Chatzigeorgiou, A. and Avgeriou, P.",ACM International Conference Proceeding Series,2017,Conference Paper,10.1145/3120459.3120465,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85029856275&doi=10.1145%2f3120459.3120465&partnerID=40&md5=55e10d2595d4afa23e46a8badb62332d,No,Case study;  Change proneness;  Interest probability;  Technical debt
S135,Read,Rejected,[IC1] - The primary study presents or points to a software artifact that automates a task within at least one TD management activity.,"After checking the respository, no software artifact was pointed",When and Why Your Code Starts to Smell Bad (and Whether the Smells Go Away),"Technical debt is a metaphor introduced by Cunningham to indicate 'not quite right code which we postpone making it right'. One noticeable symptom of technical debt is represented by code smells, defined as symptoms of poor design and implementation choices. Previous studies showed the negative impact of code smells on the comprehensibility and maintainability of code. While the repercussions of smells on code quality have been empirically assessed, there is still only anecdotal evidence on when and why bad smells are introduced, what is their survivability, and how they are removed by developers. To empirically corroborate such anecdotal evidence, we conducted a large empirical study over the change history of 200 open source projects. This study required the development of a strategy to identify smell-introducing commits, the mining of over half a million of commits, and the manual analysis and classification of over 10K of them. Our findings mostly contradict common wisdom, showing that most of the smell instances are introduced when an artifact is created and not as a result of its evolution. At the same time, 80 percent of smells survive in the system. Also, among the 20 percent of removed instances, only 9 percent are removed as a direct consequence of refactoring operations. © 1976-2012 IEEE.",Smells,MSR Studies,"Tufano, M. and Palomba, F. and Bavota, G. and Oliveto, R. and Penta, M.D. and De Lucia, A. and Poshyvanyk, D.",IEEE Transactions on Software Engineering,2017,Article,10.1109/TSE.2017.2653105,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85040307811&doi=10.1109%2fTSE.2017.2653105&partnerID=40&md5=d2b0c8b235fdd2cfb1fa8d1ec2b401ea,No,Code smells;  empirical study;  mining software repositories
S379,Read,Accepted,[IC1] - The primary study presents or points to a software artifact that automates a task within at least one TD management activity.,,The Technical Debt Density over Multiple Releases and the Refactoring Story,"Do developers postpone fixing Technical Debt (TD) in software systems? TD is a metaphor that refers to short-term decisions in software development that may affect the cost of the software development life cycle. The bad smell is an imperfect solution in the software system that negatively impacts the internal software quality and maintainability. In this paper, we will study five open-source software projects (OSSPs) that have several releases and also estimate the numbers of architecture smells (ASs), design smells (DSs), and code smells (CSs) for every release. Designite will be used to detect smells. We describe a case study conducted to explore the following: (1) What is theaverage smells density for architecture, design, and code smells in an OSSP? (2) Does the density of each smell type increase over multiple releases? (3) What percentage of each smell-type density is eliminated by refactoring? We collected around 2 million LOC from five OSSPs that have multiple releases from the GitHub repository to statistically analyze the software concerning the smells as indicators of TD. We find 36% of Architecture Technical Debt (ATD) is Cyclic Dependency, while 33% of Design Debt (DD) is Cyclically-dependent Modularization. More than 70% of Code Debt (CD) is MagicNumber. Even though the developers do refactoring between releases, the TD density in general increases. On average, by refactoring, developers remove around 48%, 16%, and 22% from the introduced ATD, DD, and CD from their next release, respectively. © 2021 World Scientific Publishing Company.",Technical Debt,Tool,"Benidris, M. and Ammar, H. and Dzielski, D.",International Journal of Software Engineering and Knowledge Engineering,"2,021.00",Article,10.1142/S0218194021500017,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85100749826&doi=10.1142%2fS0218194021500017&partnerID=40&md5=f7c76b5b6a6f5e80d5aa3896e874c0d8,No,architecture smell;  code smell;  design smell;  refactoring;  Technical Debt
S380,Read,Accepted,[IC1] - The primary study presents or points to a software artifact that automates a task within at least one TD management activity.,,Experience with Managing Technical Debt in Scientific Software Development Using the EXA2PRO Framework,"Technical Debt (TD) is a software engineering metaphor that resembles the production of poor-quality code to going into debt. In particular, a development team that 'saves' effort while developing by not removing inefficiencies, has to 'pay-back' with interest, in the form of additional maintenance costs (i.e., fixing bugs, adding features, etc.) due to the poor maintainability of the developed code. Although maintainability assurance is an established practice in traditional software development (lately known as TD management), it has still not attracted the attention of scientific software developers; i.e., researchers writing code and developing tools for purely research purposes. Nevertheless, based on the literature and practice, maintainability seems to be ranked as an important key-driver for the development of such applications; since the effort needed to update the code before the experimentation (e.g., executing a simulation) is common and should not receive low priority. In this paper, we present the outcome of a 3-year research project on Technical Debt Management (TDM) for scientific software development. The outcome of the project is a framework (termed: EXA2PRO TDM framework) and an accompanying platform for assisting scientific software developers in managing the TD of their applications. The framework is a collection of methods tailored for the mainstream programming languages of scientific software development, which have been empirically validated through five pilot applications. The majority of the EXA2PRO framework suggestions have been applied by scientific software developers and eased future maintenance activities. © 2013 IEEE.",Technical Debt,Tool,"Nikolaidis, N. and Zisis, D. and Ampatzoglou, A. and Chatzigeorgiou, A. and Soudris, D.",IEEE Access,"2,021.00",Article,10.1109/ACCESS.2021.3079271,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85105883199&doi=10.1109%2fACCESS.2021.3079271&partnerID=40&md5=6593edf4ccb52d5b0da78e64b3b1ae72,No,and technical debt;  Code quality;  refactoring;  scientific software development
S383,Read,Accepted,[IC1] - The primary study presents or points to a software artifact that automates a task within at least one TD management activity.,,Technical Debt Forecasting Based on Deep Learning Techniques,"Technical debt (TD) is a metaphor commonly used to reflect the consequences of quality compromises that can derive short-term benefits but may result in quality decay of software products in the long run. While a broad variety of methods and tools have been proposed over the years for the identification and quantification of TD during the software development cycle, it is not until recently that researchers have turned their interest towards methods aiming to forecast the future TD evolution of a software project. Predicting the future value of TD could facilitate decision-making tasks regarding software maintenance and assist developers and project managers in taking proactive actions regarding TD repayment. In previous relevant studies, time series analysis and Machine Learning techniques have been employed in order to generate meaningful TD forecasts. While these approaches have been proven capable of producing reliable TD predictions, their predictive performance has been observed to decrease significantly for long-term predictions. To this end, in the present paper we investigate whether the adoption of Deep Learning may lead to more accurate long-term TD prediction. For this purpose, Deep Learning models are constructed, evaluated, and compared based on a dataset of five popular real-world software applications. The results of our analysis indicate that the adoption of Deep Learning results in TD forecasting models with sufficient predictive performance up to 150 steps ahead into the future. © 2021, Springer Nature Switzerland AG.",Technical Debt,Tool,"Mathioudaki, M. and Tsoukalas, D. and Siavvas, M. and Kehagias, D.",Lecture Notes in Computer Science (including subseries Lecture Notes in Artificial Intelligence and Lecture Notes in Bioinformatics),"2,021.00",Conference Paper,10.1007/978-3-030-87007-2_22,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85116010167&doi=10.1007%2f978-3-030-87007-2_22&partnerID=40&md5=006267f393429147a4517f2b43d3299c,No,Deep learning;  Forecasting;  Software quality;  Technical debt
S387,Read,Accepted,[IC1] - The primary study presents or points to a software artifact that automates a task within at least one TD management activity.,,Machine Learning for Technical Debt Identification,"Technical Debt (TD) is a successful metaphor in conveying the consequences of software inefficiencies and their elimination to both technical and non-technical stakeholders, primarily due to its monetary nature. The identification and quantification of TD rely heavily on the use of a small handful of sophisticated tools that check for violations of certain predefined rules, usually through static analysis. Different tools result in divergent TD estimates calling into question the reliability of findings derived by a single tool. To alleviate this issue we use 18 metrics pertaining to source code, repository activity, issue tracking, refactorings, duplication and commenting rates of each class as features for statistical and Machine Learning models, so as to classify them as High-TD or not. As a benchmark we exploit 18.857 classes obtained from 25 Java projects, whose high levels of TD has been confirmed by three leading tools. The findings indicate that it is feasible to identify TD issues with sufficient accuracy and reasonable effort: a subset of superior classifiers achieved an F&lt;sub&gt;2&lt;/sub&gt;-measure score of approximately 0.79 with an associated Module Inspection ratio of approximately 0.10. Based on the results a tool prototype for automatically assessing the TD of Java projects has been implemented. IEEE",Technical Debt,Tool,"Tsoukalas, D. and Mittas, N. and Chatzigeorgiou, A. and Kehagias, D.D. and Ampatzoglou, A. and Amanatidis, T. and Angelis, L.",IEEE Transactions on Software Engineering,"2,021.00",Article,10.1109/TSE.2021.3129355,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85120086359&doi=10.1109%2fTSE.2021.3129355&partnerID=40&md5=30dc3dec9e0bfb49943f97c2e25285d5,No,Benchmark testing;  Codes;  Java;  Machine learning;  Metrics/Measurement;  Quality analysis and evaluation;  Radio frequency;  Software;  Software maintenance;  Support vector machines;  Tools
S390,Read,Accepted,[IC1] - The primary study presents or points to a software artifact that automates a task within at least one TD management activity.,,FixMe: A GitHub Bot for Detecting and Monitoring On-Hold Self-Admitted Technical Debt,"Self-Admitted Technical Debt (SATD) is a special form of technical debt in which developers intentionally record their hacks in the code by adding comments for attention. Here, we focus on issue-related ""On-hold SATD"", where developers suspend proper implementation due to issues reported inside or outside the project. When the referenced issues are resolved, the On-hold SATD also need to be addressed, but since monitoring these issue reports takes a lot of time and effort, developers may not be aware of the resolved issues and leave the On-hold SATD in the code. In this paper, we propose FixMe, a GitHub bot that helps developers detecting and monitoring On-hold SATD in their repositories and notify them whenever the On-hold SATDs are ready to be fixed (i.e. the referenced issues are resolved). The bot can automatically detect On-hold SATD comments from source code using machine learning techniques and discover referenced issues. When the referenced issues are resolved, developers will be notified by FixMe bot. The evaluation conducted with 11 participants shows that our FixMe bot can support them in dealing with On-hold SATD. FixMe is available at https://www.fixmebot.app/ and FixMe's VDO is at https://youtu.be/YSz9kFxN_YQ. © 2021 IEEE.",Technical Debt,Tool,"Phaithoon, S. and Wongnil, S. and Pussawong, P. and Choetkiertikul, M. and Ragkhitwetsagul, C. and Sunetnanta, T. and Maipradit, R. and Hata, H. and Matsumoto, K.","Proceedings - 2021 36th IEEE/ACM International Conference on Automated Software Engineering, ASE 2021","2,021.00",Conference Paper,10.1109/ASE51524.2021.9678680,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85125454605&doi=10.1109%2fASE51524.2021.9678680&partnerID=40&md5=4f33c0638d19063ae52d47689a64f5b4,No,
S392,Read,Accepted,[IC1] - The primary study presents or points to a software artifact that automates a task within at least one TD management activity.,,A Clustering Approach Towards Cross-Project Technical Debt Forecasting,"Technical debt (TD) describes quality compromises that can yield short-term benefits but may negatively affect the quality of software products in the long run. A wide range of tools and techniques have been introduced over the years in order for the developers to be able to determine and manage TD. However, being able to also predict its future evolution is of equal importance to avoid its accumulation, and, in turn, the unlikely event of making the project unmaintainable. Although recent research endeavors have showcased the feasibility of building accurate project-specific TD forecasting models, there is a gap in the field regarding cross-project TD forecasting. Cross-project TD forecasting is of practical importance, since it would enable the application of pre-existing forecasting models on previously unknown software projects, especially new projects that do not exhibit sufficient commit history to enable the construction of project-specific models. To this end, in the present paper, we focus on cross-project TD forecasting, and we examine whether the consideration of similarities between software projects could be the key for more accurate forecasting. More specifically, we propose an approach based on data clustering. In fact, a relatively large repository of software projects is divided into clusters of similar projects with respect to their TD aspects, and specific TD forecasting models are built for each cluster, using regression algorithms. According to our approach, previously unknown software projects are assigned to one of the defined clusters and the cluster-specific TD forecasting model is applied to predict future TD values. The approach was evaluated through several experiments based on real-world applications. The results of the analysis suggest that the proposed approach comprises a promising solution for accurate cross-project TD forecasting. © 2021, Springer Nature Singapore Pte Ltd.",Technical Debt,Tool,"Tsoukalas, D. and Mathioudaki, M. and Siavvas, M. and Kehagias, D. and Chatzigeorgiou, A.",SN Computer Science,"2,021.00",Article,10.1007/s42979-020-00408-4,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85116053383&doi=10.1007%2fs42979-020-00408-4&partnerID=40&md5=37cb9755720cbe70011b0bfa7bfcc0c2,No,Cross-project prediction;  Data clustering;  Technical debt;  Technical debt forecasting
S398,Read,Accepted,[IC1] - The primary study presents or points to a software artifact that automates a task within at least one TD management activity.,,Impact of Opportunistic Reuse Practices to Technical Debt,"Technical debt (TD) has been recognized as an important quality problem for both software architecture and code. The evolution of TD techniques over the past years has led to a number of research and commercial tools. In addition, the increasing trend of opportunistic reuse (as opposed to systematic reuse), where developers reuse code assets in popular repositories, is changing the way components are selected and integrated into existing systems. However, reusing software opportunistically can lead to a loss of quality and induce TD, especially when the architecture is changed in the process. However, to the best of our knowledge, no studies have investigated the impact of opportunistic reuse in TD. In this paper, we carry out an exploratory study to investigate to what extent reusing components opportunistically negatively affects the quality of systems. We use one commercial and one research tool to analyze the TD ratios of three case systems, before and after opportunistically extending them with open-source software. © 2021 IEEE.",Technical Debt,Tool,"Capilla, R. and Mikkonen, T. and Carrillo, C. and Fontana, F.A. and Pigazzini, I. and Lenarduzzi, V.","Proceedings - 2021 IEEE/ACM International Conference on Technical Debt, TechDebt 2021","2,021.00",Conference Paper,10.1109/TechDebt52882.2021.00011,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85114827039&doi=10.1109%2fTechDebt52882.2021.00011&partnerID=40&md5=934d9d466016810c9acf88a4b0612b8d,No,architectural debt;  opportunistic reuse;  Technical debt
S37,Read,Rejected,[EC2] - The study shows a theoretical artifact or do not provide a link to the artifact's repository;,"No artifact was pointed by the study. Even the authors proposed a new tool (HistoryMiner), it is not available",When and why your code starts to smell bad,"In past and recent years, the issues related to managing technical debt received significant attention by researchers from both industry and academia. There are several factors that contribute to technical debt. One of these is represented by code bad smells, i.e., symptoms of poor design and implementation choices. While the repercussions of smells on code quality have been empirically assessed, there is still only anecdotal evidence on when and why bad smells are introduced. To fill this gap, we conducted a large empirical study over the change history of 200 open source projects from different software ecosystems and investigated when bad smells are introduced by developers, and the circumstances and reasons behind their introduction. Our study required the development of a strategy to identify smellintroducing commits, the mining of over 0.5M commits, and the manual analysis of 9,164 of them (i.e., those identified as smellintroducing). Our findings mostly contradict common wisdom stating that smells are being introduced during evolutionary tasks. In the light of our results, we also call for the need to develop a new generation of recommendation systems aimed at properly planning smell refactoring activities. © 2015 IEEE.",Smells,MSR Studies,"Tufano, M. and Palomba, F. and Bavota, G. and Olivetox, R. and Di Penta, M. and De Lucia, A. and Poshyvanyk, D.",Proceedings - International Conference on Software Engineering,2015,Conference Paper,10.1109/ICSE.2015.59,https://www.scopus.com/inward/record.uri?eid=2-s2.0-84951770740&doi=10.1109%2fICSE.2015.59&partnerID=40&md5=1779bf7d2c140bdf3ed8647f31f40b48,No,
S340,Read,Accepted,[IC1] - The primary study presents or points to a software artifact that automates a task within at least one TD management activity.,,On the lack of consensus among technical debt detection tools,"A vigorous and growing set of technical debt analysis tools have been developed in recent years-both research tools and industrial products-such as Structure 101, SonarQube, and DV8. Each of these tools identifies problematic files using their own definitions and measures. But to what extent do these tools agree with each other in terms of the files that they identify as problematic? If the top-ranked files reported by these tools are largely consistent, then we can be confident in using any of these tools. Otherwise, a problem of accuracy arises. In this paper, we report the results of an empirical study analyzing 10 projects using multiple tools. Our results show that: 1) these tools report very different results even for the most common measures, such as size, complexity, file cycles, and package cycles. 2) These tools also differ dramatically in terms of the set of problematic files they identify, since each implements its own definitions of 'problematic'. After normalizing by size, the most problematic file sets that the tools identify barely overlap. 3) Our results show that code-based measures, other than size and complexity, do not even moderately correlate with a file's change-proneness or error-proneness. In contrast, co-change-related measures performed better. Our results suggest that, to identify files with true technical debt-those that experience excessive changes or bugs-co-change information must be considered. Code-based measures are largely ineffective at pinpointing true debt. Finally, this study reveals the need for the community to create benchmarks and data sets to assess the accuracy of software analysis tools in terms of commonly used measures. © 2021 IEEE.",Technical Debt,Tool,"Lefever, J. and Cai, Y. and Cervantes, H. and Kazman, R. and Fang, H.",Proceedings - International Conference on Software Engineering,"2,021.00",Conference Paper,10.1109/ICSE-SEIP52600.2021.00021,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85115672324&doi=10.1109%2fICSE-SEIP52600.2021.00021&partnerID=40&md5=0a3313021fb3c600e25aaaa1ec563c6a,No,Software Analysis;  Software Maintainability;  Technical Debt
S142,Read,Rejected,[EC2a] - The study provides a broken link,The link provided by the study is broken,An Exploratory Study on the Relationship between Changes and Refactoring,"Refactoring aims at improving the internal structure of a software system without changing its external behavior. Previous studies empirically assessed, on the one hand, the benefits of refactoring in terms of code quality and developers' productivity, and on the other hand, the underlying reasons that push programmers to apply refactoring. Results achieved in the latter investigations indicate that besides personal motivation such as the responsibility concerned with code authorship, refactoring is mainly performed as a consequence of changes in the requirements rather than driven by software quality. However, these findings have been derived by surveying developers, and therefore no software repository study has been carried out to corroborate the achieved findings. To bridge this gap, we provide a quantitative investigation on the relationship between different types of code changes (i.e., Fault Repairing Modification, Feature Introduction Modification, and General Maintenance Modification) and 28 different refactoring types coming from 3 open source projects. Results showed that developers tend to apply a higher number of refactoring operations aimed at improving maintainability and comprehensibility of the source code when fixing bugs. Instead, when new features are implemented, more complex refactoring operations are performed to improve code cohesion. Most of the times, the underlying reasons behind the application of such refactoring operations are represented by the presence of duplicate code or previously introduced self-admitted technical debts. © 2017 IEEE.",TD Symptoms/Consequences,MSR Studies,"Palomba, F. and Zaidman, A. and Oliveto, R. and De Lucia, A.",IEEE International Conference on Program Comprehension,2017,Conference Paper,10.1109/ICPC.2017.38,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85025172556&doi=10.1109%2fICPC.2017.38&partnerID=40&md5=fd0269655eb20a7347798a4b00286fad,No,Code Changes;  Empirical Studies;  Refactoring
S348,Read,Accepted,[IC1] - The primary study presents or points to a software artifact that automates a task within at least one TD management activity.,,An Overview and Comparison of Technical Debt Measurement Tools,"Different tools adopt different terms, metrics, and ways to identify and measure technical debt (TD). Researchers attempt to clarify the situation by comparing the features and popularity of technical debt measurement tools and analyzing the existing empirical evidence on their validity. Researchers’ aim is to provide an overview of the current landscape of TD measurement tools through a set of objective criteria related to the offered features and their popularity. Practitioners can use this overview to assess the tools, understand their strengths and weaknesses, and ultimately select the most suitable one for their needs.",Technical Debt,Tool,"Avgeriou, P.C. and Taibi, D. and Ampatzoglou, A. and Arcelli Fontana, F. and Besker, T. and Chatzigeorgiou, A. and Lenarduzzi, V. and Martini, A. and Moschou, A. and Pigazzini, I. and Saarimaki, N. and Sas, D.D. and De Toledo, S.S. and Tsintzira, A.A.",IEEE Software,"2,021.00",Article,10.1109/MS.2020.3024958,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85090030461&doi=10.1109%2fMS.2020.3024958&partnerID=40&md5=486dc99649a1884b26470a237a4efb19,No,Software Quality;  Source Code Analysis;  Technical Debt;  Tools
S180,Read,Rejected,[EC2] - The study shows a theoretical artifact or do not provide a link to the artifact's repository;,The study does not poit to any artifact,A scalable and efficient approach for compiling and analyzing commit history,"Background: Researchers oftentimes measure quality metrics only in the changed files when analyzing software evolution over commit-history. This approach is not suitable for compilation and using program analysis techniques that require byte-code. At the same time, compiling the whole software not only is costly but may also leave us with many uncompilable and unanalyzed revisions. Aims: We intend to demonstrate if analyzing changes in a module results in achieving a high compilation ratio and a better understanding of software quality evolution. Method: We conduct a large-scale multi-perspective empirical study on 37838 distinct revisions of the core module of 68 systems across Apache, Google, and Netflix to assess their compilability and identify when the software is uncompilable as a result of a developer's fault. We study the characteristics of uncompilable revisions and analyze compilable ones to understand the impact of developers on software quality. Results: We achieve high compilation ratios: 98.4% for Apache, 99.0% for Google, and 94.3% for Netflix. We identify 303 sequences of uncompile commits and create a model to predict uncompilability based on commit metadata with an F1-score of 0.89 and an AUC of 0.96. We identify statistical differences between the impact of affiliated and external developers of organizations. Conclusions: Focusing on a module results in a more complete and accurate software evolution analysis, reduces the cost and complexity, and facilitates manual inspection. © 2018 ACM.",TD Symptoms/Consequences,MSR Studies,"Behnamghader, P. and Meemeng, P. and Fostiropoulos, I. and Huang, D. and Srisopha, K. and Boehm, B.",International Symposium on Empirical Software Engineering and Measurement,2018,Conference Paper,10.1145/3239235.3239237,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85061480185&doi=10.1145%2f3239235.3239237&partnerID=40&md5=ea4516f8ea3cde7b24d759113020b21f,No,Mining software repositories;  Software compilability;  Software maintainbaility evolution;  Software technical debt
S337,Read,Rejected,[EC1] - The primary study is out of the scope of this work;,The study does not point to an artifact,Profiling developers through the lens of technical debt,"Context: Technical Debt needs to be managed to avoid disastrous consequences, and investigating developers' habits concerning technical debt management is invaluable information in software development. Objective: This study aims to characterize how developers manage technical debt based on the code smells they induce and the refactorings they apply. Method: We mined a publicly-available Technical Debt dataset for Git commit information, code smells, coding violations, and refactoring activities for each developer of a selected project. Results: By combining this information, we profile developers to recognize prolific coders, highlight activities that discriminate among developer roles (reviewer, lead, architect), and estimate coding maturity and technical debt tolerance. © 2020 IEEE Computer Society. All rights reserved.",TD Symptoms/Consequences,MSR Studies,"Codabux, Z. and Dutchyn, C.",International Symposium on Empirical Software Engineering and Measurement,2020,Conference Paper,10.1145/3382494.3422172,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85095818880&doi=10.1145%2f3382494.3422172&partnerID=40&md5=b2f8d5c5ab13490f066ba4e871983678,No,Code Smell;  Developer Characterization;  Mining Software Repositories;  Open Source Software;  Refactoring;  Technical Debt
S358,Read,Rejected,[EC2] - The study shows a theoretical artifact or do not provide a link to the artifact's repository;,The study does not point to an artifact,Behind the scenes: On the relationship between developer experience and refactoring,"Refactoring is widely recognized as one of the efficient techniques to manage technical debt and maintain a healthy software project through enforcing best design practices, or coping with design defects. Previous refactoring surveys have shown that code refactoring activities are mainly executed by developers who have sufficient knowledge of the system's design, and disposing of leadership roles in their development teams. However, these surveys were mainly limited to specific projects and companies. In this paper, we explore the generalizability of the previous results by analyzing 800 open-source projects. We mine their refactoring activities, and we identify their corresponding contributors. Then, we associate an experience score to each contributor in order to test various hypotheses related to whether developers with higher scores tend to (1) perform a higher number of refactoring operations, (2) exhibit different motivations behind their refactoring, and (3) better document their refactoring activity. We found that (1) although refactoring is not restricted to a subset of developers, those with higher contribution scores tend to perform more refactorings than others; (2) although there is no correlation between experience and motivation behind refactoring, top contributed developers are found to perform a wider variety of refactoring operations, regardless of their complexity; and (3) top contributed developer tend to document less their refactoring activity. Our qualitative analysis of three randomly sampled projects shows that the developers who are responsible for the majority of refactoring activities are typically in advanced positions in their development teams, demonstrating their extensive knowledge of the design of the systems they contribute to. © 2021 John Wiley & Sons, Ltd.",TD Symptoms/Consequences,MSR Studies,"Alomar, E.A. and Peruma, A. and Mkaouer, M.W. and Newman, C.D. and Ouni, A.",Journal of Software: Evolution and Process,2021,Article,10.1002/smr.2395,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85118239166&doi=10.1002%2fsmr.2395&partnerID=40&md5=9de955604d3db3070dcb8e03e1eeaa85,No,developer experience;  mining software repositories;  quality;  software maintenance and evolution;  software refactoring
S118,Read,Rejected,[EC2] - The study shows a theoretical artifact or do not provide a link to the artifact's repository;,"The study does not make available an artifact, but there are intresting things about issues that could be used later (Integrate a bot)",Detecting technical debt through issue trackers,"Managing technical debt effectively to prevent it from accumulating too quickly is of great concern to software stakeholders. To pay off technical debt regularly, software developers must be conscious of the existence of technical debt items. The first step is to make technical debt explicit; that is the identification of technical debt. Although there exist many kinds of static source code analysis tools to identify code-level technical debt, identifying non-code-level technical debt is very challenging and needs deep exploration. This paper proposed an approach to identifying non-code-level technical debt through issue tracking data sets using natural language processing and machine learning techniques and validated the feasibility and performance of this approach using an issue tracking data set recorded in Chinese from a commercial software project. We found that there are actually some common words that can be used as indicators of technical debt. Based on these key words, we achieved the precision of 0.72 and the recall of 0.81 for identifying technical debt items using machine learning techniques respectively. Copyright © 2017 for this paper by its authors.",Technical Debt,MSR Studies,"Dai, K. and Kruchten, P.",CEUR Workshop Proceedings,2017,Conference Paper,,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85040575660&partnerID=40&md5=9976450244a5a118017258d58fd9c23e,No,Identification;  Issue tracking data sets;  Machine learning;  Natural language processing;  technical debt
S189,Read,Rejected,[EC2] - The study shows a theoretical artifact or do not provide a link to the artifact's repository;,The study does not point to any artifact,Towards studying the evolution of technical debt in the Python projects from the apache software ecosystem,The topic of technical debt has gained significant attention from researchers in recent years since its management has significant impact of software development. Several studies that analyze technical debt evolution from different perspectives; however since most of these studies are done for Java very little is known about the evolution of technical debt in software ecosystems consisting of projects written in other languages. In this paper we run a study across nine Python open-source software projects belonging to the Apache Software Foundation to investigate the amount of technical debt that is paid back. To measure technical debt we use one of the standard tools in industry: SonarQube. We investigate the impact of using the 28 default rules of SonarQube for Python versus using an extended set of 208 rules to detect instances of technical debt. © 2018 CEUR-WS. All rights reserved.,Technical Debt,MSR Studies,"Tan, J. and Lungu, M. and Avgeriou, P.",CEUR Workshop Proceedings,2018,Conference Paper,,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85065757709&partnerID=40&md5=b1f61ab9d24c141ce25864f50e8c6468,No,
S20,Read,Rejected,[EC2a] - The study provides a broken link,The link that was provided in the study is broken,An exploratory study on self-admitted technical debt,"Throughout a software development life cycle, developers knowingly commit code that is either incomplete, requires rework, produces errors, or is a temporary workaround. Such incomplete or temporary workarounds are commonly referred to as 'technical debt'. Our experience indicates that self-admitted technical debt is common in software projects and may negatively impact software maintenance, however, to date very little is known about them. Therefore, in this paper, we use source-code comments in four large open source software projects-Eclipse, Chromium OS, Apache HTTP Server, and ArgoUML to identify self-admitted technical debt. Using the identified technical debt, we study 1) the amount of self-admitted technical debt found in these projects, 2) why this self-admitted technical debt was introduced into the software projects and 3) how likely is the self-admitted technical debt to be removed after their introduction. We find that the amount of self-admitted technical debt exists in 2.4% - 31% of the files. Furthermore, we find that developers with higher experience tend to introduce most of the self-admitted technical debt and that time pressures and complexity of the code do not correlate with the amount of self-admitted technical debt. Lastly, although self-admitted technical debt is meant to be addressed or removed in the future, only between 26.3% - 63.5% of self-admitted technical debt gets removed from projects after introduction. © 2014 IEEE.",Technical Debt,MSR Studies,"Potdar, A. and Shihab, E.","Proceedings - 30th International Conference on Software Maintenance and Evolution, ICSME 2014",2014,Conference Paper,10.1109/ICSME.2014.31,https://www.scopus.com/inward/record.uri?eid=2-s2.0-84931072943&doi=10.1109%2fICSME.2014.31&partnerID=40&md5=02e97501ed8c099b236854d80bc9c72c,No,Software comments;  Technical debt
S257,Read,Rejected,[EC1] - The primary study is out of the scope of this work;,Check to extract the tools (Snowballing),An Analysis of Automated Technical Debt Measurement,"Background: Measuring and understanding Technical Debt (TD) is quite complex since there are a number of different definitions and techniques that have been proposed in the last few years and it is not clear which ones should be used in which conditions. The approaches proposed are almost never based on the existing ones and their validation is often performed in a very limited number of projects. For this reasons, practitioners are confused and find difficult to apply such approaches in their projects. Goals: This paper investigates the available techniques for evaluating TD using automated tools aiming at helping practitioners and researcher in understanding the available options and apply them correctly. Method: The study has been performed as a Systematic Literature Review (SLR) applied to 835 studies obtained from the three largest digital libraries and databases. Results: After applying all filtering stages, 38 papers out of 835 have been selected and analyzed in depth. Almost all of them propose novel approaches to measure TD using different criteria and they do not extend or validate existing approaches. Conclusions: The area is not mature and it lacks independent evaluations of the models proposed. Authors focus on proposing new approaches and no consolidation can be identified. Moreover, almost all the approaches proposed are automated only partially and through prototype tools designed just to support the studies analyzed in the paper in which the approach is proposed and rarely maintained. These facts makes difficult the application of such methods by practitioners. © Springer Nature Switzerland AG 2020.",Technical Debt,Literature Review,"Khomyakov, I. and Makhmutov, Z. and Mirgalimova, R. and Sillitti, A.",Lecture Notes in Business Information Processing,2020,Conference Paper,10.1007/978-3-030-40783-4_12,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85081550029&doi=10.1007%2f978-3-030-40783-4_12&partnerID=40&md5=cb94fa62fd9b58db70b77925477cb13d,No,Literature review;  Measurement;  Technical debt;  Tools
S34,Read,Rejected,[EC2] - The study shows a theoretical artifact or do not provide a link to the artifact's repository;,Check to extract the tools (Snowballing),Investigating the Link between User Stories and Documentation Debt on Software Projects,"Technical debt is a metaphor that describes the effect of immature artefacts in software development. One of its types is documentation debt, which can be identified by locating missing, inadequate or incomplete artefacts in software projects. Nowadays, we can observe more organizations using agile methods to support their activities. In particular, the use of user stories reduces the focus on requirement specification tasks and, as a consequence, creates difficulties that need to be overcame by the development team. In order to investigate these difficulties and assess whether they create a favourable scenario for incurring documentation debt, this paper presents the results of a literature review and an exploratory study. The results from both studies allowed us to identify a list of causes that can lead the development team to incur documentation debt when working with agile requirements. This is an important step in order to manage the technical debt from a preventive perspective. © 2015 IEEE.",Technical Debt,Literature Review,"Soares, H.F. and Alves, N.S.R. and Mendes, T.S. and Mendonca, M. and Spinola, R.O.","Proceedings - 12th International Conference on Information Technology: New Generations, ITNG 2015",2015,Conference Paper,10.1109/ITNG.2015.68,https://www.scopus.com/inward/record.uri?eid=2-s2.0-84936806101&doi=10.1109%2fITNG.2015.68&partnerID=40&md5=48450a4ce8418ed0062c52635c77d04f,No,Agile Requirements;  Documentation Debt;  Exploratory Study;  Literature Review;  Technical Debt;  User Stories
S341,Read,Rejected,[EC2] - The study shows a theoretical artifact or do not provide a link to the artifact's repository;,Check to extract the tools (Snowballing),Characterizing Technical Debt and Antipatterns in AI-Based Systems: A Systematic Mapping Study,"Background: With the rising popularity of Artificial Intelligence (AI), there is a growing need to build large and complex AI-based systems in a cost-effective and manageable way. Like with traditional software, Technical Debt (TD) will emerge naturally over time in these systems, therefore leading to challenges and risks if not managed appropriately. The influence of data science and the stochastic nature of AI-based systems may also lead to new types of TD or antipatterns, which are not yet fully understood by researchers and practitioners. Objective: The goal of our study is to provide a clear overview and characterization of the types of TD (both established and new ones) that appear in AI-based systems, as well as the antipatterns and related solutions that have been proposed. Method: Following the process of a systematic mapping study, 21 primary studies are identified and analyzed. Results: Our results show that (i) established TD types, variations of them, and four new TD types (data, model, configuration, and ethics debt) are present in AI-based systems, (ii) 72 antipatterns are discussed in the literature, the majority related to data and model deficiencies, and (iii) 46 solutions have been proposed, either to address specific TD types, antipatterns, or TD in general. Conclusions: Our results can support AI professionals with reasoning about and communicating aspects of TD present in their systems. Additionally, they can serve as a foundation for future research to further our understanding of TD in AI-based systems. © 2021 IEEE.",Technical Debt,Literature Review,"Bogner, J. and Verdecchia, R. and Gerostathopoulos, I.","Proceedings - 2021 IEEE/ACM International Conference on Technical Debt, TechDebt 2021",2021,Conference Paper,10.1109/TechDebt52882.2021.00016,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85114832074&doi=10.1109%2fTechDebt52882.2021.00016&partnerID=40&md5=d2a18c8a42af690521e2a1a5b47df62c,No,Antipatterns;  Artificial Intelligence;  Machine Learning;  Systematic Mapping Study;  Technical Debt
S342,Read,Rejected,[EC1] - The primary study is out of the scope of this work;,Check to extract the tools (Snowballing),A systematic mapping study on architectural smells detection,"The recognition of the need for high-quality software architecture is evident from the increasing trend in investigating architectural smells. Detection of architectural smells is paramount because they can seep through to design and implementation stages if left unidentified. Many architectural smells detection techniques and tools are proposed in the literature. The diversity in the detection techniques and tools suggests the need for their collective analysis to identify interesting aspects for practice and open research areas. To fulfill this, in this paper, we unify the knowledge about the detection of architectural smells through a systematic mapping study. We report on the existing detection techniques and tools for architectural smells to identify their limitations. We find there has been limited investigation of some architectural smells (e.g., micro-service smells); many architectural smells are not detected by tools yet; and there are limited empirical validations of techniques and tools. Based on our findings, we suggest several open research problems, including the need to (1) investigate undetected architectural smells (e.g., Java package smells), (2) improve the coverage of architectural smell detection across architecture styles (e.g., service-oriented and cloud), and (3) perform empirical validations of techniques and tools in industry across different languages and project domains. © 2020 Elsevier Inc.",Technical Debt,Literature Review,"Mumtaz, H. and Singh, P. and Blincoe, K.",Journal of Systems and Software,2021,Article,10.1016/j.jss.2020.110885,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85098698807&doi=10.1016%2fj.jss.2020.110885&partnerID=40&md5=79bcce91325598c5ba71753a900109f3,No,Antipatterns;  Architectural debt;  Architectural smells;  Smell detection techniques;  Systematic mapping study
S344,Read,Rejected,[EC2] - The study shows a theoretical artifact or do not provide a link to the artifact's repository;,Check to extract the tools (Snowballing),"A systematic literature review on Technical Debt prioritization: Strategies, processes, factors, and tools","Background: Software companies need to manage and refactor Technical Debt issues. Therefore, it is necessary to understand if and when refactoring of Technical Debt should be prioritized with respect to developing features or fixing bugs. Objective: The goal of this study is to investigate the existing body of knowledge in software engineering to understand what Technical Debt prioritization approaches have been proposed in research and industry. Method: We conducted a Systematic Literature Review of 557 unique papers published until 2020, following a consolidated methodology applied in software engineering. We included 44 primary studies. Results: Different approaches have been proposed for Technical Debt prioritization, all having different goals and proposing optimization regarding different criteria. The proposed measures capture only a small part of the plethora of factors used to prioritize Technical Debt qualitatively in practice. We present an impact map of such factors. However, there is a lack of empirical and validated set of tools. Conclusion: We observed that Technical Debt prioritization research is preliminary and there is no consensus on what the important factors are and how to measure them. Consequently, we cannot consider current research conclusive. In this paper, we therefore outline different directions for necessary future investigations. © 2020 Elsevier Inc.",Technical Debt,Literature Review,"Lenarduzzi, V. and Besker, T. and Taibi, D. and Martini, A. and Arcelli Fontana, F.",Journal of Systems and Software,2021,Article,10.1016/j.jss.2020.110827,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85092459560&doi=10.1016%2fj.jss.2020.110827&partnerID=40&md5=a59e030ac2d0a88e9c0468720ad2ecec,No,Systematic Literature Review;  Technical Debt;  Technical Debt prioritization
S165,Read,Rejected,[EC1] - The primary study is out of the scope of this work;,Check to extract the tools (Snowballing),Architectural technical debt identification: The research landscape,"Architectural Technical Debt (ATD) regards sub-optimal design decisions that bring short-term benefits to the cost of long-term gradual deterioration of the quality of the architecture of a software system. The identification of ATD strongly influences the technical and economic sustainability of software systems and is attracting growing interest in the scientific community. During the years several approaches for ATD identification have been conceived, each of them addressing ATD from different perspectives and with heterogeneous characteristics. In this paper we apply the systematic mapping study methodology for identifying, classifying, and evaluating the state of the art on ATD identification from the following three perspectives: publication trends, characteristics, and potential for industrial adoption. Specifically, starting from a set of 509 potentially relevant studies, we systematically selected 47 primary studies and analyzed them according to a rigorously-defined classification framework. The analysis of the obtained results supports both researchers and practitioners by providing (i) an assessment of current research trends and gaps in ATD identification, (ii) a solid foundation for understanding existing (and future) research on ATD identification, and (iii) a rigorous evaluation of its potential for industrial adoption. © 2018 ACM.",Technical Debt,Literature Review,"Verdecchia, R. and Malavolta, I. and Lago, P.",Proceedings - International Conference on Software Engineering,2018,Conference Paper,10.1145/3194164.3194176,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85051500046&doi=10.1145%2f3194164.3194176&partnerID=40&md5=9e20e27f09bb693e95d44291bd882d12,No,software architecture;  systematic mapping study;  technical debt
S33,Read,Rejected,[EC1] - The primary study is out of the scope of this work;,Check to extract the tools (Snowballing),Preemptive management of model driven technical debt for improving software quality,"Technical debt has been the subject of numerous studies over the last few years. To date, most of the research has concentrated on management (detection, quantification, and decision making) approaches -most performed at code and implementation levels through various static analysis tools. However, if practitioners are to adopt model driven techniques, then the management of technical debt also requires that we address this problem during the specification and architectural phases. This position paper discusses several questions that need to be addressed in order to improve the quality of software architecture by exploring the management of technical debt during modeling, and suggests various lines of research that are worthwhile subjects for further investigation. Copyright © 2015 ACM.",Technical Debt,Literature Review,"Izurieta, C. and Rojas, G. and Griffith, I.","QoSA 2015 - Proceedings of the 11th International ACM SIGSOFT Conference on Quality of Software Architectures, Part of CompArch 2015",2015,Conference Paper,10.1145/2737182.2737193,https://www.scopus.com/inward/record.uri?eid=2-s2.0-84963574332&doi=10.1145%2f2737182.2737193&partnerID=40&md5=66e2f1b705d7fee8b468238d4a65ed7d,No,Model and architectural quality;  Model driven development;  Software maintenance;  Software quality;  Technical debt
S403,Read,Accepted,[IC1] - The primary study presents or points to a software artifact that automates a task within at least one TD management activity.,,DebtHunter: A machine learning-based approach for detecting self-admitted technical debt,"Due to limited time, budget or resources, a team is prone to introduce code that does not follow the best software development practices. This code that introduces instability in the software projects is known as Technical Debt (TD). Often, TD intentionally manifests in source code, which is known as Self-Admitted Technical Debt (SATD). This paper presents DebtHunter, a natural language processing (NLP)- and machine learning (ML)- based approach for identifying and classifying SATD in source code comments. The proposed classification approach combines two classification phases for differentiating between the multiple debt types. Evaluations over 10 open source systems, containing more than 259k comments, showed that the approach was able to improve the performance of others in the literature. The presented approach is supported by a tool that can help developers to effectively manage SATD. The tool complements the analysis over Java source code by allowing developers to also examine the associated issue tracker. DebtHunter can be used in a continuous evolution environment to monitor the development process and make developers aware of how and where SATD is introduced, thus helping them to manage and resolve it. © 2021 ACM.",Technical Debt,Tool,"Sala, I. and Tommasel, A. and Arcelli Fontana, F.",ACM International Conference Proceeding Series,"2,021.00",Conference Paper,10.1145/3463274.3464455,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85108905885&doi=10.1145%2f3463274.3464455&partnerID=40&md5=72d95961bb20e726db887900f1cb3f6d,No,Machine learning;  Natural language processing;  Self-admitted technical debt;  Technical debt
S407,Read,Accepted,[IC1] - The primary study presents or points to a software artifact that automates a task within at least one TD management activity.,,Technical Debt predictive model through Temporal Convolutional Network,"Technical debt is a metaphor that refers to all the consequences of poorly written code and trade-offs in development. Early technical debt diagnosis is important for software developers because it allows planning for software maintenance and improvement activities, such as refactoring, to prevent system degradation. Several studies have been conducted in the literature on the identification of the technical debt and its consequences, thanks to useful tools for identifying the problem within the source code. On the other hand, this work aims to explore a deep learning approach to predict the rise of technical debt in software code by leveraging the knowledge of changing quality metrics. For validation of the approach, a large dataset was built, related to four known Java software projects, with the collection of numerous class-level code quality metrics. The results obtained show the effectiveness of the proposed approach in predicting the development of Technical Debt within the source code. We obtained an F1 score of 0.99 for two of the chosen software systems and greater than 0.91 for the remaining two. © 2021 IEEE.",Technical Debt,Tool,"Aversano, L. and Bernardi, M.L. and Cimitile, M. and Iammarino, M.",Proceedings of the International Joint Conference on Neural Networks,"2,021.00",Conference Paper,10.1109/IJCNN52387.2021.9534423,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85116420916&doi=10.1109%2fIJCNN52387.2021.9534423&partnerID=40&md5=7ca186b49cb61cfb0ead5d3f5c4bfbb5,No,Deep Learning;  Prediction;  Technical Debt
S414,Read,Accepted,[IC1] - The primary study presents or points to a software artifact that automates a task within at least one TD management activity.,,Architectural technical debt of multiagent systems development platforms,"Technical debt is candidate to be the next buzzword in software engineering, and the number of studies evaluating the technical debt of software projects is increasing. A particular and dangerous type of debt is the architectural debt, i.e., the consequences of sub-optimal design decisions. Currently, there are no studies about the evaluation of architectural debt in MultiAgent Systems (MAS) and platforms. Hence, in this paper we propose the analysis of four well-known MAS development platforms, with the aim of evaluating their architectural debt and open the discussion in this field. We exploit a tool, named Arcan, developed for architectural smell detection and for the computation of an architectural debt index. The results show that MAS development platforms are subjected to architectural debt, and in particular to the presence of Cyclic Dependency smells. However, there is evidence that the minimum amount of debt is reached when developers report “bug fixes” and “Improvements”. © 2021 CEUR-WS. All rights reserved.",Technical Debt,Tool,"Pigazzini, I. and Briola, D. and Fontana, F.A.",CEUR Workshop Proceedings,"2,021.00",Conference Paper,,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85116898427&partnerID=40&md5=040f1845b6770ddecad9feac2bc6ea4b,No,Architectural debt;  Architectural smells;  Multiagent system platforms;  Trend analysis
S188,Read,Rejected,[EC1] - The primary study is out of the scope of this work;,"Even the study points to Understand and NDepend, the tools are cited and no explanation of its use is provided",Architectural Technical Debt Identification: Moving Forward,"Architectural technical debt is a metaphor used to describe sub-optimal architectural design and implementation choices that bring short-term benefits to the cost of the long-term gradual deterioration of the quality of software. Architectural technical debt is an active field of research. Nevertheless, how to accurately identify architectural technical debt is still an open question. Our research aims to fill this gap. We strive to: (i) consolidate the existing knowledge of architectural technical debt identification in practice, (ii) conceive novel identification approaches built upon the existing state of the art techniques and industrial needs, and (iii) provide empirical evidence of architectural technical debt phenomena and assess the viability of the conceived approaches. © 2018 IEEE.",Technical Debt,Case Study,"Verdecchia, R.","Proceedings - 2018 IEEE 15th International Conference on Software Architecture Companion, ICSA-C 2018",2018,Conference Paper,10.1109/ICSA-C.2018.00018,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85052569196&doi=10.1109%2fICSA-C.2018.00018&partnerID=40&md5=ddd0b9625abb2acd27df411b07506f74,No,Software Architecture;  Software Maintenance;  Technical Debt
S351,Read,Accepted,[IC1] - The primary study presents or points to a software artifact that automates a task within at least one TD management activity.,,Metrics to Measure Code Complexity Based on Software Design: Practical Evaluation,"Software complexity is an indicator to the quality of software. It shows that a software or a component of software has a design or implementation that is difficult to understand, modify and maintain. Many complexity metrics have been developed by researchers to identify and measure the degree of complexity. Unfortunately, Current complexity metrics are based on the number of model elements only, regardless of the complexity of those elements themselves. In this paper, we propose new code complexity metrics that are derived from its design. This approach ensures that the derived metrics are uniquely tailored for the software under development, and the derived metrics are unique for each software module. In this study, we aim to attempt an empirical evaluation study in order to have a clear understanding of the proposed complexity metrics. We investigated whether there is a correlation between the proposed UML Class Diagram complexity and the associated code, specially code size, code smells, and technical debt. The result shows that there is a high correlation between the design driven code complexity metrics and the associated code. © 2021, The Author(s), under exclusive license to Springer Nature Switzerland AG.",TD Symptoms/Consequences,Theoretical Artifact,"Masmali, O. and Badreddin, O. and khandoker, R.",Advances in Intelligent Systems and Computing,"2,021.00",Conference Paper,10.1007/978-3-030-73103-8_9,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85105952800&doi=10.1007%2f978-3-030-73103-8_9&partnerID=40&md5=cf09c02673d92fba921d1d138ff9e0b9,No,Code quality;  Code smell;  Complexity;  Large class;  Maintainability;  Technical debt
S369,Read,Accepted,[IC1] - The primary study presents or points to a software artifact that automates a task within at least one TD management activity.,,The Need for Holistic Technical Debt Management across the Value Stream: Lessons Learnt and Open Challenges,"The long lifetime and the evolving nature of industrial products make them subject to technical debt at different levels. Despite multiple years of research on technical debt management, our industrial experience shows that introducing systematic technical debt management in a large-scale company is very challenging. To identify the challenges, we provide a conceptual framework for holistic debt management across the product development value stream, which takes multiple categories of debt and their interplays into account. We use this framework to identify multiple challenges that are still open to be explored by the research community. Due to the practical nature of technical debt management, we believe this paper can guide the research community on the needs of industry for the effective application of technical debt management in practice. © 2021 IEEE.",Technical Debt,Theoretical Artifact,"Malakuti, S. and Heuschkel, J.","Proceedings - 2021 IEEE/ACM International Conference on Technical Debt, TechDebt 2021","2,021.00",Conference Paper,10.1109/TechDebt52882.2021.00021,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85114777544&doi=10.1109%2fTechDebt52882.2021.00021&partnerID=40&md5=5b6af045aa087d16f8793275dfa54cb1,No,agile process;  multiobjective improvement;  process maturity;  technical debt management
S402,Read,Accepted,[IC1] - The primary study presents or points to a software artifact that automates a task within at least one TD management activity.,,Building and evaluating a theory of architectural technical debt in software-intensive systems,"Architectural technical debt in software-intensive systems is a metaphor used to describe the “big” design decisions (e.g., choices regarding structure, frameworks, technologies, languages, etc.) that, while being suitable or even optimal when made, significantly hinder progress in the future. While other types of debt, such as code-level technical debt, can be readily detected by static analyzers, and often be refactored with minimal or only incremental efforts, architectural debt is hard to be identified, of wide-ranging remediation cost, daunting, and often avoided. In this study, we aim at developing a better understanding of how software development organizations conceptualize architectural debt, and how they deal with it. In order to do so, in this investigation we apply a mixed empirical method, constituted by a grounded theory study followed by focus groups. With the grounded theory method we construct a theory on architectural technical debt by eliciting qualitative data from software architects and senior technical staff from a wide range of heterogeneous software development organizations. We applied the focus group method to evaluate the emerging theory and refine it according to the new data collected. The result of the study, i.e., a theory emerging from the gathered data, constitutes an encompassing conceptual model of architectural technical debt, identifying and relating concepts such as its symptoms, causes, consequences, management strategies, and communication problems. From the conducted focus groups, we assessed that the theory adheres to the four evaluation criteria of classic grounded theory, i.e., the theory fits its underlying data, is able to work, has relevance, and is modifiable as new data appears. By grounding the findings in empirical evidence, the theory provides researchers and practitioners with novel knowledge on the crucial factors of architectural technical debt experienced in industrial contexts. © 2021 The Author(s)",Technical Debt,Theoretical Artifact,"Verdecchia, R. and Kruchten, P. and Lago, P. and Malavolta, I.",Journal of Systems and Software,"2,021.00",Article,10.1016/j.jss.2021.110925,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85101964849&doi=10.1016%2fj.jss.2021.110925&partnerID=40&md5=56c68cdb45c3ab54d2b00fda88ab9e62,No,Focus group;  Grounded theory;  Software architecture;  Software engineering;  Software evolution;  Technical debt
S368,Read,Accepted,[IC1] - The primary study presents or points to a software artifact that automates a task within at least one TD management activity.,,Assessing Smart Contracts Security Technical Debts,"Smart contracts are self-enforcing agreements that are employed to exchange assets without the approval of trusted third parties. This feature has encouraged various sectors to make use of smart contracts when transacting. Experience shows that many deployed contracts are vulnerable to exploitation due to their poor design, which allows attackers to steal valuable assets from the involved parties. Therefore, an assessment approach that allows developers to recognise the consequences of deploying vulnerable contracts is needed. In this paper, we propose a debt-aware approach for assessing security design vulnerabilities in smart contracts. Our assessment approach involves two main steps: (i) identification of design vulnerabilities using security analysis techniques and (ii) an estimation of the ramifications of the identified vulnerabilities leveraging the technical debt metaphor, its principal and interest. We use examples of vulnerable contracts to demonstrate the applicability of our approach. The results show that our assessment approach increases the visibility of security design issues. It also allows developers to concentrate on resolving smart contract vulnerabilities through technical debt impact analysis and prioritisation. Developers can use our approach to inform the design of more secure contracts and for reducing unintentional debts caused by a lack of awareness of security issues. © 2021 IEEE.",Technical Debt,Theoretical Artifact,"Ahmadjee, S. and Mera-Gomez, C. and Bahsoon, R.","Proceedings - 2021 IEEE/ACM International Conference on Technical Debt, TechDebt 2021","2,021.00",Conference Paper,10.1109/TechDebt52882.2021.00010,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85114796874&doi=10.1109%2fTechDebt52882.2021.00010&partnerID=40&md5=f47f96e207b85aa3c825689b573bd70e,No,security;  smart contract;  technical debt
S413,Read,Accepted,[IC1] - The primary study presents or points to a software artifact that automates a task within at least one TD management activity.,,Self-admitted technical debt practices: a comparison between industry and open-source,"Self-admitted technical debt (SATD) consists of annotations, left by developers as comments in the source code or elsewhere, as a reminder about pieces of software manifesting technical debt (TD), i.e., “not being ready yet”. While previous studies have investigated SATD management and its relationship with software quality, there is little understanding of the extent and circumstances to which developers admit TD. This paper reports the results of a study in which we asked developers from industry and open-source about their practices in annotating source code and other artifacts for self-admitting TD. The study consists of two phases. First, we conducted 10 interviews to gather a first understanding of the phenomenon and to prepare a survey questionnaire. Then, we surveyed 52 industrial developers as well as 49 contributors to open-source projects. Results of the study show how the TD annotation practices, as well as the typical content of SATD comments, are very similar between open-source and industry. At the same time, our results highlight how, while open-source code is spread of comments admitting the need for improvements, SATD in industry may be dictated by organizational guidelines but, at the same time, implicitly discouraged by the fear of admitting responsibilities. Results also highlight the need for tools helping developers to achieve a better TD awareness. © 2021, The Author(s), under exclusive licence to Springer Science+Business Media, LLC, part of Springer Nature.",Technical Debt,Survey,"Zampetti, F. and Fucci, G. and Serebrenik, A. and Di Penta, M.",Empirical Software Engineering,"2,021.00",Article,10.1007/s10664-021-10031-3,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85115753395&doi=10.1007%2fs10664-021-10031-3&partnerID=40&md5=8f5452f0b97e1e6b6713650ecbe1a2d5,No,Empirical study;  Self-admitted technical debt;  Software quality;  Technical debt
S409,Read,Accepted,[IC1] - The primary study presents or points to a software artifact that automates a task within at least one TD management activity.,,An empirical study on the co-occurrence between refactoring actions and Self-Admitted Technical Debt removal,"Technical Debt (TD) concerns the lack of an adequate solution in a software project, from its design to the source code. Its admittance through source code comments, issues, or commit messages is referred to as Self-Admitted Technical Debt (SATD). Previous research has studied SATD from different perspectives, including its distribution, impact on software quality, and removal. In this paper, we investigate the relationship between refactoring and SATD removal. By leveraging a dataset of SATD and their removals in four open-source projects and by using an automated refactoring detection tool, we study the co-occurrence of refactoring and SATD removals. Results of the study indicate that refactoring is more likely to co-occur with SATD removals than with other commits, however, in most cases, they belong to different quality improvement activities performed at the same time. Moreover, if looking closely at refactoring actions co-occurring with SATD removal in the same code entities, a relationship between these activities can be found. Finally, we found how both source code quality metrics and SATD removals play a statistically significant role in the likelihood that the commit applies a refactoring action. © 2021 Elsevier Inc.",Technical Debt,MSR Studies,"Iammarino, M. and Zampetti, F. and Aversano, L. and Di Penta, M.",Journal of Systems and Software,"2,021.00",Article,10.1016/j.jss.2021.110976,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85104701235&doi=10.1016%2fj.jss.2021.110976&partnerID=40&md5=465d320d5df377851f8a956da06c8c8f,No,Self-Admitted Technical Debt;  Software quality;  Software refactoring
S354,Read,Accepted,[IC1] - The primary study presents or points to a software artifact that automates a task within at least one TD management activity.,,QScored: A large dataset of code smells and quality metrics,"Code quality aspects such as code smells and code quality metrics are widely used in exploratory and empirical software engineering research. In such studies, researchers spend a substantial amount of time and effort to not only select the appropriate subject systems but also to analyze them to collect the required code quality information. In this paper, we present QScored dataset; the dataset contains code quality information of more than 86 thousand C# and Java GitHub repositories containing more than 1.1 billion lines of code. The code quality information contains seven kinds of detected architecture smells, 20 kinds of design smells, eleven kinds of implementation smells, and 27 commonly used code quality metrics computed at project, package, class, and method levels. Availability of the dataset will facilitate empirical studies involving code quality aspects by making the information readily available for a large number of active GitHub repositories. © 2021 IEEE.",Smells,MSR Studies,"Sharma, T. and Kessentini, M.","Proceedings - 2021 IEEE/ACM 18th International Conference on Mining Software Repositories, MSR 2021","2,021.00",Conference Paper,10.1109/MSR52588.2021.00080,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85113586145&doi=10.1109%2fMSR52588.2021.00080&partnerID=40&md5=f73f0ff63831c66174dda79436bafade,No,Code quality;  Code smells;  Maintainability;  Quality metrics;  Technical debt
S242,Read,Rejected,[EC1] - The primary study is out of the scope of this work;,"The paper just cites the tools, and does not provide any information about that",But do commit messages matter? An empirical association analysis with technical debt,"An empirical analysis is conducted to investigate the association of the content of commit messages and technical debt. The analysis is based on 33 open-source Apache JAVA projects. Structural Topic Modelling, a recently developed text mining technique is employed for sophisticated analysis. The result shows that the certain content of commit messages such as empty messages are potentially associated with Technical Debt. Copyright © 2019 for this paper by its authors.",Technical Debt,MSR Studies,"Lu, C.",CEUR Workshop Proceedings,2019,Conference Paper,,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85077510692&partnerID=40&md5=8b183e2de97b212297781855ad7c7fcd,No,Commit messages;  Technical debt;  Text mining
S355,Read,Accepted,[IC1] - The primary study presents or points to a software artifact that automates a task within at least one TD management activity.,,Worst Smells and Their Worst Reasons,"Code bad smells are symptoms of poor design and implementation. There are several well-known smell types, such as large classes (aka God classes), code clones, etc. and they have been shown to lead to technical debt and hence to decrease code maintainability. Quality gates are a recent technology that prevents the automatic acceptance of push requests of code commits that have been identified as containing certain smells. However, it is a challenging activity to decide which smells should be included in the quality gate, as developers may choose to optimize short term benefits like time to market over long term benefits like maintainability. But some smells appear to provide no benefit to developers whatsoever and hence such smells should always be avoided. The aims of this paper are: 1) to identify ""worst smells"", i.e., bad smells that never have a good reason to exist, 2) to determine the frequency, change-proneness, and severity associated with worst smells, and 3) to identify the ""worst reasons"", i.e., the reasons for introducing these worst smells in the first place. To achieve these aims we ran a survey with 71 developers. We learned that 80 out of 314 catalogued code smells are ""worst""; that is, developers agreed that these 80 smells should never exist in any code base. We then checked the frequency and change-proneness of these worst smells on 27 large Apache open- source projects. Our results show insignificant differences, in both frequency and change proneness, between worst and non-worst smells. That is to say, these smells are just as damaging as other smells, but there is never any justifiable reason to introduce them. Finally, in follow-up phone interviews with five developers we confirmed that these smells are indeed worst, and the interviewees proposed seven reasons for why they may be introduced in the first place. By explicitly identifying these seven reasons, project stakeholders can, through quality gates or reviews, ensure that such smells are never accepted in a code base, thus improving quality without compromising other goals such as agility or time to market. © 2021 IEEE.",Smells,MSR Studies,"Falessi, D. and Kazman, R.","Proceedings - 2021 IEEE/ACM International Conference on Technical Debt, TechDebt 2021","2,021.00",Conference Paper,10.1109/TechDebt52882.2021.00014,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85114792669&doi=10.1109%2fTechDebt52882.2021.00014&partnerID=40&md5=5d6312457eff4211584f227134a2a9dc,No,code smells;  reasons for code smells;  Technical debt
S349,Read,Accepted,[IC1] - The primary study presents or points to a software artifact that automates a task within at least one TD management activity.,,One Step Further: Investigating Problematic Files of Architecture Anti-patterns,"Architecture anti-patterns violate design principles and negatively impact software internal quality. Both academia and industry have designed methods and tools to detect anti-patterns. However, these tools tend to report a large number of defects, hindering developers from prioritizing true debts. In this work, we take one step further to explore the most problematic files (we define them as root files) in the architecture anti-patterns, which are potential causes leading to the difficulty of software maintenance. Using 45 Python projects as subjects, we investigate root files' maintainability, evolution (i.e., birth, living, and death), and their interactions in different architecture anti-patterns. Our results reveal that, compared with other files in anti-patterns, these root files take only a small proportion but incur heavy maintenance costs. Our study of their evolution and interactions can help developers identify potential causes of anti-patterns. We believe our findings will benefit the practice of design problem fixing. © 2021 IEEE.",TD Symptoms/Consequences,MSR Studies,"Liu, J. and Jin, W. and Feng, Q. and Zhang, X. and Dai, Y.","Proceedings - International Symposium on Software Reliability Engineering, ISSRE","2,021.00",Conference Paper,10.1109/ISSRE52982.2021.00060,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85126395572&doi=10.1109%2fISSRE52982.2021.00060&partnerID=40&md5=5661c4850ef1cd8e40447551b32def6a,No,Anti-patterns;  Architecture maintainability
S350,Read,Accepted,[IC1] - The primary study presents or points to a software artifact that automates a task within at least one TD management activity.,,Two different facets of architectural smells criticality: An empirical study,"Architectural smells (AS) represent symptoms of problems at architectural level that have an impact on architectural debt. It is important to identify among them the most critical ones, so that developers can prioritize them for their removal. In order to evaluate the criticality of AS, in this paper we consider two facets: the PageRank metric, to assess the centrality of a smell in a project, and Severity, a metric to estimate the cost-solving of smells. We have proposed these two metrics in a previous work and here we perform an empirical analysis of the evolution and correlation of these metrics in the version history of 10 projects (at least 22 versions each, 264 projects in total). The analysis of the evolution is useful in order to identify which architectural smells types tend to become more critical. The analysis of the correlation is useful to study whether the criticality of a smell has an influence on how much it costs to remove it, and vice-versa. © 2021 Copyright for this paper by its authors. Use permitted under Creative Commons License Attribution 4.0 International (CC BY 4.0).",TD Symptoms/Consequences,MSR Studies,"Pigazzini, I. and Foppiani, D. and Fontana, F.A.",CEUR Workshop Proceedings,"2,021.00",Conference Paper,,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85117851973&partnerID=40&md5=432dfcd59472a3cd505d933cd50bb82a,No,Architectural Debt;  Architectural Smells;  Architectural Smells criticality;  Architectural Smells evolution;  Empirical study
S312,Read,Rejected,[EC2] - The study shows a theoretical artifact or do not provide a link to the artifact's repository;,The repository provided by the authors presents just a dataset. Most of the work in this study was made manually,Beyond the Code: Mining Self-Admitted Technical Debt in Issue Tracker Systems,"Self-admitted technical debt (SATD) is a particular case of Technical Debt (TD) where developers explicitly acknowledge their sub-optimal implementation decisions. Previous studies mine SATD by searching for specific TD-related terms in source code comments. By contrast, in this paper we argue that developers can admit technical debt by other means, e.g., by creating issues in tracking systems and labelling them as referring to TD. We refer to this type of SATD as issue-based SATD or just SATD-I. We study a sample of 286 SATD-I instances collected from five open source projects, including Microsoft Visual Studio and GitLab Community Edition. We show that only 29% of the studied SATD-I instances can be tracked to source code comments. We also show that SATD-I issues take more time to be closed, compared to other issues, although they are not more complex in terms of code churn. Besides, in 45% of the studied issues TD was introduced to ship earlier, and in almost 60% it refers to DESIGN flaws. Finally, we report that most developers pay SATD-I to reduce its costs or interests (66%). Our findings suggest that there is space for designing novel tools to support technical debt management, particularly tools that encourage developers to create and label issues containing TD concerns. © 2020 ACM.",Technical Debt,MSR Studies,"Xavier, L. and Ferreira, F. and Brito, R. and Valente, M.T.","Proceedings - 2020 IEEE/ACM 17th International Conference on Mining Software Repositories, MSR 2020",2020,Conference Paper,10.1145/3379597.3387459,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85093696448&doi=10.1145%2f3379597.3387459&partnerID=40&md5=d83a2d14a56f14fc61a614034a5d039b,No,
S375,Read,Accepted,[IC1] - The primary study presents or points to a software artifact that automates a task within at least one TD management activity.,,Refactorings and Technical Debt in Docker Projects: An Empirical Study,"Software containers, such as Docker, are recently considered as the mainstream technology of providing reusable software artifacts. Developers can easily build and deploy their applications based on the large number of reusable Docker images that are publicly available. Thus, a current popular trend in industry is to move towards the containerization of their applications. However, container-based projects compromise different components including the Docker and Docker-compose files, and several other dependencies to the source code combining different containers and facilitating the interactions with them. Similar to any other complex systems, container-based projects are prone to various quality and technical debt issues related to different artifacts: Docker and Docker-compose files, and regular source code ones. Unfortunately, there is a gap of knowledge in how container-based projects actually evolve and are maintained.In this paper, we address the above gap by studying refactorings, i.e., structural changes while preserving the behavior, applied in open-source Docker projects, and the technical debt issues they alleviate. We analyzed 68 projects, consisting of 19, 5 MLOC, along with 193 manually examined commits. The results indicate that developers refactor these Docker projects for a variety of reasons that are specific to the configuration, combination and execution of containers, leading to several new technical debt categories and refactoring types compared to existing refactoring domains. For instance, refactorings for reducing the image size of Dockerfiles, improving the extensibility of Docker-compose files, and regular source code refactorings are mainly associated with the evolution of Docker and Docker-compose files. We also introduced 24 new Docker-specific refactorings and technical debt categories, respectively, and defined different best practices. The implications of this study will assist practitioners, tool builders, and educators in improving the quality of Docker projects. © 2021 IEEE.",Technical Debt,MSR Studies,"Ksontini, E. and Kessentini, M. and Ferreira, T.D.N. and Hassan, F.","Proceedings - 2021 36th IEEE/ACM International Conference on Automated Software Engineering, ASE 2021","2,021.00",Conference Paper,10.1109/ASE51524.2021.9678585,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85125452214&doi=10.1109%2fASE51524.2021.9678585&partnerID=40&md5=f29518f0e7f188b13e1c0e3c91c22511,No,Containers;  Docker;  Maintenance;  Refactoring;  Technical debt
S395,Read,Accepted,[IC1] - The primary study presents or points to a software artifact that automates a task within at least one TD management activity.,,Evolution of technical debt remediation in Python: A case study on the Apache Software Ecosystem,"In recent years, the evolution of software ecosystems and the detection of technical debt received significant attention by researchers from both industry and academia. While a few studies that analyze various aspects of technical debt evolution already exist, to the best of our knowledge, there is no large-scale study that focuses on the remediation of technical debt over time in Python projects—that is, one of the most popular programming languages at the moment. In this paper, we analyze the evolution of technical debt in 44 Python open-source software projects belonging to the Apache Software Foundation. We focus on the type and amount of technical debt that is paid back. The study required the mining of over 60K commits, detailed code analysis on 3.7K system versions, and the analysis of almost 43K fixed issues. The findings show that most of the repayment effort goes into testing, documentation, complexity, and duplication removal. Moreover, more than half of the Python technical debt is short term being repaid in less than 2 months. In particular, the observations that a minority of rules account for the majority of issues fixed and spent effort suggest that addressing those kinds of debt in the future is important for research and practice. © 2020 The Authors. Journal of Software: Evolution and Process published by John Wiley & Sons Ltd",Technical Debt,MSR Studies,"Tan, J. and Feitosa, D. and Avgeriou, P. and Lungu, M.",Journal of Software: Evolution and Process,"2,021.00",Article,10.1002/smr.2319,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85096653422&doi=10.1002%2fsmr.2319&partnerID=40&md5=17b16087cc755e56857d388ee9eb13c4,No,Apache Software Foundation;  software ecosystems;  software evolution;  technical debt repayment
S410,Read,Accepted,[IC1] - The primary study presents or points to a software artifact that automates a task within at least one TD management activity.,,Technical Debt Impacting Lead-Times: An Exploratory Study,"Background: Technical Debt is a consolidated notion in software engineering research and practice. However, the estimation of its impact (interest of the debt) is still imprecise and requires heavy empirical and experimental inquiry. Objective: We aim at developing a data-driven approach to calculate the interest of Technical Debt in terms of delays in resolving affected tasks.Method: We conducted a case study to estimate the Technical Debt interest by analyzing its association with the lead time variation of resolving related Jira issues.Results: Data-driven approaches could significantly change the Technical Debt estimation and improve the removing Technical Debt prioritization. Our case study shows that the presence of Code Technical Debt did not affect the lead time for resolving the issues.Conclusion: Future works include the further refinement of this approach and its application to a larger data-set and on different type of issues. © 2021 IEEE.",Technical Debt,MSR Studies,"Lenarduzzi, V. and Martini, A. and Saarimaki, N. and Tamburri, D.A.","Proceedings - 2021 47th Euromicro Conference on Software Engineering and Advanced Applications, SEAA 2021","2,021.00",Conference Paper,10.1109/SEAA53835.2021.00032,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85119188059&doi=10.1109%2fSEAA53835.2021.00032&partnerID=40&md5=aa61a2e188974a7848c87e65473cb369,No,Empirical Study;  SonarQube;  Technical Debt
S445,Read,Accepted,[IC1] - The primary study presents or points to a software artifact that automates a task within at least one TD management activity.,,A DQN-based agent for automatic software refactoring,"Context: Nowadays, technical debt has become a very important issue in software project management. The main mechanism to repay this debt is through refactoring. Refactoring software projects usually comes at a high cost. As a result, researchers have always looked for ways to minimize this cost, and a good potential candidate to reduce the cost of a process is to automate it. Objective: One of the automatic software refactoring methods that recently has received a lot of attention is based on search-based software engineering (SBSE) methods. Although because of comprehensiveness and versatility SBSE is considered an appropriate method for automatic refactoring, it has its downsides, the most important of which are the uncertainty of the results and the exponential execution time. Method: In this research, a solution is proposed inspired by search-based refactoring while taking advantage of exploitation in reinforcement learning techniques. This work aims to solve the uncertainty problems and execution time for large programs. In the proposed approach, the problem of uncertainty is solved by targeting the selection of refactoring actions used in the search-based approach. Also, due to the reduction of the dependency between the choice of the appropriate refactoring and its execution time, the time problem in large software refactoring has been greatly improved. Results: Amongst the performed evaluations and specifically for the refactoring of the largest case study, the proposed approach managed to increase the accuracy to more than twice of the SBSE refactoring approaches, while reducing the execution time of refactoring by more than 98%. Conclusion: The results of the tests show that with increasing the volume and size of the software, the performance of the proposed approach also improves compared to the methods based on SBSE, both in terms of reducing technical debt and speeding up the refactoring process. © 2022",TD Symptoms/Consequences,Tool,"Ahmadi, H. and Ashtiani, M. and Azgomi, M.A. and Saheb-Nassagh, R.",Information and Software Technology,"2,022.00",Article,10.1016/j.infsof.2022.106893,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85125538286&doi=10.1016%2fj.infsof.2022.106893&partnerID=40&md5=e7dbbb7040631e77f785234db0604831,No,Design patterns;  Reinforcement learning;  Software metrics;  Software refactoring;  Technical debt
S433,Read,Accepted,[IC1] - The primary study presents or points to a software artifact that automates a task within at least one TD management activity.,,Empirical evaluation of an architectural technical debt index in the context of the Apache and ONAP ecosystems,"Background. Architectural Technical Debt (ATD) in a software-intensive system denotes architectural design choices which, while being suitable or even optimal when adopted, lower the maintainability and evolvability of the system in the long term, hindering future development activities. Despite the growing research interest in ATD, how to gain an informative and encompassing viewpoint of the ATD present in a software-intensive system is still an open problem. Objective. In this study, we evaluate ATDx, a data-driven approach providing an overview of the ATD present in a software-intensive system. The approach, based on the analysis of a software portfolio, calculates severity levels of architectural rule violations via a clustering algorithm, and aggregates results into different ATD dimensions. Method. To evaluate ATDx, we implement an instance of the approach based on SonarQube, and run the analysis on the Apache and ONAP ecosystems. The analysis results are then shared with the portfolio contributors, who are invited to participate in an online survey designed to evaluate the representativeness and actionability of the approach. Results. The survey results confirm the representativeness of the ATDx, in terms of both the ATDx analysis results and the used architectural technical debt dimensions. Results also showed the actionability of the approach, although to a lower extent when compared to the ATDx representativeness, with usage scenarios including refactoring, code review, communication, and ATD evolution analysis. Conclusions. With ATDx, we strive for the establishment of a sound, comprehensive, and intuitive architectural view of the ATD identifiable via source code analysis. The collected results are promising, and display both the representativeness and actionability of the approach. As future work, we plan to consolidate the approach via further empirical experimentation, by considering other development contexts (e.g., proprietary portfolios and other source code analysis tools), and enhancing the ATDx report capabilities. Copyright 2022 Verdecchia et al.",Technical Debt,Tool,"Verdecchia, R. and Malavolta, I. and Lago, P. and Ozkaya, I.",PeerJ Computer Science,"2,022.00",Article,10.7717/peerj-cs.833,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85125096682&doi=10.7717%2fpeerj-cs.833&partnerID=40&md5=06879917efc4b3a920e55ab3eb81502a,No,Empirical evaluation;  Index;  Software architecture;  Software metrics;  Software portfolio analysis;  Technical debt
S444,Read,Accepted,[IC1] - The primary study presents or points to a software artifact that automates a task within at least one TD management activity.,,DebtFree: minimizing labeling cost in self-admitted technical debt identification using semi-supervised learning,"Keeping track of and managing Self-Admitted Technical Debts (SATDs) is important for maintaining a healthy software project. Current active-learning SATD recognition tool involves manual inspection of 24% of the test comments on average to reach 90% of the recall. Among all the test comments, about 5% are SATDs. The human experts are then required to read almost a quintuple of the SATD comments which indicates the inefficiency of the tool. Plus, human experts are still prone to error: 95% of the false-positive labels from previous work were actually true positives. To solve the above problems, we propose DebtFree, a two-mode framework based on unsupervised learning for identifying SATDs. In mode1, when the existing training data is unlabeled, DebtFree starts with an unsupervised learner to automatically pseudo-label the programming comments in the training data. In contrast, in mode2 where labels are available with the corresponding training data, DebtFree starts with a pre-processor that identifies the highly prone SATDs from the test dataset. Then, our machine learning model is employed to assist human experts in manually identifying the remaining SATDs. Our experiments on 10 software projects show that both models yield statistically significant improvement in effectiveness over the state-of-the-art automated and semi-automated models. Specifically, DebtFree can reduce the labeling effort by 99% in mode1 (unlabeled training data), and up to 63% in mode2 (labeled training data) while improving the current active learner’s F1 relatively to almost 100%. © 2022, The Author(s), under exclusive licence to Springer Science+Business Media, LLC, part of Springer Nature.",Technical Debt,Tool,"Tu, H. and Menzies, T.",Empirical Software Engineering,"2,022.00",Article,10.1007/s10664-022-10121-w,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85127825250&doi=10.1007%2fs10664-022-10121-w&partnerID=40&md5=6b976295e4a0ab64440d5bea832c353d,No,Labeling effort;  Semi-supervised learning;  Technical debt;  Unsupervised learning
S448,Read,Accepted,[IC1] - The primary study presents or points to a software artifact that automates a task within at least one TD management activity.,,SATDBailiff-mining and tracking self-admitted technical debt,"Self-Admitted Technical Debt (SATD) is a metaphorical concept to describe the self-documented addition of technical debt to a software project in the form of source code comments. SATD can linger in projects and degrade source-code quality, but it can also be more visible than unintentionally added or undocumented technical debt. Understanding the implications of adding SATD to a software project is important because developers can benefit from a better understanding of the quality trade-offs they are making. However, empirical studies, analyzing the survivability and removal of SATD comments, are challenged by potential code changes or SATD comment updates that may interfere with properly tracking their appearance, existence, and removal. In this paper, we propose SATDBailiff, a tool that uses an existing state-of-the-art SATD detection tool, to identify SATD in method comments, then properly track their lifespan. SATDBailiff is given as input links to open source projects, and its output is a list of all identified SATDs, and for each detected SATD, SATDBailiff reports all its associated changes, including any updates to its text, all the way to reporting its removal. The goal of SATDBailiff is to aid researchers and practitioners in better tracking SATDs instances, and providing them with a reliable tool that can be easily extended. SATDBailiff was validated using a dataset of previously detected and manually validated SATD instances. SATDBailiff is publicly available as an open source, along with the manual analysis of SATD instances associated with its validation, on the project website. © 2021 Elsevier B.V.",Technical Debt,Tool,"AlOmar, E.A. and Christians, B. and Busho, M. and AlKhalid, A.H. and Ouni, A. and Newman, C. and Mkaouer, M.W.",Science of Computer Programming,"2,022.00",Article,10.1016/j.scico.2021.102693,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85115889625&doi=10.1016%2fj.scico.2021.102693&partnerID=40&md5=5dbc6d48d322c359a08ff5baedd3732b,No,Mining software repositories;  Self-admitted technical debt
S386,Read,Rejected,[EC6] - The study is a previous version of a more complete one that also mentions the same automation artifact.,Same that S302,The temporality of technical debt introduction on new code and confounding factors,"Code Technical Debt (TD) is intentionally or unintentionally created when developers introduce inefficiencies in the codebase. This can be attributed to various reasons such as heavy workload, tight delivery schedule, or developers’ lack of experience. Since a software system grows mostly through the addition of new code, it is interesting to study how TD fluctuates along this process. Specifically, in this paper, we investigate: (a) the temporality of code TD introduction in new code, i.e., whether the introduction of TD is stable across the lifespan of the project, or if its evolution presents spikes; and (b) the relation of TD introduction to the development team’s workload in a given period, as well as to the experience of the development team. To answer these questions, we have performed a case study on 47 open-source projects from two well-known ecosystems (Apache and Eclipse) as well as additional isolated projects from GitHub (not selected from a specific ecosystem) and inspected the number of TD issues introduced in 6-month sliding temporal windows. The results of the study suggested that: (a) overall, the number of TD issues introduced through new code is a stable measure, although it presents spikes; and (b) the number of commits performed, as well as developers’ experience are not strongly correlated to the number of introduced TD issues. © 2021, The Author(s), under exclusive licence to Springer Science+Business Media, LLC, part of Springer Nature.",Technical Debt,MSR Studies,"Digkas, G. and Ampatzoglou, A. and Chatzigeorgiou, A. and Avgeriou, P.",Software Quality Journal,2021,Article,10.1007/s11219-021-09569-8,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85119501911&doi=10.1007%2fs11219-021-09569-8&partnerID=40&md5=ff03a242d5283fcece3f12be9c190420,No,Case study;  Metrics fluctuation;  New code debt;  TD temporality
S394,Read,Rejected,[EC2] - The study shows a theoretical artifact or do not provide a link to the artifact's repository;,The study does not provide a link to the artifacts that was used,An exploratory study on the introduction and removal of different types of technical debt in deep learning frameworks,"To complete tasks faster, developers often have to sacrifice the quality of the software. Such compromised practice results in the increasing burden to developers in future development. The metaphor, technical debt, describes such practice. Prior research has illustrated the negative impact of technical debt, and many researchers investigated how developers deal with a certain type of technical debt. However, few studies focused on the removal of different types of technical debt in practice. To fill this gap, we use the introduction and removal of different types of self-admitted technical debt (i.e., SATD) in 7 deep learning frameworks as an example. This is because deep learning frameworks are some of the most important software systems today due to their prevalent use in life-impacting deep learning applications. Moreover, the field of the development of different deep learning frameworks is the same, which enables us to find common behaviors on the removal of different types of technical debt across projects. By mining the file history of these frameworks, we find that design debt is introduced the most along the development process. As for the removal of technical debt, we find that requirement debt is removed the most, and design debt is removed the fastest. Most of test debt, design debt, and requirement debt are removed by the developers who introduced them. Based on the introduction and removal of different types of technical debt, we discuss the evolution of the frequencies of different types of technical debt to depict the unresolved sub-optimal trade-offs or decisions that are confronted by developers along the development process. We also discuss the removal patterns of different types of technical debt, highlight future research directions, and provide recommendations for practitioners. © 2021, The Author(s), under exclusive licence to Springer Science+Business Media, LLC part of Springer Nature.",Technical Debt,MSR Studies,"Liu, J. and Huang, Q. and Xia, X. and Shihab, E. and Lo, D. and Li, S.",Empirical Software Engineering,2021,Article,10.1007/s10664-020-09917-5,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85100924329&doi=10.1007%2fs10664-020-09917-5&partnerID=40&md5=3e7ce79f3c6bc5ed55165ba876d31c97,No,Categorization;  Deep learning;  Empirical study;  Self-admitted technical debt
S400,Read,Rejected,[EC2a] - The study provides a broken link,The supplementary material has a broken link,Evaluating unit testing practices in R packages,"Testing Technical Debt (TTD) occurs due to shortcuts (non-optimal decisions) taken about testing; it is the test dimension of technical debt. R is a package-based programming ecosystem that provides an easy way to install third-party code, datasets, tests, documentation and examples. This structure makes it especially vulnerable to TTD because errors present in a package can transitively affect all packages and scripts that depend on it. Thus, TTD can effectively become a threat to the validity of all analysis written in R that rely on potentially faulty code. This two-part study provides the first analysis in this area. First, 177 systematically-selected, open-source R packages were mined and analysed to address quality of testing, testing goals, and identify potential TTD sources. Second, a survey addressed how R package developers perceive testing and face its challenges (response rate of 19.4%). Results show that testing in R packages is of low quality; the most common smells are inadequate and obscure unit testing, improper asserts, inexperienced testers and improper test design. Furthermore, skilled R developers still face challenges such as time constraints, emphasis on development rather than testing, poor tool documentation and a steep learning curve. © 2021 IEEE.",Technical Debt,MSR Studies,"Vidoni, M.",Proceedings - International Conference on Software Engineering,2021,Conference Paper,10.1109/ICSE43902.2021.00136,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85115730695&doi=10.1109%2fICSE43902.2021.00136&partnerID=40&md5=46ea15577b80be5b47765ac316108eeb,No,Developers survey;  Mining software repositories;  R programming;  Testing Technical debt;  Unit testing
S418,Read,Rejected,[EC2] - The study shows a theoretical artifact or do not provide a link to the artifact's repository;,No artifact is presented in the study,An empirical study of refactorings and technical debt in machine learning systems,"Machine Learning (ML), including Deep Learning (DL), systems, i.e., those with ML capabilities, are pervasive in today's data-driven society. Such systems are complex; they are comprised of ML models and many subsystems that support learning processes. As with other complex systems, ML systems are prone to classic technical debt issues, especially when such systems are long-lived, but they also exhibit debt specific to these systems. Unfortunately, there is a gap of knowledge in how ML systems actually evolve and are maintained. In this paper, we fill this gap by studying refactorings, i.e., source-to-source semantics-preserving program transformations, performed in real-world, open-source software, and the technical debt issues they alleviate. We analyzed 26 projects, consisting of 4.2 MLOC, along with 327 manually examined code patches. The results indicate that developers refactor these systems for a variety of reasons, both specific and tangential to ML, some refactorings correspond to established technical debt categories, while others do not, and code duplication is a major cross-cutting theme that particularly involved ML configuration and model code, which was also the most refactored. We also introduce 14 and 7 new ML-specific refactorings and technical debt categories, respectively, and put forth several recommendations, best practices, and anti-patterns. The results can potentially assist practitioners, tool developers, and educators in facilitating long-term ML system usefulness. © 2021 IEEE.",Technical Debt,MSR Studies,"Tang, Y. and Khatchadourian, R. and Bagherzadeh, M. and Singh, R. and Stewart, A. and Raja, A.",Proceedings - International Conference on Software Engineering,2021,Conference Paper,10.1109/ICSE43902.2021.00033,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85112094387&doi=10.1109%2fICSE43902.2021.00033&partnerID=40&md5=7e439b62b2c0f13c230c4bfd4a1f6346,No,Empirical studies;  Machine learning systems;  Refactoring;  Software evolution;  Software repository mining;  Technical debt
S45,Read,Rejected,[EC2] - The study shows a theoretical artifact or do not provide a link to the artifact's repository;,The study does not provide a link to an artifact,Mining knowledge on technical debt propagation,"Technical debt has gained considerable traction both in the industry and the academia due to its unique ability to distinguish asset management characteristics for problematic software project trade-offs. Management of technical debt relies on separate solutions identifying instances of technical debt, tracking the instances, and delivering information regarding the debt to relevant decision making processes. While there are several of these solutions available, due to the multiformity of software development, they are applicable only in predefined contexts that are often independent from one another. As technical debt management must consider all these aspects in unison, our work pursues connecting the software contexts via unlimited capturing and explanation of technical debt propagation intra- and inter-software-contexts. We mine software repositories (MSR) for data regarding the amount of work as a function of time. Concurrently, we gather information on events that are clearly external to the programmers' own work on these repositories. These data are then combined in an effort to statistically measure the impact of these events in the amount of work. With this data, as future work, we can apply taxonomies, code analysis, and other analyses to pinpoint these effects into different technical debt propagation channels. Abstraction of the channel patterns into rules is pursued so that development tools may automatically maintain technical debt information with them (the authors have introduced the DebtFlag tool for this). Hence, successfully implementing this study would allow further understanding and describing technical debt propagation at both the high level (longitudinal technical debt propagation effects for the project) and the low level (artifact level effects describing the mechanism of technical debt value accumulation).",Technical Debt,MSR Studies,"Suovuo, T. and Holvitie, J. and Smed, J. and Leppänen, V.",CEUR Workshop Proceedings,2015,Conference Paper,,https://www.scopus.com/inward/record.uri?eid=2-s2.0-84962543117&partnerID=40&md5=f8fdbd9e260285ce7d85c02b545e26a4,No,
S62,Read,Rejected,[EC2a] - The study provides a broken link,The link provided is broken,A large-scale empirical study on self-admitted technical debt,"Technical debt is a metaphor introduced by Cunningham to indicate ""not quite right code which we postpone making it right"". Examples of technical debt are code smells and bug hazards. Several techniques have been proposed to detect different types of technical debt. Among those, Potdar and Shihab defined heuristics to detect instances of self-admitted technical debt in code comments, and used them to perform an empirical study on five software systems to investigate the phenomenon. Still, very little is known about the diffusion and evolution of technical debt in software projects. This paper presents a differentiated replication of the work by Potdar and Shihab. We run a study across 159 software projects to investigate the diffusion and evolution of self-admitted technical debt and its relationship with software quality. The study required the mining of over 600K commits and 2 Billion comments as well as a qualitative analysis performed via open coding. Our main findings show that self-admitted technical debt (i) is diffused, with an average of 51 instances per system, (ii) is mostly represented by code (30%), defect, and requirement debt (20% each), (iii) increases over time due to the introduction of new instances that are not fixed by developers, and (iv) even when fixed, it survives long time (over 1,000 commits on average) in the system. © 2016 ACM.",Technical Debt,MSR Studies,"Bavota, G. and Russo, B.","Proceedings - 13th Working Conference on Mining Software Repositories, MSR 2016",2016,Conference Paper,10.1145/2901739.2901742,https://www.scopus.com/inward/record.uri?eid=2-s2.0-84974604506&doi=10.1145%2f2901739.2901742&partnerID=40&md5=522504d1861300cb6fd2b195801e9ac9,No,Empirical software engineering;  Mining software repositories;  Technical debt
S81,Read,Rejected,[EC2] - The study shows a theoretical artifact or do not provide a link to the artifact's repository;,The study does not point to any artifact,Examining the impact of self-admitted technical debt on software quality,"Technical debt refers to incomplete or temporary workarounds that allow us to speed software development in the short term at the cost of paying a higher price later on. Recently, studies have shown that technical debt can be detected from source code comments, referred to as self-admitted technical debt. Researchers have examined the detection, classification and removal of self-admitted technical debt. However, to date there is no empirical evidence on the impact of self-admitted technical debt on software quality. Therefore, in this paper, we examine the relation between self-admitted technical debt and software quality by investigating whether (i) files with self-admitted technical debt have more defects compared to files without self-admitted technical debt, (ii) whether self-admitted technical debt changes introduce future defects, and (iii) whether self-admitted technical debt-related changes tend to be more difficult. We measured the difficulty of a change using well-known measures proposed in prior work such as the amount of churn, the number of files, the number of modified modules in a change, as well as the entropy of a change. An empirical study using five open source projects, namely Hadoop, Chromium, Cassandra, Spark and Tomcat, showed that: i) there is no clear trend when it comes to defects and self-admitted technical debt, although the defectiveness of the technical debt files increases after the introduction of technical debt, ii) self-admitted technical debt changes induce less future defects than none technical debt changes, however, iii) self-admitted technical debt changes are more difficult to perform, i.e., they are more complex. Our study indicates that although technical debt may have negative effects, its impact is not only related to defects, rather making the system more difficult to change in the future. © 2016 IEEE",Technical Debt,MSR Studies,"Wehaibi, S. and Shihab, E. and Guerrouj, L.","2016 IEEE 23rd International Conference on Software Analysis, Evolution, and Reengineering, SANER 2016",2016,Conference Paper,10.1109/SANER.2016.72,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85099135104&doi=10.1109%2fSANER.2016.72&partnerID=40&md5=f87cc6fbaf08850b5ebde785938e2606,No,
S405,Read,Rejected,[EC2] - The study shows a theoretical artifact or do not provide a link to the artifact's repository;,The study does not point to any artifact,"Identifying architectural technical debt, principal, and interest in microservices: A multiple-case study","Background: Using a microservices architecture is a popular strategy for software organizations to deliver value to their customers fast and continuously. However, scientific knowledge on how to manage architectural debt in microservices is scarce. Objectives: In the context of microservices applications, this paper aims to identify architectural technical debts (ATDs), their costs, and their most common solutions. Method: We conducted an exploratory multiple case study by conducting 25 interviews with practitioners working with microservices in seven large companies. Results: We found 16 ATD issues, their negative impact (interest), and common solutions to repay each debt together with the related costs (principal). Two examples of critical ATD issues found were the use of shared databases that, if not properly planned, leads to potential breaks on services every time the database schema changes and bad API designs, which leads to coupling among teams. We identified ATDs occurring in different domains and stages of development and created a map of the relationships among those debts. Conclusion: The findings may guide organizations in developing microservices systems that better manage and avoid architectural debts. © 2021 The Authors",Technical Debt,Interview,"de Toledo, S.S. and Martini, A. and Sjøberg, D.I.K.",Journal of Systems and Software,2021,Article,10.1016/j.jss.2021.110968,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85104051358&doi=10.1016%2fj.jss.2021.110968&partnerID=40&md5=bf474414881d6c2a9f9b0844afc822be,No,Cost of software;  Cross-company study;  Qualitative analysis;  Software maintainability;  Software quality
S279,Read,Rejected,[EC1] - The primary study is out of the scope of this work;,"Even the authors point to their scripts, they do not automate any task of TDM",A large empirical assessment of the role of data balancing in machine-learning-based code smell detection,"Code smells can compromise software quality in the long term by inducing technical debt. For this reason, many approaches aimed at identifying these design flaws have been proposed in the last decade. Most of them are based on heuristics in which a set of metrics is used to detect smelly code components. However, these techniques suffer from subjective interpretations, a low agreement between detectors, and threshold dependability. To overcome these limitations, previous work applied Machine-Learning that can learn from previous datasets without needing any threshold definition. However, more recent work has shown that Machine-Learning is not always suitable for code smell detection due to the highly imbalanced nature of the problem. In this study, we investigate five approaches to mitigate data imbalance issues to understand their impact on Machine Learning-based approaches for code smell detection in Object-Oriented systems and those implementing the Model-View-Controller pattern. Our findings show that avoiding balancing does not dramatically impact accuracy. Existing data balancing techniques are inadequate for code smell detection leading to poor accuracy for Machine-Learning-based approaches. Therefore, new metrics to exploit different software characteristics and new techniques to effectively combine them are needed. © 2020 Elsevier Inc.",Smells,Case Study,"Pecorelli, F. and Di Nucci, D. and De Roover, C. and De Lucia, A.",Journal of Systems and Software,2020,Article,10.1016/j.jss.2020.110693,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85086465273&doi=10.1016%2fj.jss.2020.110693&partnerID=40&md5=c52d1386d8458354f2e436c3ae9006dc,No,Code smells;  Data balancing;  Machine learning;  Model view controller;  Object oriented
S126,Read,Rejected,[EC1] - The primary study is out of the scope of this work;,The study does not point to any artifact,A method for assessing class change proneness,"Change proneness is a quality characteristic of software artifacts that represents their probability to change in the future due to: (a) evolving requirements, (b) bug fixing, or (c) ripple effects. In the literature, change proneness has been associated with many negative consequences along software evolution. For example, artifacts that are change-prone tend to produce more defects, and accumulate more technical debt. Therefore, identifying and monitoring modules of the system that are change-prone is of paramount importance. Assessing change proneness requires information from two sources: (a) the history of changes in the artifact as a proxy of how frequently the artifact itself is changing, and (b) the source code structure that affects the probability of a change being propagated among artifacts. In this paper, we propose a method for assessing the change proneness of classes based on the two aforementioned information sources. To validate the proposed approach, we performed a case study on five open-source projects. Specifically, we compared the accuracy of the proposed approach to the use of other software metrics and change history to assess change proneness, based on the 1061-1998 IEEE Standard on Software Measurement. The results of the case study suggest that the proposed method is the most accurate and reliable assessor of change proneness. The high accuracy of the method suggests that the method and accompanying tool can effectively aid practitioners during software maintenance and evolution. © 2017 Association for Computing Machinery ACM.",TD Symptoms/Consequences,Case Study,"Arvanitou, E.-M. and Ampatzoglou, A. and Chatzigeorgiou, A. and Avgeriou, P.",ACM International Conference Proceeding Series,2017,Conference Paper,10.1145/3084226.3084239,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85025432762&doi=10.1145%2f3084226.3084239&partnerID=40&md5=874158b90143a4a1ada5da7df674be31,No,Case study;  Change proneness;  Metrics;  Software quality
S422,Read,Accepted,[IC1] - The primary study presents or points to a software artifact that automates a task within at least one TD management activity.,,Detection of Design Smells Using Adaptive Neuro-Fuzzy Approaches,"Software evolution, an integral part of the software development process, encompasses frequent and numerous changes and updates that may lead to complex and poor-quality systems. Software engineers and quality practitioners continually refactor the software components to mitigate the negative effects of code and design smells. Although these smells are not directly connected to design and coding bugs, they are high indicators of technical debt that may arise as bugs in future software releases. Therefore, refactoring plays a significant role in the overall software evolution process. To fix the underlying code and design smells, they must be first detected and classified. As code smells have been the focus of research in the literature, this paper focuses on detecting design smells. A novel design smell detection scheme is proposed using adaptive neuro-fuzzy approaches. This scheme can be seamlessly integrated with any refactoring scheduling and prioritization models as it is efficiently designed using a fast-training scheme based on a neuro-fuzzy architecture. In addition, the design smell detection solution relies on a reduced set of software metrics. A large custom dataset with more than 30,000 class records is created to assess the performance of the design smell detection solution. The reported performance scores confirm the superiority of the proposed technique over the existing ones. The accuracy, precision, recall, and area-under-the-curve (AUC) scores attained 0.97, 0.98, 0.98, and 0.99, respectively. Thanks to the high detection scores, design smell refactoring sequencing and prioritization routines can be further enhanced. © 2022, The Author(s) under exclusive licence to Taiwan Fuzzy Systems Association.",Smells,Tool,"AbuHassan, A. and Alshayeb, M. and Ghouti, L.",International Journal of Fuzzy Systems,"2,022.00",Article,10.1007/s40815-022-01248-5,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85125222267&doi=10.1007%2fs40815-022-01248-5&partnerID=40&md5=9f7e9f99ac22a96db4a97550f0f8e2c5,No,Benchmark design smell detection dataset;  Design smell detection;  Empirical study;  Fuzzy rules;  Neuro-fuzzy
S423,Read,Accepted,[IC1] - The primary study presents or points to a software artifact that automates a task within at least one TD management activity.,,Crowdsmelling: A preliminary study on using collective knowledge in code smells detection,"Code smells are seen as major source of technical debt and, as such, should be detected and removed. However, researchers argue that the subjectiveness of the code smells detection process is a major hindrance to mitigate the problem of smells-infected code. This paper presents the results of a validation experiment for the Crowdsmelling approach proposed earlier. The latter is based on supervised machine learning techniques, where the wisdom of the crowd (of software developers) is used to collectively calibrate code smells detection algorithms, thereby lessening the subjectivity issue. In the context of three consecutive years of a Software Engineering course, a total “crowd” of around a hundred teams, with an average of three members each, classified the presence of 3 code smells (Long Method, God Class, and Feature Envy) in Java source code. These classifications were the basis of the oracles used for training six machine learning algorithms. Over one hundred models were generated and evaluated to determine which machine learning algorithms had the best performance in detecting each of the aforementioned code smells. Good performances were obtained for God Class detection (ROC= 0.896 for Naive Bayes) and Long Method detection (ROC= 0.870 for AdaBoostM1), but much lower for Feature Envy (ROC= 0.570 for Random Forrest). The results suggest that Crowdsmelling is a feasible approach for the detection of code smells. Further validation experiments based on dynamic learning are required to a comprehensive coverage of code smells to increase external validity. © 2022, The Author(s), under exclusive licence to Springer Science+Business Media, LLC, part of Springer Nature.",Smells,Tool,"Reis, J.P. and Abreu, F.B. and Carneiro, G.F.",Empirical Software Engineering,"2,022.00",Article,10.1007/s10664-021-10110-5,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85126535966&doi=10.1007%2fs10664-021-10110-5&partnerID=40&md5=4532d1f2c2f16aac1c17a49eb93c0e31,No,Code smells;  Code smells detection;  Collective knowledge;  Crowdsmelling;  Machine learning algorithms;  Software maintenance;  Software quality
S429,Read,Accepted,[IC1] - The primary study presents or points to a software artifact that automates a task within at least one TD management activity.,,Technical debt as an indicator of software security risk: a machine learning approach for software development enterprises,"Vulnerability prediction facilitates the development of secure software, as it enables the identification and mitigation of security risks early enough in the software development lifecycle. Although several factors have been studied for their ability to indicate software security risk, very limited attention has been given to technical debt (TD), despite its potential relevance to software security. To this end, in the present study, we investigate the ability of common TD indicators to indicate security risks in software products, both at project-level and at class-level of granularity. Our findings suggest that TD indicators may potentially act as security indicators as well. © 2020 Informa UK Limited, trading as Taylor & Francis Group.",TD Symptoms/Consequences,Tool,"Siavvas, M. and Tsoukalas, D. and Jankovic, M. and Kehagias, D. and Tzovaras, D.",Enterprise Information Systems,"2,022.00",Article,10.1080/17517575.2020.1824017,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85091426748&doi=10.1080%2f17517575.2020.1824017&partnerID=40&md5=cda4cfb39edc69c3987dbadb2f2f44bf,No,decision making;  Software engineering;  software security;  technical debt;  vulnerability prediction
S417,Read,Rejected,[EC1] - The primary study is out of the scope of this work;,The study proposes an analysis and does not point to any artifact to automate TDM,Technical Debt in Large-Scale Distributed Projects: An Industrial Case Study,"Technical debt (TD) is a metaphor that reflects the technical compromises that sacrifice the long-term health of a software product to achieve short term benefit. It is important to manage TD to avoid software degradation. In large-scale distributed projects, technical debt management (TDM) becomes more complex and challenging. There is a lack of empirical studies on the TD accumulation in large-scale distributed projects. Then, to address this gap, we conducted a case study in Ericsson (a European Telecom Company) to identify the relationship between TD accumulation and factors such as task complexity, lead time, total of developers, and task scaling. We used data from 33 projects extracted from managerial documents to conduct a regression analysis. We also conducted interviews with seniors developers of the team to interpret the results. We found out that Task Complexity has a strong relationship (p-value = 5.69 × 10-5) with Technical Debt, while Global Distance was mentioned by the interviewees as a relevant factor for TD accumulation (although not statistically significant in our regression analysis). Practitioners should consider avoiding complex/big tasks, breaking down big tasks into small ones (if possible). We also plan to analyze other projects in this company to confirm our findings further. © 2021 IEEE.",Technical Debt,MSR Studies,"Sousa, A. and Rocha, L. and Britto, R. and Gong, Z. and Lyu, F.","Proceedings - 2021 IEEE International Conference on Software Analysis, Evolution and Reengineering, SANER 2021",2021,Conference Paper,10.1109/SANER50967.2021.00071,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85106614306&doi=10.1109%2fSANER50967.2021.00071&partnerID=40&md5=f95708694bd9f1534f5dbf31961fb536,No,global software engineering;  large-scale;  technical debt management
S431,Read,Accepted,[IC1] - The primary study presents or points to a software artifact that automates a task within at least one TD management activity.,,Practice of Tech Debt Assessment and Management with TETRA™,"The paper covers the further development of the company’s proprietary approach to the assessment of software product quality and measurement of technical debt. In the current paper, the authors show assessment results of the existing e-learning project with the help of the Technical dEbT Reduction plAtform (TETRA™) with exact numbers of all reviewed metrics and assigned indices as well. The methodology, its advantages and limitations are also discussed. © 2022, The Author(s), under exclusive license to Springer Nature Singapore Pte Ltd.",Technical Debt,Tool,"Kontsevoi, B. and Syraeshko, D. and Terekhov, S.",Lecture Notes in Networks and Systems,"2,022.00",Conference Paper,10.1007/978-981-16-2380-6_74,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85115994520&doi=10.1007%2f978-981-16-2380-6_74&partnerID=40&md5=6908f041bca4f446c85c920b0c72827f,No,Quality assurance;  Quality management;  Software development;  Software product;  Source code;  Technical debt
S432,Read,Accepted,[IC1] - The primary study presents or points to a software artifact that automates a task within at least one TD management activity.,,Toward prioritization of self-admitted technical debt: an approach to support decision to payment,"Technical Debt (TD) is a metaphor that describes the cost–benefit relationship between postponing technical development activities and the consequences of this long-term postponement. The lack of TD Management compromises the Software’s internal quality. It makes its maintenance complex and costly. TD instances are called Self-Admitted Technical Debt (SATD) when intentionally committed and documented through comments in the source code. Several studies explore the identification of SATD, but approaches to support the payment stage are lacking, particularly approaches to indicate which SATD priority for payment. This paper presents an approach to support the prioritization activity in SATD payment. The Prioritization Approach focuses on creating associations between SATD associations and problems found in the source code, identified by Automatic Static Analysis. The results demonstrate that using the issues found on source code and SATD description (found in comments) has greater precision to establish the priority among the SATD compared to the SATD description on comments. We applied the approach proposed to different software projects, and the results support developers’ prioritization. © 2021, The Author(s), under exclusive licence to Springer Science+Business Media, LLC, part of Springer Nature.",Technical Debt,Tool,"de Lima, B.S. and Garcia, R.E. and Eler, D.M.",Software Quality Journal,"2,022.00",Article,10.1007/s11219-021-09578-7,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85123247050&doi=10.1007%2fs11219-021-09578-7&partnerID=40&md5=f8da8fe1b0e0b26ae3df1d4da5e4e904,No,Self-Admitted Technical Debt;  Software Maintenance;  Software quality;  Technical Debt Managing;  Technical Debt Prioritization
S442,Read,Accepted,[IC1] - The primary study presents or points to a software artifact that automates a task within at least one TD management activity.,,Identifying Self-Admitted Technical Debts With Jitterbug: A Two-Step Approach,"Keeping track of and managing Self-Admitted Technical Debts (SATDs) are important to maintaining a healthy software project. This requires much time and effort from human experts to identify the SATDs manually. The current automated solutions do not have satisfactory precision and recall in identifying SATDs to fully automate the process. To solve the above problems, we propose a two-step framework called Jitterbug for identifying SATDs. Jitterbug first identifies the 'easy to find' SATDs automatically with close to 100 percent precision using a novel pattern recognition technique. Subsequently, machine learning techniques are applied to assist human experts in manually identifying the remaining 'hard to find' SATDs with reduced human effort. Our simulation studies on ten software projects show that Jitterbug can identify SATDs more efficiently (with less human effort) than the prior state-of-the-art methods. © 1976-2012 IEEE.",Technical Debt,Tool,"Yu, Z. and Fahid, F.M. and Tu, H. and Menzies, T.",IEEE Transactions on Software Engineering,"2,022.00",Article,10.1109/TSE.2020.3031401,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85096147180&doi=10.1109%2fTSE.2020.3031401&partnerID=40&md5=6ccbd34b4c58d5bca5a9cd37fc2cec63,No,machine learning;  pattern recognition;  software engineering;  Technical debt
S440,Read,Rejected,[EC1] - The primary study is out of the scope of this work;,"After reading the paper, it does uses or points to any tools, indeed, it analyses (manually) the presence of TD in Deep Learning Projects",An empirical study on self-admitted technical debt in Dockerfiles,"In software development, ad hoc solutions that are intentionally implemented by developers are called self-admitted technical debt (SATD). Because the existence of SATD spreads poor implementations, it is necessary to remove it as soon as possible. Meanwhile, container virtualization has been attracting attention in recent years as a technology to support infrastructure such as servers. Currently, Docker is the de facto standard for container virtualization. In Docker, a file describing how to build a container (Dockerfile) is a set of procedural instructions; thus, it can be considered as a kind of source code. Moreover, because Docker is a relatively new technology, there are few developers who have accumulated good or bad practices for building Docker container. Hence, it is likely that Dockerfiles contain many SATDs, as is the case with general programming language source code analyzed in previous SATD studies. The goal of this paper is to categorize SATDs in Dockerfiles and to share knowledge with developers and researchers. To achieve this goal, we conducted a manual classification for SATDs in Dockerfile. We found that about 3.0% of the comments in Dockerfile are SATD. In addition, we have classified SATDs into five classes and eleven subclasses. Among them, there are some SATDs specific to Docker, such as SATDs for version fixing and for integrity check. The three most common classes of SATD were related to lowering maintainability, testing, and defects. © 2022, The Author(s).",Technical Debt,MSR Studies,"Azuma, H. and Matsumoto, S. and Kamei, Y. and Kusumoto, S.",Empirical Software Engineering,2022,Article,10.1007/s10664-021-10081-7,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85124006010&doi=10.1007%2fs10664-021-10081-7&partnerID=40&md5=d27f46fbd645e3b250241cfaa84d2245,No,Container virtualization;  Docker;  Infrastructure as code (IaC);  Self-admitted technical debt;  Technical debt
S443,Read,Rejected,[EC1] - The primary study is out of the scope of this work;,Does not point to any artifact,An empirical study on self-admitted technical debt in modern code review,"Technical debt is a sub-optimal state of development in projects. In particular, the type of technical debt incurred by developers themselves (e.g., comments that mean the implementation is imperfect and should be replaced with another implementation) is called self-admitted technical debt (SATD). In theory, technical debt should not be left for a long period because it accumulates more cost over time, making it more difficult to process. Accordingly, developers have traditionally conducted code reviews to find technical debt. In fact, we observe that many SATD comments are often introduced during modern code reviews (MCR) that are light-weight reviews with web applications. However, it is uncertain about the nature of SATD comments that are introduced in the review process: impact, frequency, characteristics, and triggers. Herein, this study empirically examines the relationship between SATD and MCR. Our case study of 156,372 review records from the Qt and OpenStack systems shows that (i) review records involving SATD are about 6%–7% less likely to be accepted by reviews than those without SATD; (ii) review records involving SATD tend to require two to three more revisions compared with those without SATD; (iii) 28–48% of SATD comments are introduced during code reviews; (iv) SATD during reviews works for communicating between authors and reviewers; and (v) 20% of the SATD comments are introduced due to reviewers’ requests. © 2022 Elsevier B.V.",Technical Debt,MSR Studies,"Kashiwa, Y. and Nishikawa, R. and Kamei, Y. and Kondo, M. and Shihab, E. and Sato, R. and Ubayashi, N.",Information and Software Technology,2022,Article,10.1016/j.infsof.2022.106855,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85124250048&doi=10.1016%2fj.infsof.2022.106855&partnerID=40&md5=9afeafbd064c1e6c375331632459783c,No,Modern code reviews;  Self-admitted technical debt
S447,Read,Accepted,[IC1] - The primary study presents or points to a software artifact that automates a task within at least one TD management activity.,,SDK4ED: A platform for technical debt management,"Technical debt management is of paramount importance for the software industry, since maintenance is the costlier activity in the software development lifecycle. In this article, we present the SDK4ED platform that enables efficient technical debt management (i.e., measurement, evolution analysis, prevention, etc.) at the code level, and evaluate its capabilities in an industrial setting. The SDK4ED platform is the outcome of a 3-year project, including several software industries. Since, the research rigor of the approaches that reside in SDK4ED have already been validated, in this work we focus: (a) on the presentation of the platform per se; (b) the evaluation of its industrial relevance; (c) the usability of the platform; as well as (d) the financial implications of its usage. © 2022 John Wiley & Sons Ltd.",Technical Debt,Tool,"Ampatzoglou, A. and Chatzigeorgiou, A. and Arvanitou, E.M. and Bibi, S.",Software - Practice and Experience,"2,022.00",Article,10.1002/spe.3093,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85129838215&doi=10.1002%2fspe.3093&partnerID=40&md5=e22cde9c69e6b91c1c529527fdfe7b10,No,
S420,Read,Accepted,[IC1] - The primary study presents or points to a software artifact that automates a task within at least one TD management activity.,,Towards a taxonomy of code review smells,"Context: Code review is a crucial step of the software development life cycle in order to detect possible problems in source code before merging the changeset to the codebase. Although there is no consensus on a formally defined life cycle of the code review process, many companies and open source software (OSS) communities converge on common rules and best practices. In spite of minor differences in different platforms, the primary purpose of all these rules and practices leads to a faster and more effective code review process. Non-conformance of developers to this process does not only reduce the advantages of the code review but can also introduce waste in later stages of the software development. Objectives: The aim of this study is to provide an empirical understanding of the bad practices followed in the code review process, that are code review (CR) smells. Methods: We first conduct a multivocal literature review in order to gather code review bad practices discussed in white and gray literature. Then, we conduct a targeted survey with 32 experienced software practitioners and perform follow-up interviews in order to get their expert opinion. Based on this process, a taxonomy of code review smells is introduced. To quantitatively demonstrate the existence of these smells, we analyze 226,292 code reviews collected from eight OSS projects. Results: We observe that a considerable number of code review smells exist in all projects with varying degrees of ratios. The empirical results illustrate that 72.2% of the code reviews among eight projects are affected by at least one code review smell. Conclusion: The empirical analysis shows that the OSS projects are substantially affected by the code review smells. The provided taxonomy could provide a foundation for best practices and tool support to detect and avoid code review smells in practice. © 2021",Smells,Theoretical Artifact,"Doğan, E. and Tüzün, E.",Information and Software Technology,"2,022.00",Article,10.1016/j.infsof.2021.106737,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85117847066&doi=10.1016%2fj.infsof.2021.106737&partnerID=40&md5=529d704af6de828f1e2afa02a328c520,No,Bad practices;  Code review smell;  Conformance checking;  Modern code review;  Process debt;  Process smell
S426,Read,Accepted,[IC1] - The primary study presents or points to a software artifact that automates a task within at least one TD management activity.,,The Known Unknowns: Discovering Trade-Offs Between Heterogeneous Code Changes: Invited Paper,"Software projects must adhere to a variety of non-functional requirements, also known as software qualities. Automated evaluation with respect to such requirements can be conducted thanks to a wide array of available tools. Each tool usually focuses on a specific quality, since heterogeneous analyses are needed for each non-functional requirement. Apart from an overall index expressing the project’s performance in terms of the software quality they specialize on, many tools recommend code changes that are expected to improve the aforementioned index. Thus, a development team that cares for more than one non-functional requirement is facing the problem of unknown trade-offs; besides improving the quality on which the tool that generated each suggestion focuses, how would this code change, if implemented, affect the rest of the non-functional requirements? We present a framework for dealing with this problem. We pick energy efficiency, technical debt and software security as our qualities of interest, and use three respective tools for the analysis of several open-source projects with regard to these qualities. We develop an extensible empirical model, based on fuzzy sets, for the characterization of each suggestion’s trade-offs. Finally, we present an intuitive visualization of said trade-offs, and suggest a method of utilizing them towards reliable decision-making. © 2022, Springer Nature Switzerland AG.",TD Symptoms/Consequences,Theoretical Artifact,"Lamprakos, C.P. and Marantos, C. and Papadopoulos, L. and Soudris, D.",Lecture Notes in Computer Science (including subseries Lecture Notes in Artificial Intelligence and Lecture Notes in Bioinformatics),"2,022.00",Conference Paper,10.1007/978-3-031-04580-6_23,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85129823404&doi=10.1007%2f978-3-031-04580-6_23&partnerID=40&md5=4fcc87848cce86df535d1423b50f5552,No,Decision-making;  Software quality;  Trade-off analysis
S260,Read,Rejected,[EC1] - The primary study is out of the scope of this work;,The study does not point to any artifact,Trade-offs in managing risk and technical debt in industrial research labs: An experience report,"Nowadays, industrial research labs operate like startups. In a relatively short amount of time, researchers are expected not only to explore innovative ideas but also show how the new ideas can add value to the organisation. One way to do this, especially when developing tools, is to construct usable prototypes. When the technology underlying the research tool is highly complex or niche, like program analysis, field trials with potential users also help explaining and demonstrating the benefits of the tool. Getting support from potential users helps demonstrate value to the organisation, which in turn justifies conducting more extensive research and investing more resources to enhance the initial prototype. Thus, research that involves the construction of tools need to manage both short and long term risk, and the technical debt that arises throughout the lifecycle of a research prototype. As not all prototypes will result in a technology transfer, one has to carefully manage the project resources dedicated to paying the technical debt. For example, failure to pay the debt early in the project might result in unstable prototypes that can have a negative influence on potential customers and make technology transfer harder. On the other hand, over committing resources to reduce the technical debt might result in slower research progress and failure to show improvement over state-of-the-art. In this paper, we will present experience reports from two dynamic program analysis projects. at Oracle Labs Australia. © 2020 ACM.",Technical Debt,Experience Report,"Gauthier, F. and Jordan, A. and Krishnan, P. and Hassanshahi, B. and Süß, J.G. and Bae, S. and Lee, H.","Proceedings - 2020 IEEE/ACM International Conference on Technical Debt, TechDebt 2020",2020,Conference Paper,10.1145/3387906.3388623,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85093072518&doi=10.1145%2f3387906.3388623&partnerID=40&md5=f9adf35c16e5c82ddf487d78a2e009ac,No,
S427,Read,Accepted,[IC1] - The primary study presents or points to a software artifact that automates a task within at least one TD management activity.,,Exploring the relationship between refactoring and code debt indicators,"Refactoring, which aims to improve the internal structure of the software systems preserving their behavior, is the most common payment strategy for technical debt (TD) by removing the code smells. There exist many studies presenting code smell detection approaches/tools or investigating their impact on quality attributes. There are also studies that focus on refactoring techniques, their relation with quality attributes, tool supports, and opportunities for them. Although there are several studies addressing the gap between refactoring and TD indicators, the empirical evidence provided is still limited. In this study, we examine the distribution of 29 refactoring types among the different projects and their relation with code smells or faults. We explore the refactoring types that are most commonly performed together and other activities performed with refactorings. We conduct a large exploratory study with automatically detected 57,528 refactorings, 37,553 smells, 27,340 faults, and 134,812 commits of 33 Java projects. Results show that some refactoring types are more commonly applied by developers. Our analysis indicates that refactorings usually remove or do not affect the code smells, and this contradicts with the previous studies. Also, the commits in which refactoring(s) is performed are three times more fault inducing than those without refactoring. © 2022 John Wiley & Sons, Ltd.",TD Symptoms/Consequences,MSR Studies,"Halepmollasi, R. and Tosun, A.",Journal of Software: Evolution and Process,"2,022.00",Article,10.1002/smr.2447,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85126038476&doi=10.1002%2fsmr.2447&partnerID=40&md5=b06e256c549f7ab41334ece699d2e2d1,No,code smells;  refactoring;  software faults;  technical debt
S174,Read,Rejected,[EC2] - The study shows a theoretical artifact or do not provide a link to the artifact's repository;,The study does not point to any artifact,Early evaluation of technical debt impact on maintainability,"It is widely claimed that Technical Debt is related to quality problems being often produced by poor processes, lack of verification or basic incompetence. Several techniques have been proposed to detect Technical Debt in source code, as identification of modularity violations, code smells or grime buildups. These approaches have been used to empirically demonstrate the relation among Technical Debt indicators and quality harms. However, these works are mainly focused on programming level, when the system has already been implemented. There may also be sources of Technical Debt in non-code artifacts, e.g. requirements, and its identification may provide important information to move refactoring efforts to previous stages and reduce future Technical Debt interest. This paper presents an empirical study to evaluate whether modularity anomalies at requirements level are directly related to maintainability attributes affecting systems quality and increasing, thus, system's interest. The study relies on a framework that allows the identification of modularity anomalies and its quantification by using modularity metrics. Maintainability metrics are also used to assess dynamic maintainability properties. The results obtained by both sets of metrics are pairwise compared to check whether the more modularity anomalies the system presents, the less stable and more difficult to maintain it is. © 2018 Elsevier Inc.",Technical Debt,Case Study,"Conejero, J.M. and Rodríguez-Echeverría, R. and Hernández, J. and Clemente, P.J. and Ortiz-Caraballo, C. and Jurado, E. and Sánchez-Figueroa, F.",Journal of Systems and Software,2018,Article,10.1016/j.jss.2018.04.035,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85046356434&doi=10.1016%2fj.jss.2018.04.035&partnerID=40&md5=c8dfec977a146d8645d549a00c82a273,No,Empirical evaluation;  Maintainability;  Modularity anomalies;  Requirements;  Technical Debt indicator
S181,Read,Rejected,[EC2a] - The study provides a broken link,The link that was provided is broken,A case study of the effects of architecture debt on software evolution effort,"In large-scale software systems, the majority of defective files are architecturally connected, and the architecture connections usually exhibit design flaws, which are associated with higher change-proneness among files and higher maintenance costs. As software evolves with bug fixes, new features, or improvements, unresolved architecture design flaws can contribute to maintenance difficulties. The impact on effort due to architecture design flaws has been difficult to quantify and justify. In this paper, we conducted a case study where we identified flawed architecture relations and quantified their effects on maintenance activities. Using data from this project's source code and revision history, we identified file groups where files are architecturally connected and participated in flawed architecture designs, quantified the maintenance activities in the detected files, and assessed the penalty related to these files. © 2018 IEEE.",Technical Debt,Case Study,"Snipes, W. and Karlekar, S.L. and Mo, R.","Proceedings - 44th Euromicro Conference on Software Engineering and Advanced Applications, SEAA 2018",2018,Conference Paper,10.1109/SEAA.2018.00071,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85057154427&doi=10.1109%2fSEAA.2018.00071&partnerID=40&md5=9a99b68208938d885a3d1b1602d3276d,No,Software architecture;  Software maintenance;  Technical debt
S23,Read,Rejected,[EC2a] - The study provides a broken link,The link that was provided is broken,A Case Study in Locating the Architectural Roots of Technical Debt,"Our recent research has shown that, in large-scale software systems, defective files seldom exist alone. They are usually architecturally connected, and their architectural structures exhibit significant design flaws which propagate bugginess among files. We call these flawed structures the architecture roots, a type of technical debt that incurs high maintenance penalties. Removing the architecture roots of bugginess requires refactoring, but the benefits of refactoring have historically been difficult for architects to quantify or justify. In this paper, we present a case study of identifying and quantifying such architecture debts in a large-scale industrial software project. Our approach is to model and analyze software architecture as a set of design rule spaces (DRSpaces). Using data extracted from the project's development artifacts, we were able to identify the files implicated in architecture flaws and suggest refactorings based on removing these flaws. Then we built economic models of the before and (predicted) after states, which gave the organization confidence that doing the refactorings made business sense, in terms of a handsome return on investment. © 2015 IEEE.",Technical Debt,Case Study,"Kazman, R. and Cai, Y. and Mo, R. and Feng, Q. and Xiao, L. and Haziyev, S. and Fedak, V. and Shapochka, A.",Proceedings - International Conference on Software Engineering,2015,Conference Paper,10.1109/ICSE.2015.146,https://www.scopus.com/inward/record.uri?eid=2-s2.0-84943346141&doi=10.1109%2fICSE.2015.146&partnerID=40&md5=4c376181b738827b3df75b054e628c12,No,
S424,Read,Accepted,[IC1] - The primary study presents or points to a software artifact that automates a task within at least one TD management activity.,,Can Clean New Code Reduce Technical Debt Density?,"While technical debt grows in absolute numbers as software systems evolve over time, the density of technical debt (technical debt divided by lines of code) is reduced in some cases. This can be explained by either the application of refactorings or the development of new artifacts with limited Technical Debt. In this paper we explore the second explanation, by investigating the relation between the amount of Technical Debt in new code and the evolution of Technical Debt in the system. To this end, we compare the Technical Debt Density of new code with existing code, and we investigate which of the three major types of code changes (additions, deletions and modifications) is primarily responsible for changes in the evolution of Technical Debt density. Furthermore, we study whether there is a relation between code quality practices and the 'cleanness' of new code. To obtain the required data, we have performed a large-scale case study on twenty-seven open-source software projects by the Apache Software Foundation, analyzing 66,661 classes and 56,890 commits. The results suggest that writing 'clean' (or at least 'cleaner') new code can be an efficient strategy for reducing Technical Debt Density, and thus preventing software decay over time. The findings also suggest that projects adopting an explicit policy for quality improvement, e.g., through discussions on code quality in board meetings, are associated with a higher frequency of cleaner new code commits. Therefore, we champion the establishment of processes that monitor the density of Technical Debt of new code to control the accumulation of Technical Debt in a software system. © 1976-2012 IEEE.",Technical Debt,MSR Studies,"Digkas, G. and Chatzigeorgiou, A. and Ampatzoglou, A. and Avgeriou, P.",IEEE Transactions on Software Engineering,"2,022.00",Article,10.1109/TSE.2020.3032557,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85096110448&doi=10.1109%2fTSE.2020.3032557&partnerID=40&md5=2168c9c99ba99ccee2a7cb767344a2ae,No,case study;  clean code;  refactoring;  Technical debt
S28,Read,Rejected,[EC2] - The study shows a theoretical artifact or do not provide a link to the artifact's repository;,The study does not point to any artifact,Toward measuring defect debt and developing a recommender system for their prioritization,"Software development managers make a release decision with- out fully resolving the defects from current and previous releases due to tight deadlines. Deferring the defects would accumulate a tremendous amount of technical debt in the system. Typically, the defect debts are defined as the type of defect that should be fixed. However, due to competing priorities and the limited amount of time and resources, they would be postponed to the next release. In order to aid practitioners ,who make release decisions, to observe the amount of debt, there is a need for quantifying the defect debt. Software bug repositories roughly provide us with in- formation about the amount of time the defect debt exist in the system, the time the defects are resolved and the severity of the defect. We suggest categorizing the defect into the regular defect and debt prone defect by analyzing this information. Afterwards, we compare the regular defect and debt-prone defect to determine the principal, interest and interest probability of defect debt. We also propose the re- inforcement learning for scheduling which defect debt needs to be paid and when they need to be paid. Categories and Subject Descriptors H.4 [Information Systems Applications]: Miscellaneous; D.2.8 [Software Engineering]: Metrics|complexity measures, performance measures General Terms Theory. © 2015 for this paper by its authors.",Technical Debt,Case Study,"Akbarinasaji, S.",CEUR Workshop Proceedings,2015,Conference Paper,,https://www.scopus.com/inward/record.uri?eid=2-s2.0-84954530907&partnerID=40&md5=56ca7d9280dd1d9645db4994556d734a,No,Defect debt;  Reinforcement learning;  Software maintainability;  Technical debt measurement
S58,Read,Rejected,[IC1] - The primary study presents or points to a software artifact that automates a task within at least one TD management activity.,The study does not point to any artifact,Exploring the Presence of Technical Debt in Industrial GUI-Based Testware: A Case Study,"Technical debt (TD) is a concept used to describe a sub-optimal solution of a software artifact that negatively affects its comprehensibility, extendability and maintainability. As such, TD adversely affects the costs or quality associated with the artifact, which is also called interest. TD has through research been identified in all types of software artifacts, from architectural design to automated tests (Testware). However, research into testware technical debt (TTD) is limited and primarily focused on testing on lower level of system abstraction, i.e. unit-and integration tests, leaving a need for more TTD research on GUI-based testing. In this study we explore this gap in knowledge through an industrial case study at a Swedish avionics software development company. Four repositories are studied for the presence of TTD using expert interviews, semi-automated document analysis and automatic metric analysis. Results of the study provide initial support that the concept of TTD is applicable to GUI-based testware and show the presence of both TD items unique to GUI-based testware and items common to software. The implications of these results are that engineering best practices must be established for GUI-based testware to minimize TD interest. © 2016 IEEE.",Technical Debt,Case Study,"Alégroth, E. and Steiner, M. and Martini, A.","Proceedings - 2016 IEEE International Conference on Software Testing, Verification and Validation Workshops, ICSTW 2016",2016,Conference Paper,10.1109/ICSTW.2016.47,https://www.scopus.com/inward/record.uri?eid=2-s2.0-84992202683&doi=10.1109%2fICSTW.2016.47&partnerID=40&md5=85b1ad5098fd3376003b706e265fa3ce,No,GUI-based testing;  Industrial case study;  Technical debt;  Testware
S436,Read,Accepted,[IC1] - The primary study presents or points to a software artifact that automates a task within at least one TD management activity.,,Further investigation of the survivability of code technical debt items,"Context: Technical debt (TD) discusses the negative impact of sub-optimal decisions to cope with the need-for-speed in software development. Code technical debt items (TDI) are atomic elements of TD that can be observed in code artifacts. Empirical results on open-source systems demonstrated how code-smells, which are just one type of TDIs, are introduced and “survive” during release cycles. However, little is known about whether the results on the survivability of code-smells hold for other types of code TDIs (i.e., bugs and vulnerabilities) and in industrial settings. Goal: Understanding the survivability of code TDIs by conducting an empirical study analyzing two industrial cases and 31 open-source systems from Apache Foundation. Method: We analyzed 133,670 code TDIs (35,703 from the industrial systems) detected by SonarQube (in 193,196 commits) to assess their survivability using survivability models. Results: In general, code TDIs tend to remain and linger for long periods in open-source systems, whereas they are removed faster in industrial systems. Code TDIs that survive over a certain threshold tend to remain much longer, which confirms previous results. Our results also suggest that bugs tend to be removed faster, while code smells and vulnerabilities tend to survive longer. © 2022 The Authors. Journal of Software: Evolution and Process published by John Wiley & Sons Ltd.",Technical Debt,MSR Studies,"Zabardast, E. and Ebo Bennin, K. and Gonzalez-Huerta, J.",Journal of Software: Evolution and Process,"2,022.00",Article,10.1002/smr.2425,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85122929311&doi=10.1002%2fsmr.2425&partnerID=40&md5=1ac0c41558d6ca3ae64543c2de094b55,No,bugs;  code smells;  code technical debt items;  survivability;  vulnerabilities
S437,Read,Accepted,[IC1] - The primary study presents or points to a software artifact that automates a task within at least one TD management activity.,,Does it matter who pays back Technical Debt? An empirical study of self-fixed TD,"Context: Technical Debt (TD) can be paid back either by those that incurred it or by others. We call the former self-fixed TD, and it can be particularly effective, as developers are experts in their own code and are well-suited to fix the corresponding TD issues. Objective: The goal of our study is to investigate self-fixed technical debt, especially the extent in which TD is self-fixed, which types of TD are more likely to be self-fixed, whether the remediation time of self-fixed TD is shorter than non-self-fixed TD and how development behaviors are related to self-fixed TD. Method: We report on an empirical study that analyzes the self-fixed issues of five types of TD (i.e., Code, Defect, Design, Documentation and Test), captured via static analysis, in more than 44,000 commits obtained from 20 Python and 16 Java projects of the Apache Software Foundation. Results: The results show that about half of the fixed issues are self-fixed and that the likelihood of contained TD issues being self-fixed is negatively correlated with project size, the number of developers and total issues. Moreover, there is no significant difference of the survival time between self-fixed and non-self-fixed issues. Furthermore, developers are more keen to pay back their own TD when it is related to lower code level issues, e.g., Defect Debt and Code Debt. Finally, developers who are more dedicated to or knowledgeable about the project contribute to a higher chance of self-fixing TD. Conclusions: These results can benefit both researchers and practitioners by aiding the prioritization of TD remediation activities and refining strategies within development teams, and by informing the development of TD management tools. © 2021",Technical Debt,MSR Studies,"Tan, J. and Feitosa, D. and Avgeriou, P.",Information and Software Technology,"2,022.00",Article,10.1016/j.infsof.2021.106738,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85118484186&doi=10.1016%2fj.infsof.2021.106738&partnerID=40&md5=09f983845293611bb95aab432bdf002a,No,Human factors;  Python;  Self-fixed issues;  Static analysis;  Technical Debt