,id,title,abstract,study-type,author,author_type,year,venue,venue_type,link,reference,objective,artifacts
0,S1,CCFinder: A Multilinguistic Token-Based Code Clone Detection System for Large Scale Source Code,"A code clone is a code portion in source files that is identical or similar to another. Since code clones are believed to reduce the maintainability of software, several code clone detection techniques and tools have been Proposed. This paper Proposes a new clone detection technique, which consists of the transformation of input source text and a token-by-token comparison. For its implementation with several Useful optimization techniques, we have developed a tool, named CCFinder (Code Clone Finder), which extracts code clones in C, C++, Java, COBOL and other source files. In addition, metrics for the code clones have been developed. In order to evaluate the Usefulness of CCFinder and metrics, we conducted several case studies where we applied the new tool to the source code of JDK, FreeBSD, NetBSD, Linux, and many other systems. As a result, CCFinder has effectively found clones and the metrics have been able to effectively identify the characteristics of the systems. In addition, we have Compared the Proposed technique with other clone detection techniques.",Propose,"Toshihiro Kamiya, Member
Shinji Kusumoto
Katsuro Inoue",Academia,"2,002.00",IEEE TRANSACTIONS ON SOFTWARE ENGINEERING,Journal,,"@article{Kamiya2002CCFinderAM,
  title={CCFinder: A Multilinguistic Token-Based Code Clone Detection System for Large Scale Source Code},
  author={Toshihiro Kamiya and Shinji Kusumoto and Katsuro Inoue},
  journal={IEEE Trans. Software Eng.},
  year={2002},
  volume={28},
  pages={654-670}
}",,CCFinderX
1,S2,A Catalogue of Lightweight Visualizations to Support Code Smell Inspection,"Preserving the integrity of software systems is essential in ensuring future product success. Commonly, companies allocate only
a limited budget toward perfective maintenance and instead pressure developers to focus on implementing new features. Traditional
techniques, such as code inspection, consume many staff resources
and attention from developers. Metrics automate the process of
checking for problems but produce voluminous, imprecise, and incongruent results. An opportunity exists for visualization to assist
where automated measures have failed; however, current software
visualization techniques only handle the voluminous aspect of data
but fail to address imprecise and incongruent aspects. In this paper, we describe several techniques for visualizing possible defects
reported by automated inspection tools. We Propose a catalogue
of lightweight visualizations that assist reviewers in weeding out
false positives. We implemented the visualizations in a tool called
NOSEPRINTS and present a case study on several commercial systems and open source applications in which we examined the impact of our tool on the inspection process.",Use,"Chris Parnin
Carsten Gorg
Ogechi Nnadi",Academia,"2,008.00",ACM symposium on Software visualization,Conference,https://doi.org/10.1145/1409720.1409733,"@INPROCEEDINGS{Parnin2008-mo,
  title           = ""A catalogue of lightweight visualizations to support code
                     smell inspection"",
  booktitle       = ""Proceedings of the 4th {ACM} symposium on Software
                     visuallization - {SoftVis} '08"",
  author          = ""Parnin, Chris and G{\""o}rg, Carsten and Nnadi, Ogechi"",
  publisher       = ""ACM Press"",
  year            =  2008,
  address         = ""New York, New York, USA"",
  conference      = ""the 4th ACM symposium"",
  location        = ""Ammersee, Germany""
}
",,Gendarme
2,S3,Metrics Functions for Kanban Guards,"Agile and lean approaches favor self-organizing teams
that Use low-tech solutions for communicating and negotiating project content and scope in software projects. We
consider this approach to have many benefits, but we also
recognize that there is information in software projects that
does not readily lend itself to low-tech types of visualization. Different characteristics of the code base is one such
example. In this paper, we outline metrics functions that can
take advantage of more advanced information of the development artifacts and provide the lean or agile team with
partially automated decision support for quality assurance
actions",Cite,"Jeanette Heidenberg
Ivan Porres",Academia,"2,010.00",International Conference and Workshops on Engineering of Computer-Based Systems,Conference,http://doi.org/10.1109/ECBS.2010.43,"@inproceedings{Heidenberg2010,
  doi = {10.1109/ecbs.2010.43},
  url = {https://doi.org/10.1109/ecbs.2010.43},
  year = {2010},
  publisher = {{IEEE}},
  author = {Jeanette Heidenberg and Ivan Porres},
  title = {Metrics Functions for Kanban Guards},
  booktitle = {2010 17th {IEEE} International Conference and Workshops on Engineering of Computer Based Systems}
}","In this paper, we outline metrics functions that can take advantage of more advanced information of the development artifacts and provide the lean or agile team with partially automated decision support for quality assurance actions","STAN
Resource standard metrics"
3,S4,Building Empirical Support for Automated Code Smell Detection,"Identifying refactoring opportunities in software systems is an important activity in today's agile development environments. The concept of code smells has been Proposed to characterize different types of design shortcomings in code. Additionally, metric-based detection algorithms claim to identify the ""smelly"" components automatically. This paper presents results for an empirical study performed in a commercial environment. The study investigates the way professional software developers detect god class code smells, then Compares these results to automatic classification. The results show that, even though the subjects perceive detecting god classes as an easy task, the agreement for the classification is low. Misplaced methods are a strong driver for letting subjects identify god classes as such. Earlier Proposed metric-based detection approaches performed well Compared to the human classification. These results lead to the conclusion that an automated metric-based pre-selection decreases the effort spent on manual code inspections. Automatic detection accompanied by a manual review increases the overall confidence in the results of metric-based classifiers.",Propose,"Jan Schumacher
Nico Zazworka
Forrest Shull
Carolyn Seaman
Michele Shaw",Academia,"2,010.00",International Symposium on Empirical Software Engineering and Measurement,Conference,,"@inproceedings{10.1145/1852786.1852797,
author = {Schumacher, Jan and Zazworka, Nico and Shull, Forrest and Seaman, Carolyn and Shaw, Michele},
title = {Building Empirical Support for Automated Code Smell Detection},
year = {2010},
isbn = {9781450300391},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/1852786.1852797},
doi = {10.1145/1852786.1852797},
booktitle = {Proceedings of the 2010 ACM-IEEE International Symposium on Empirical Software Engineering and Measurement},
articleno = {8},
numpages = {10},
keywords = {empirical study, code smells, maintainability, code inspection, god class},
location = {Bolzano-Bozen, Italy},
series = {ESEM '10}
}",,CodeVizard
4,S5,The SQALE Quality and Analysis Models for Assessing the Quality of Ada Source Code,"This article presents the quality and analysis model of the SQALE assessment method of software source code. It explains how an Ada quality model compliant to SQALE is implemented and the results of its application to selected software, and how the Use of Ada reduces the quality debt unlike many other technologies.",Propose,"Thierry Coq
Jean-Pierre Rosen",Industry,"2,011.00",International Conference on Reliable Software Technologies,Conference,https://doi.org/10.1007/978-3-642-21338-0_5,"@incollection{Coq_2011,
	doi = {10.1007/978-3-642-21338-0_5},
	url = {https://doi.org/10.1007%2F978-3-642-21338-0_5},
	year = 2011,
	publisher = {Springer Berlin Heidelberg},
	pages = {61--74},
	author = {Thierry Coq and Jean-Pierre Rosen},
	title = {The {SQALE} Quality and Analysis Models for Assessing the Quality of Ada Source Code},
	booktitle = {Reliable Software Technologies - Ada-Europe 2011}
}","This article presents the quality and analysis model of the SQALE assessment method of software source code. It explains how an Ada quality model compliant to SQALE is implemented and the results of its application to selected software, and how the Use of Ada reduces the quality debt unlike many other technologies.",AdaControl
5,S6,Automatic detection of bad smells in code: An experimental assessment,"Code smells are structural characteristics of software that may indicate a code or design problem that makes software hard to evolve and maintain, and may trigger refactoring of code. Recent research is active in defining automatic detection tools to help humans in finding smells when code size becomes unmanageable for manual review. Since the definitions of code smells are informal and subjective, assessing how effective code smell detection tools are is both important and hard to achieve. This paper reviews the current panorama of the tools for automatic code smell detection. It defines research questions about the consistency of their responses, their ability to expose the regions of code most affected by structural decay, and the relevance of their responses with respect to future software evolution. It gives answers to them by analyzing the output of four representative code smell detectors applied to six different versions of GanttProject, an open source system written in Java. The results of these experiments cast light on what current code smell detection tools are able to do and what the relevant areas for further improvement are.",Compare,"Francesca Arcelli Fontanaa
Pietro Braionea
Marco Zanonia",Academia,"2,011.00",Journal of Object Technology,Journal,,"@article{ArcelliFontana2012,
  doi = {10.5381/jot.2012.11.2.a5},
  url = {https://doi.org/10.5381/jot.2012.11.2.a5},
  year = {2012},
  publisher = {{AITO} - Association Internationale pour les Technologies Objets},
  volume = {11},
  number = {2},
  pages = {5:1},
  author = {Francesca Arcelli Fontana and Pietro Braione and Marco Zanoni},
  title = {Automatic detection of bad smells in code: An experimental assessment.},
  journal = {The Journal of Object Technology}
}",,Checkstyle
6,S7,Detecting Software Modularity Violations,"This paper presents Clio, an approach that detects modularity violations, which can caUse software defects, modularity decay, or expensive refactorings. Clio computes the discrepancies between how components should change together based on the modular structure, and how components actually change together as revealed in version history. We evaluated Clio using 15 releases of Hadoop Common and 10 releases of Eclipse JDT. The results show that hundreds of violations identified using Clio were indeed recognized as design problems or refactored by the developers in later versions. The identified violations exhibit multiple symptoms of poor design, some of which are not easily detectable using existing approaches.",Propose,,Academia,"2,011.00",International Conference on Software Engineering,Conference,,"@INPROCEEDINGS{6032480,  author={Wong, Sunny and Cai, Yuanfang and Kim, Miryung and Dalton, Michael},  booktitle={2011 33rd International Conference on Software Engineering (ICSE)},   title={Detecting software modularity violations},   year={2011},  volume={},  number={},  pages={411-420},  doi={10.1145/1985793.1985850}}",,clio
7,S8,Value-Based Technical Debt Model and Its Application,"The majority of software development today is being
conducted in a value-neutral setting, where each functionality
once being locked down as a part of software release is treated
as equally important. This limited visibility of the real value
perceived by customer inside software engineering
organizational departments has significant consequences in the
way the technical quality of the product is being evaluated and
maintained. The relentless pursuit of efficiency in the software
engineering domain requires a broader view of long-term
economical consequences of any product-related decision.
Technical debt typically is an internalized (engineering-based)
assessment. We Propose to expand the understanding and
visibility of the technical debt by introducing a model driven
approach to provide the means to assess the technical debt
impact on perceived product quality parameters, such as
codebase/design and architecture, engineering productivity,
and finally the company’s business return on the engineering
investment. Furthermore, the case studies presented in this
paper are focUsed on the application of the technical debt
concept—how it could be identified, measured and what are
the consequences of not managing it. The key principles of this
concept were proved to be valid while evaluating the
development of a major software system release. Finally, the
need for balanced view for the technical debt management
strategy is discussed, to ensure pay-off benefits are aligned
with time-to-market expectations",Propose,"Marek G. Stochel
Mariusz R. Wawrowski
Magdalena Rabiej",Industry,"2,012.00",International Conference on Software Engineering Advances,Conference,,"@inproceedings{Stochel2012ValueBasedTD,
  title={Value-Based Technical Debt Model and Its Application},
  author={Marek Grzegorz Stochel and Mariusz R. Wawrowski and M. Rabiej},
  booktitle={ICSEA 2012},
  year={2012}
}","We Propose to expand the understanding and  visibility of the technical debt by introducing a model driven  approach to provide the means to assess the technical debt  impact on perceived product quality parameters, such as  codebase/design and architecture, engineering productivity,  and finally the company’s business return on the engineering 
 investment.","PMD
Checkstyle
Cobertura
FXCop
Klocwork
Sonar TD Plugin"
8,S9,Estimating the Principal of an Application’s Technical Debt,"This article characterizes technical debt across 700 business applications, comprising 357 MLOC. These applications were analyzed against more than 1,200 rules of good architectural and coding practice. The authors present a formula with adjustable parameters for estimating the principal of technical debt from structural quality data.",Use,"Bill Curtis
Jay Sappidi
Alexandra Szynkarski",Industry,"2,012.00",IEEE Software,Journal,https://doi.org/10.1109/ms.2012.156,"@article{Curtis2012,
  doi = {10.1109/ms.2012.156},
  url = {https://doi.org/10.1109/ms.2012.156},
  year = {2012},
  month = nov,
  publisher = {Institute of Electrical and Electronics Engineers ({IEEE})},
  volume = {29},
  number = {6},
  pages = {34--42},
  author = {Bill Curtis and Jay Sappidi and Alexandra Szynkarski},
  title = {Estimating the Principal of an Application{\textquotesingle}s Technical Debt},
  journal = {{IEEE} Software}
}","A formula with adjustable parameters can
help in estimating the principal of technical
debt from structural quality data",CAST
9,S10,A Threshold Based Approach to Technical Debt,"Nearly two decades ago, Ward Cunningham introduced us to the term ""technical debt"" as a means of describing the long term costs associated with a suboptimal software design and implementation. For most programs, especially those with a large legacy code baseline, achieving zero absolute debt is an unnecessary and unrealistic goal. It is important to recall that a primary reason for managing and eliminating debt is to drive down maintenance costs and to reduce defects. A sufficiently low, manageable level of debt can minimize the long-term impact, i.e., ""low debt interest payments"". In this article, we define an approach for establishing program specific thresholds to define manageable levels of technical debt.",Propose,Robert J. Eisenberg,Industry,"2,012.00",ACM Software Engineering Notes,Journal,https://doi.org/10.1145/2108144.2108151,"@article{Eisenberg_2012,
	doi = {10.1145/2108144.2108151},
	url = {https://doi.org/10.1145/2108144.2108151},
	year = 2012,
	month = {apr},
	publisher = {Association for Computing Machinery ({ACM})},
	volume = {37},
	number = {2},
	pages = {1--6},
	author = {Robert J. Eisenberg},
	title = {A threshold based approach to technical debt},
	journal = {{ACM} {SIGSOFT} Software Engineering Notes}
}
","In this article, we define an approach for establishing program specific thresholds to define
manageable levels of technical debt.",SonarQube
10,S11,The SQALE Method for Evaluating Technical Debt,This paper presents the SQALE (Software Quality Assessment Based on Lifecycle Expectations) method. We describe its Quality Model and Analysis Model which is Used to estimate the Quality and the Technical Debt of an application source code. We provide recommendations and guidelines for using the SQALE indicators in order to analyse the structure and the impact of the Technical Debt.,Propose,Jean-Louis Letouzey,Industry,"2,012.00",International Workshop on Managing Technical Debt,Workshop,https://dl.acm.org/doi/10.5555/2666036.2666042,"@inproceedings{,
author = {Letouzey, Jean-Louis},
title = {The SQALE Method for Evaluating Technical Debt},
year = {2012},
isbn = {9781467317498},
publisher = {IEEE Press},
abstract = {This paper presents the SQALE (Software Quality Assessment Based on Lifecycle Expectations) method. We describe its Quality Model and Analysis Model which is Used to estimate the Quality and the Technical Debt of an application source code. We provide recommendations and guidelines for using the SQALE indicators in order to analyse the structure and the impact of the Technical Debt.},
booktitle = {Proceedings of the Third International Workshop on Managing Technical Debt},
pages = {31–36},
numpages = {6},
keywords = {technical debt, source code, quality model, quality, analysis model, SQALE},
location = {Zurich, Switzerland},
series = {MTD '12}
}","This paper presents the SQALE (Software
Quality Assessment Based on Lifecycle Expectations) method.
We describe its Quality Model and Analysis Model which is
Used to estimate the Quality and the Technical Debt of an
application source code.",SQALE plugin of the Sonar
11,S12,Using Automatic Static Analysis to Identify Technical Debt,"The technical debt (TD) metaphor describes a tradeoff between short-term and long-term goals in software development. Developers, in such situations, accept compromises in one dimension (e.g. maintainability) to meet an urgent demand in another dimension (e.g. delivering a release on time). Since TD produces interests in terms of time spent to correct the code and accomplish quality goals, accumulation of TD in software systems is dangerous becaUse it could lead to more difficult and expensive maintenance. The research presented in this paper is focUsed on the usage of automatic static analysis to identify Technical Debt at code level with respect to different quality dimensions. The methodological approach is that of Empirical Software Engineering and both past and current achieved results are presented, focusing on functionality, efficiency and maintainability.",Use,Antonio Vetrò,Academia,"2,012.00",International Conference on Software Engineering - Doctoral Symposium,Conference,https://doi.org/10.1109/ICSE.2012.6227226,"@inproceedings{Vetro2012,
  doi = {10.1109/icse.2012.6227226},
  url = {https://doi.org/10.1109/icse.2012.6227226},
  year = {2012},
  month = jun,
  publisher = {{IEEE}},
  author = {Antonio Vetro},
  title = {Using automatic static analysis to identify technical debt},
  booktitle = {2012 34th International Conference on Software Engineering ({ICSE})}
}","The research  presented in this paper is focUsed on the usage of automatic
static analysis to identify Technical Debt at code level with
respect to different quality dimensions.","FindBugs
Resharper"
12,S13,"Estimating the Size, Cost, and Types of Technical Debt",This study summarizes results of a study of Technical Debt across 745 business applications comprising 365 million lines of code collected from 160 companies in 10 industry segments. These applications were submitted to a static analysis that evaluates quality within and across application layers that may be coded in different languages. The analysis consists of evaluating the application against a repository of over 1200 rules of good architectural and coding practice. A formula for estimating Technical Debt with adjustable parameters is presented. Results are presented for Technical Debt across the entire sample as well as for different programming languages and quality factors.,Use,"Bill Curtis
Jay Sappidi
Alexandra Szynkarski",Industry,"2,012.00",International Workshop on Managing Technical Debt,Workshop,https://doi.org/10.1109/MTD.2012.6226000,"@inproceedings{Curtis2012,
  doi = {10.1109/mtd.2012.6226000},
  url = {https://doi.org/10.1109/mtd.2012.6226000},
  year = {2012},
  month = jun,
  publisher = {{IEEE}},
  author = {Bill Curtis and Jay Sappidi and Alexandra Szynkarski},
  title = {Estimating the size,  cost,  and types of Technical Debt},
  booktitle = {2012 Third International Workshop on Managing Technical Debt ({MTD})}
}",,CAST
13,S14,"ConcernReCS: Finding Code Smells in Software Aspectization
","Refactoring object-oriented (OO) code to aspects is an error-prone task. To support this task, this paper presents ConcernReCS, an Eclipse plug-in to help developers to avoid recurring mistakes during software aspectization. Based on a map of concerns, ConcernReCS automatically finds and reports error-prone scenarios in OO source code; i.e., before the concerns have been refactored to aspects.",Propose,"Péricles Alves
Diogo Santana
Eduardo Figueiredo",Academia,"2,012.00",International Conference on Software Engineering,Conference,10.1109/ICSE.2012.6227063,"@inproceedings{Alves_2012,
	doi = {10.1109/icse.2012.6227063},
	url = {https://doi.org/10.1109%2Ficse.2012.6227063},
	year = 2012,
	month = {jun},
	publisher = {{IEEE}},
	author = {Pericles Alves and Diogo Santana and Eduardo Figueiredo},
	title = {{ConcernReCS}: Finding code smells in software aspectization},
	booktitle = {2012 34th International Conference on Software Engineering ({ICSE})}
}
",,
14,S15,Assessing technical debt by identifying design flaws in software systems,"Tough time-to-market constraints and unanticipated integration or evolution issues lead to design tradeoffs that usually caUse flaws in the structure of a software system. Thus, maintenance costs grow significantly. The impact of these design decisions, which provide short-term benefits at the expense of the system’s design integrity, is usually referred to as technical debt. In this paper, I Propose a novel framework for assessing technical debt using a technique for detecting design flaws, i.e., specific violations of well-established design principles and rules. To make the framework comprehensive and balanced, it is built on top of a set of metrics-based detection rules for well-known design flaws that cover all of the major aspects of design such as coupling, complexity, and encapsulation. I demonstrate the effectiveness of the framework by assessing the evolution of technical debt symptoms over a total of 63 releases of two popular Eclipse® projects. The case study shows how the framework can detect debt symptoms and past refactoring actions. The experiment also reveals that in the absence of such a framework, restructuring actions are not always coherent and systematic, not even when performed by very experienced developers.",Propose,R. Marinescu,Academia,"2,012.00",IBM Journal of Research and Development,Journal,,"@ARTICLE{6261578,  author={Marinescu, R.},  journal={IBM Journal of Research and Development},   title={Assessing technical debt by identifying design flaws in software systems},   year={2012},  volume={56},  number={5},  pages={9:1-9:13},  doi={10.1147/JRD.2012.2204512}}",,SonarQube
15,S16,"Code Smell Detecting
Tool and Code Smell-Structure Bug Relationship
","This paper Proposes an approach for detecting the so- called bad smells in software known as Code Smell. In considering software bad smells, object-oriented software metrics were Used to detect the source code whereby Eclipse Plugins were developed for detecting in which location of Java source code the bad smell appeared so that software refactoring could then take place. The detected source code was classified into 7 types: Large Class, Long Method, Parallel Inheritance Hierarchy, Long Parameter List, Lazy Class, Switch Statement, and Data Class. This work conducted analysis by using 323 java classes to ascertain the relationship between the code smell and structural defects of software by using the data mining techniques of Naive Bayes and Association Rules. The result of the Naive Bayes test showed that the Lazy Class caUsed structural defects in DLS, DE, and Se. Also, Data Class caUsed structural defects in UwF, DE, and Se, while Long Method, Large Class, Data Class, and Switch Statement caUsed structural defects in UwF and Se. Finally, Parallel Inheritance Hierarchy caUsed structural defects in Se. However, Long Parameter List caUsed no structural defects whatsoever. The results of the Association Rules test found that the Lazy Class code smell caUsed structural defects in DLS and DE, which corresponded to the results of the Naive Bayes test.",Propose,"Phongphan Danphitsanuphan
Thanitta Suwantada 
",Academia,"2,012.00",Spring Congress on Engineering and Technology,Conference,,"@INPROCEEDINGS{6342082,  author={Danphitsanuphan, Phongphan and Suwantada, Thanitta},  booktitle={2012 Spring Congress on Engineering and Technology},   title={Code Smell Detecting Tool and Code Smell-Structure Bug Relationship},   year={2012},  volume={},  number={},  pages={1-5},  doi={10.1109/SCET.2012.6342082}}",,Findbugs
16,S17,Supporting the Identification of Architecturally-Relevant Code Anomalies,"Code anomalies are likely to be critical to the systems' maintainability when they are related to architectural problems. Many tools have been developed to support the identification of code anomalies. However, those tools are restricted to only analyze source code structure and identify individual anomaly occurrences. These limitations are the main reasons why state-of-art tools are often unable to identify architecturally-relevant code anomalies, i.e. those related to architectural problems. To overcome these shortcomings we Propose SCOOP, a tool that includes: (i) architecture-code traces in the analysis of the source code, and (ii) exploits relationships between multiple occurrences of code anomalies to detect the architecturally-relevant ones. Our preliminary evaluation indicated that SCOOP was able to detect anomalous code elements related to 293 out of 368 architectural problems found in 3 software systems.",Propose,,Academia,"2,012.00",International Conference on Software Maintenance,Conference,,"@INPROCEEDINGS{6405348,  author={Macia, Isela and Arcoverde, Roberta and Cirilo, Elder and Garcia, Alessandro and von Staa, Arndt},  booktitle={2012 28th IEEE International Conference on Software Maintenance (ICSM)},   title={Supporting the identification of architecturally-relevant code anomalies},   year={2012},  volume={},  number={},  pages={662-665},  doi={10.1109/ICSM.2012.6405348}}",,scoop
17,S18,"A multiple case study of design pattern decay, grime, and rot in evolving software systems","Software designs decay as systems, Uses, and operational environments evolve. Decay can involve the design patterns Used to structure a system. Classes that participate in design pattern realizations accumulate grime—non-pattern-related code. Design pattern realizations can also rot, when changes break the structural or functional integrity of a design pattern. Design pattern rot can prevent a pattern realization from fulfilling its responsibilities, and thus represents a fault. Grime buildup does not break the structural integrity of a pattern but can reduce system testability and adaptability. This research examined the extent to which software designs actually decay, rot, and accumulate grime by studying the aging of design patterns in three successful object-oriented systems. We generated UML models from the three implementations and employed a multiple case study methodology to analyze the evolution of the designs. We found no evidence of design pattern rot in these systems. However, we found considerable evidence of pattern decay due to grime. Dependencies between design pattern components increased without regard for pattern intent, reducing pattern modularity, and decreasing testability and adaptability. The study of decay and grime showed that the grime that builds up around design patterns is mostly due to increases in coupling.",Use,"Clemente Izurieta
James M. Bieman",Academia,"2,013.00",Software Qual J,Journal,https://doi.org/10.1007/s11219-012-9175-x,"@article{Izurieta2012,
  doi = {10.1007/s11219-012-9175-x},
  url = {https://doi.org/10.1007/s11219-012-9175-x},
  year = {2012},
  month = feb,
  publisher = {Springer Science and Business Media {LLC}},
  volume = {21},
  number = {2},
  pages = {289--323},
  author = {Clemente Izurieta and James M. Bieman},
  title = {A multiple case study of design pattern decay,  grime,  and rot in evolving software systems},
  journal = {Software Quality Journal}
}","This research examined the extent to which software designs actually decay, rot, and accumulate grime by studying the aging of design patterns in three successful object-oriented systems.","JDepends
JavaNCSS"
18,S19,Visualizing and Managing Technical Debt in Agile Development: an Experience Report,"This paper reports the experience of an architecture team of a software development department with 25 agile teams in supporting technical decisions regarding technical practices. The main motivation to Use technical debt metaphor was its acknowledged potential in driving software development and maintenance decisions, especially those long term maintenance tradeoffs which are usually less visible to developers and decision makers in general. We Propose the Use of a ""technical debt board"" with main technical debt categories to manage and visualize the high-level debt, combined with tools to measure it at low-level (software metrics and other kind of static analysis). We have found that our approach improved the teams’ awareness about the technical debt, stimulated a beneficial competition between teams towards the debt payment and enhanced the communication regarding technical decisions.",Propose,"Paulo Sérgio Medeiros dos Santos
Amanda Varella
Cristine Ribeiro Dantas
Daniel Beltrão Borges",Both,"2,013.00",International Conference on Agile Software Development,Conference,https://doi.org/10.1007/978-3-642-38314-4_9,"@incollection{dos_Santos_2013,
	doi = {10.1007/978-3-642-38314-4_9},
	url = {https://doi.org/10.1007%2F978-3-642-38314-4_9},
	year = 2013,
	publisher = {Springer Berlin Heidelberg},
	pages = {121--134},
	author = {Paulo S{\'{e}}rgio Medeiros dos Santos and Amanda Varella and Cristine Ribeiro Dantas and Daniel Beltr{\~{a}}o Borges},
	title = {Visualizing and Managing Technical Debt in Agile Development: An Experience Report},
	booktitle = {Lecture Notes in Business Information Processing}
}","We Propose the Use of a ""technical debt board"" with main technical debt categories
to manage and visualize the high-level debt, combined with tools to measure it
at low-level (software metrics and other kind of static analysis).","SonarQube
PMD
Findbugs
Cobertura
Checkstyle"
19,S20,Comparing four approaches for technical debt identification,"Software systems accumulate technical debt (TD) when short-term goals in software development are traded for long-term goals (e.g., quick-and-dirty implementation to reach a release date versus a well-refactored implementation that supports the long-term health of the project). Some forms of TD accumulate over time in the form of source code that is difficult to work with and exhibits a variety of anomalies. A number of source code analysis techniques and tools have been Proposed to potentially identify the code-level debt accumulated in a system. What has not yet been studied is if using multiple tools to detect TD can lead to benefits, that is, if different tools will flag the same or different source code components. Further, these techniques also lack investigation into the symptoms of TD “interest” that they lead to. To address this latter question, we also investigated whether TD, as identified by the source code analysis techniques, correlates with interest payments in the form of increased defect- and change-proneness. Comparing the results of different TD identification approaches to understand their commonalities and differences and to evaluate their relationship to indicators of future TD “interest.” We selected four different TD identification techniques (code smells, automatic static analysis issues, grime buildup, and Modularity violations) and applied them to 13 versions of the Apache Hadoop open source software project. We collected and aggregated statistical measures to investigate whether the different techniques identified TD indicators in the same or different classes and whether those classes in turn exhibited high interest (in the form of a large number of defects and higher change-proneness). The outputs of the four approaches have very little overlap and are therefore Citeing to different problems in the source code. Dispersed Coupling and Modularity violations were co-located in classes with higher defect-proneness. We also observed a strong relationship between Modularity violations and change-proneness. Our main contribution is an initial overview of the TD landscape, showing that different TD techniques are loosely coupled and therefore indicate problems in different locations of the source code. Moreover, our proxy interest indicators (change- and defect-proneness) correlate with only a small subset of TD indicators.",Compare,"Nico Zazworka
Antonio Vetro
Clemente Izurieta
Sunny Wong
Yuanfang Cai
Carolyn Seaman
Forrest Shull",Academia,"2,013.00",Software Quality Journal,Journal,https://doi.org/10.1007/s11219-013-9200-8,"@article{Zazworka_2013,
	doi = {10.1007/s11219-013-9200-8},
	url = {https://doi.org/10.1007%2Fs11219-013-9200-8},
	year = 2013,
	month = {apr},
	publisher = {Springer Science and Business Media {LLC}},
	volume = {22},
	number = {3},
	pages = {403--426},
	author = {Nico Zazworka and Antonio Vetro' and Clemente Izurieta and Sunny Wong and Yuanfang Cai and Carolyn Seaman and Forrest Shull},
	title = {Comparing four approaches for technical debt identification},
	journal = {Software Quality Journal}
}","To address this latter question, we also investigated whether TD, as identified by the source code analysis techniques, correlates with interest payments in the form of increased defect- and change-proneness. Comparing the results of different TD identification approaches to understand their commonalities and differences and to evaluate their relationship to indicators of future TD ‘‘interest.’’","CLIO
FindBugs
Codevizard"
20,S21,Exploring Software Supply Chains From a Technical Debt Perspective,Software development has evolved from software development organizations building custom solutions for every need and creating a backlog of applications needed by Users to specialized organizations producing components that are supplied to other software development organizations to speed the development of their software products. Our objective is to illustrate how a manager might Use supply chain information to evaluate software being considered for inclusion in a product. We investigated the Eclipse platform code to illustrate analysis methods that produce information of Use to decision makers. The technical debt of the software pieces was measured using the Technical Debt plug-in to Sonar as one input into the evaluation of supply chain quality. The dependency graphs of “Uses” relationships among files were analyzed using graph metrics such as betweenness centrality. There was a statistically significant moderate correlation between the technical debt for a file and the betweenness centrality for that file. This relationship is Used as the basis for a heuristic approach to forming advice to a development manager regarding which assets to acquire.,Use,"J. Yates Monteith
John D. McGregor",Academia,"2,013.00",International Workshop on Managing Technical Debt,Workshop,https://doi.org/10.1109/MTD.2013.6608676,"@inproceedings{Monteith2013,
  doi = {10.1109/mtd.2013.6608676},
  url = {https://doi.org/10.1109/mtd.2013.6608676},
  year = {2013},
  month = may,
  publisher = {{IEEE}},
  author = {J. Yates Monteith and John D. McGregor},
  title = {Exploring software supply chains from a technical debt perspective},
  booktitle = {2013 4th International Workshop on Managing Technical Debt ({MTD})}
}","We investigated the Eclipse platform code to illustrate analysis
methods that produce information of Use to decision makers.
The technical debt of the software pieces was measured using
the Technical Debt plug-in to Sonar as one input into the
evaluation of supply chain quality.","Sonar
Understand
Cytoscape"
21,S22,Generating Precise Dependencies for Large Software,"Intra- and inter-module dependencies can be a significant source of technical debt in the long-term software development, especially for large software with millions of lines of code. This paper designs and implements a precise and scalable tool that extracts code dependencies and their utilization for large C/C++ software projects. The tool extracts both symbol-level and module-level dependencies of a software system and identifies potential underutilized and inconsistent dependencies. Such information Cites to potential refactoring opportunities and help developers perform large-scale refactoring tasks.",Propose,"Pei Wang
Jinqiu Yang
Lin Tan
Robert Kroeger
J. David Morgenthaler",Both,"2,013.00",International Workshop on Managing Technical Debt,Workshop,https://doi.org/10.1109/mtd.2013.6608678,"@inproceedings{Wang2013,
  doi = {10.1109/mtd.2013.6608678},
  url = {https://doi.org/10.1109/mtd.2013.6608678},
  year = {2013},
  month = may,
  publisher = {{IEEE}},
  author = {Pei Wang and Jingiu Yang and Lin Tan and Robert Kroeger and J. David Morgenthaler},
  title = {Generating precise dependencies for large software},
  booktitle = {2013 4th International Workshop on Managing Technical Debt ({MTD})}
}","This paper designs and implements a precise and scalable
tool that extracts code dependencies and their utilization for

large C/C++ software projects.","CodeSurfer
CppDepend"
22,S23,"To what extent can maintenance problems be predicted by code smell
detection? – An empirical study","Context
Code smells are indicators of poor coding and design choices that can caUse problems during software maintenance and evolution.

Objective
This study is aimed at a detailed investigation to which extent problems in maintenance projects can be predicted by the detection of currently known code smells.

Method
A multiple case study was conducted, in which the problems faced by six developers working on four different Java systems were registered on a daily basis, for a period up to four weeks. Where applicable, the files associated to the problems were registered. Code smells were detected in the pre-maintenance version of the systems, using the tools Borland Together and InCode. In-depth examination of quantitative and qualitative data was conducted to determine if the observed problems could be explained by the detected smells.

Results
From the total set of problems, roughly 30% percent were related to files containing code smells. In addition, interaction effects were observed amongst code smells, and between code smells and other code characteristics, and these effects led to severe problems during maintenance. Code smell interactions were observed between collocated smells (i.e., in the same file), and between coupled smells (i.e., spread over multiple files that were coupled).

Conclusions
The role of code smells on the overall system maintainability is relatively minor, thus complementary approaches are needed to achieve more comprehensive assessments of maintainability. Moreover, to improve the explanatory power of code smells, interaction effects amongst collocated smells and coupled smells should be taken into account during analysis.",Use,"Aiko Yamashita
Leon Moonen",Academia,"2,013.00",Information and Software Technology,Journal,http://dx.doi.org/10.1016/j.infsof.2013.08.002,"@ARTICLE{Yamashita2013-ca,
  title     = ""To what extent can maintenance problems be predicted by code
               smell detection? -- An empirical study"",
  author    = ""Yamashita, Aiko and Moonen, Leon"",
  journal   = ""Inf. Softw. Technol."",
  publisher = ""Elsevier BV"",
  volume    =  55,
  number    =  12,
  pages     = ""2223--2242"",
  month     =  dec,
  year      =  2013,
  language  = ""en""
}
",,Together
23,S24,Code Smell Detection: Towards a Machine Learning-Based Approach,"Several code smells detection tools have been developed providing different results, becaUse smells can be subjectively interpreted and hence detected in different ways. Usually the detection techniques are based on the computation of different kinds of metrics, and other aspects related to the domain of the system under analysis, its size and other design features are not taken into account. In this paper we Propose an approach we are studying based on machine learning techniques. We outline some common problems faced for smells detection and we describe the different steps of our approach and the algorithms we Use for the classification.",Propose,"Francesca Arcelli Fontana
Marco Zanoni
Alessandro Marino
Mika V. Mäntylä",Academia,"2,013.00",International Conference on Software Maintenance and Evolution,Conference,,"@INPROCEEDINGS{6676916,  author={Fontana, Francesca Arcelli and Zanoni, Marco and Marino, Alessandro and Mäntylä, Mika V.},  booktitle={2013 IEEE International Conference on Software Maintenance},   title={Code Smell Detection: Towards a Machine Learning-Based Approach},   year={2013},  volume={},  number={},  pages={396-399},  doi={10.1109/ICSM.2013.56}}",,CheckStyle
24,S25,Integrating Technical Debt into MDE,"The main goal of this work is to evaluate the feasibility to
calculate the technical debt (a traditional software quality approach) in
a model-driven context through the same tools Used by software developers at work. The SonarQube tool was Used, so that the quality check
was performed directly on projects created with Eclipse Modeling Framework (EMF) instead of traditionals source code projects. In this work,
XML was Used as the model specification language to verify in SonarQube due to the creation of EMF metamodels in XMI (XML Metadata
Interchange) and that SonarQube offers a plugin to assess the XML language. After this, our work focUsed on the definition of model rules as
an XSD schema (XML Schema Definition) and the integration between
EMF-SonarQube in order that these metrics were directly validated by
SonarQube; and subsequently, this tool determined the technical debt
that the analyzed EMF models could contain.",Use,"Faber D. Giraldo
Sergio Espana
Manuel A. Pineda
William J. Giraldo
Oscar Pastor",Academia,"2,014.00",International Conference on Advanced Information Systems Engineering,Conference,http://ceur-ws.org/Vol-1164/PaperDemo02.pdf,"@inproceedings{Giraldo2014,
  author    = {F{\'{a}}ber D. Giraldo and
               Sergio Espa{\~{n}}a and
               Manuel A. Pineda and
               William J. Giraldo and
               Oscar Pastor},
  editor    = {Selmin Nurcan and
               Elias Pimenidis and
               Oscar Pastor and
               Yannis Vassiliou},
  title     = {Integrating Technical Debt into {MDE}},
  booktitle = {Joint Proceedings of the CAiSE 2014 Forum and CAiSE 2014 Doctoral
               Consortium co-located with the 26th International Conference on Advanced
               Information Systems Engineering (CAiSE 2014), Thessaloniki, Greece,
               June 18-20, 2014}
  year      = {2014},
  url       = {http://ceur-ws.org/Vol-1164/PaperDemo02.pdf},
  timestamp = {Mon, 18 Jan 2021 08:56:37 +0100},
  biburl    = {https://dblp.org/rec/conf/caise/GiraldoEPGP14.bib},
  bibsource = {dblp computer science bibliography, https://dblp.org}
}","The SonarQube tool was Used, so that the quality check was performed directly on projects created with Eclipse Modeling Framework (EMF) instead of traditionals source code projects.",SonarQube
25,S26,JSpIRIT: A Flexible Tool for the Analysis of Code Smells,"Code smells are a popular mechanism to identify structural design problems in software systems. Since it is generally not feasible to fix all the smells arising in the code, some of them are often postponed by developers to be resolved in the future. One reason for this decision is that the improvement of the code structure, to achieve modifability goals, requires extra effort from developers. Therefore, they might not always spend this additional effort, particularly when they are focUsed on delivering customer-visible features. This postponement of code smells are seen as a source of technical debt. Furthermore, not all the code smells may be urgent to fix in the context of the system's modifability and business goals. While there are a number of tools to detect smells, they do not allow developers to discover the most urgent smells according to their goals. In this article, we present a fexible tool to prioritize technical debt in the form of code smells. The tool is flexible to allow developer s to add new smell detection strategies and to prioritize smells, and groups of smells, based on the confguration of their manifold criteria. To illustrate this flexibility, we present an application example of our tool. The results suggest that our tool can be easily extended to be aligned with the developer's goals.",Propose,"Santiago Vidal
Hernan Vazquez
J. Andres Díaz-Pace
Claudia Marcos
Alessandro Garcia
Willian Oizumi",Academia,"2,015.00",International Conference of the Chilean Computer Science Society,Conference,https://doi.org/10.1109/SCCC.2015.7416572,"@INPROCEEDINGS{Vidal2015-jl,
  title           = ""{JSpIRIT}: a flexible tool for the analysis of code smells"",
  booktitle       = ""2015 34th International Conference of the Chilean Computer
                     Science Society ({SCCC})"",
  author          = ""Vidal, Santiago and Vazquez, Hernan and Diaz-Pace, J
                     Andres and Marcos, Claudia and Garcia, Alessandro and
                     Oizumi, Willian"",
  publisher       = ""IEEE"",
  month           =  nov,
  year            =  2015,
  conference      = ""2015 34th International Conference of the Chilean Computer
                     Science Society (SCCC)"",
  location        = ""Santiago, Chile""
}
","In this article,
we present a f exible tool to prioritize technical debt in the form
of code smells. The tool is f exible to allow developer s to add new
smell detection str ategies and to prioritize smells, and groups of
smells, based on the conf gur ation of their manifold criteria.",JSpIRIT
26,S27,Assessing the Effectiveness of Static Analysis through Defect Correlation Analysis,"Assessment of code and design quality using Software Code Assessment tools is important for continuous improvement and monitoring of code quality in the software industry in general and for global software development in particular. Static Analysis is believed to help identify issues at an early stage in the software development life cycle (SDLC), however it is still under utilized in the industry. In this paper, we discuss our experiences in determining the importance of Static Analysis and the extent to which the defects (that could otherwise be slipped to later stages of SDLC) could have been reduced with the continuous Use of Static Analysis. Towards this end, we have performed analysis of defects reported from testing/field by correlating the defects to Static Analysis Rules, for projects that were developed across different regions. Our focus was to gather insight into the number and type of defects that could be identified in advance through Static Analysis Rules. The purpose of gaining the insights is to justify the ROI for software quality checks, fine tune, update existing software quality practices and introduce new practices uniformly across the teams as necessary. The results substantiate the role of Static Analysis in reducing technical debt by identifying potential defects early in the SDLC.",Use,"Radhika D Venkatasubramanyam
Shrinath Gupta
Umesh Uppili",Industry,"2,015.00",International Conference on Global Software Engineering,Conference,http://doi.org/10.1109/ICGSE.2015.18,"@inproceedings{Venkatasubramanyam_2015,
	doi = {10.1109/icgse.2015.18},
	url = {https://doi.org/10.1109%2Ficgse.2015.18},
	year = 2015,
	month = {jul},
	publisher = {{IEEE}},
	author = {Radhika D. Venkatasubramanyam and Shrinath Gupta and Umesh Uppili},
	title = {Assessing the Effectiveness of Static Analysis through Defect Correlation Analysis},
	booktitle = {2015 {IEEE} 10th International Conference on Global Software Engineering}
}","In this paper, we
discuss our experiences in determining the importance of Static
Analysis and the extent to which the defects (that could otherwise
be slipped to later stages of SDLC) could have been reduced with
the continuous Use of Static Analysis.","FxCop
PCLint
FindBugs"
27,S28,Conciliating Model-Driven Engineering with Technical Debt Using a Quality Framework,"The main goal of this work is to evaluate the feasibility to calculate the technical debt (a traditional software quality approach) in a model-driven context through the same tools Used by software developers at work. The SonarQube tool was Used, so that the quality check was performed directly on projects created with Eclipse Modeling Framework (EMF) instead of traditionals source code projects. In this work, XML was Used as the model specification language to verify in SonarQube due to the creation of EMF metamodels in XMI (XML Metadata Interchange) and that SonarQube offers a plugin to assess the XML language. After this, our work focUsed on the definition of model rules as an XSD schema (XML Schema Definition) and the integration between EMF-SonarQube in order that these metrics were directly validated by SonarQube; and subsequently, this tool determined the technical debt that the analyzed EMF models could contain.",Propose,"Faber D. Giraldo
Sergio Espana
Manuel A. Pineda,
William J. Giraldo
Oscar Pastor",Academia,"2,015.00",International Conference on Advanced Information Systems Engineering,Conference,https://doi.org/10.1007/978-3-319-19270-3_13,"@incollection{Giraldo_2015,
	doi = {10.1007/978-3-319-19270-3_13},
	url = {https://doi.org/10.1007%2F978-3-319-19270-3_13},
	year = 2015,
	publisher = {Springer International Publishing},
	pages = {199--214},
	author = {F{\'{a}}ber D. Giraldo and Sergio Espa{\~{n}}a and Manuel A. Pineda and William J. Giraldo and Oscar Pastor},
	title = {Conciliating Model-Driven Engineering with Technical Debt Using a Quality Framework},
	booktitle = {Lecture Notes in Business Information Processing}
}",,SonarQube
28,S29,Towards a Prioritization of Code Debt: A Code Smell Intensity Index,"Code smells can be Used to capture symptoms of code decay and potential maintenance problems that can be avoided by applying the right refactoring. They can be seen as a source of technical debt. However, tools for code smell detection often provide far too many and different results, and identify many false positive code smell instances. In fact, these tools are rooted on initial and rather informal code smell definitions. This represents a challenge to interpret their results in different ways. In this paper, we provide an Intensity Index, to be Used as an estimator to determine the most critical instances, prioritizing the examination of smells and, potentially, their removal. We apply Intensity on the detection of six well known and common smells and we report their Intensity distribution from an analysis performed on 74 systems of the Qualitas Corpus, showing how Intensity could be Used to prioritize code smells inspection.",Compare,"Francesca Arcelli Fontana
Marco Zanoni
Marco Zanoni
Riccardo Roveda",Academia,"2,015.00",International Workshop on Managing Technical Debt,Workshop,10.1109/MTD.2015.7332620,"@INPROCEEDINGS{7332620,  author={Fontana, Francesca Arcelli and Ferme, Vincenzo and Zanoni, Marco and Roveda, Riccardo},  booktitle={2015 IEEE 7th International Workshop on Managing Technical Debt (MTD)},   title={Towards a prioritization of code debt: A code smell Intensity Index},   year={2015},  volume={},  number={},  pages={16-24},  doi={10.1109/MTD.2015.7332620}}",,
29,S30,Comparing and experimenting machine learning techniques for code smell detection,"Several code smell detection tools have been developed providing different results, becaUse smells can be subjectively interpreted, and hence detected, in different ways. In this paper, we perform the largest experiment of applying machine learning algorithms to code smells to the best of our knowledge. We experiment 16 different machine-learning algorithms on four code smells (Data Class, Large Class, Feature Envy, Long Method) and 74 software systems, with 1986 manually validated code smell samples. We found that all algorithms achieved high performances in the cross-validation data set, yet the highest performances were obtained by J48 and Random Forest, while the worst performance were achieved by support vector machines. However, the lower prevalence of code smells, i.e., imbalanced data, in the entire data set caUsed varying performances that need to be addressed in the future studies. We conclude that the application of machine learning to the detection of these code smells can provide high accuracy (>96 %), and only a hundred training examples are needed to reach at least 95 % accuracy.",Propose,,Academia,"2,015.00",Empirical Software Engineering,Journal,,"@article{ArcelliFontana2015,
  doi = {10.1007/s10664-015-9378-4},
  url = {https://doi.org/10.1007/s10664-015-9378-4},
  year = {2015},
  month = jun,
  publisher = {Springer Science and Business Media {LLC}},
  volume = {21},
  number = {3},
  pages = {1143--1191},
  author = {Francesca Arcelli Fontana and Mika V. M\""{a}ntyl\""{a} and Marco Zanoni and Alessandro Marino},
  title = {Comparing and experimenting machine learning techniques for code smell detection},
  journal = {Empirical Software Engineering}
}",,
30,S31,Experimental Evaluation of Code Smell Detection Tools,"Code smells refer to any symptom in the source code of a program that possibly indicates a deeper problem, hindering software maintenance and evolution. Detection of code smells is challenging for developers and their informal definition leads to the implementation of multiple detection techniques and tools. This paper evaluates and Compares four code smell detection tools, namely inFusion, JDeodorant, PMD, and JSpIRIT. These tools were applied to different versions of the same software systems, namely MobileMedia and Health Watcher, to calculate the accuracy and agreement of code smell detection tools. We calculated the accuracy of each tool in the detection of three code smells: God Class, God Method, and Feature Envy. Agreement was calculated among tools and between pairs of tools. One of our main findings is that the evaluated tools present different levels of accuracy in different contexts. For MobileMedia, for instance, the average recall varies from 0 to 58% and the average precision from 0 to 100%, while for Health Watcher the variations are 0 to 100% and 0 to 85%, respectively. Regarding the agreement, we found that the overall agreement between tools varies from 83 to 98% among all tools and from 67 to 100% between pairs of tools. We also conducted a secondary study of the evolution of code smells in both target systems and found that, in general, code smells are present from the moment of creation of a class or method in 74.4% of the cases of MobileMedia and 87.5% of Health Watcher.",Compare,,Academia,"2,015.00",Journal of Software Engineering Research and Development,Journal,,"@article{Paiva2017,
  doi = {10.1186/s40411-017-0041-1},
  url = {https://doi.org/10.1186/s40411-017-0041-1},
  year = {2017},
  month = oct,
  publisher = {Sociedade Brasileira de Computacao - {SB}},
  volume = {5},
  number = {1},
  author = {Thanis Paiva and Amanda Damasceno and Eduardo Figueiredo and Cl{\'{a}}udio Sant'Anna},
  title = {On the evaluation of code smells and detection tools},
  journal = {Journal of Software Engineering Research and Development}
}",,"PMD,Jdeodorant"
31,S32,Mining Version Histories for Detecting Code Smells,"Code smells are symptoms of poor design and implementation choices that may hinder code comprehension, and possibly increase changeand fault-proneness. While most of the detection techniques just rely on structural information, many code smells are intrinsically characterized by how code elements change overtime. In this paper, we Propose Historical Information for Smell deTection (HIST), an approach exploiting change history information to detect instances of five different code smells, namely Divergent Change, Shotgun Surgery, Parallel Inheritance, Blob, and Feature Envy. We evaluate HIST in two empirical studies. The first, conducted on 20 open source projects, aimed at assessing the accuracy of HIST in detecting instances of the code smells mentioned above. The results indicate that the precision of HIST ranges between 72 and 86 percent, and its recall ranges between 58 and 100 percent. Also, results of the first study indicate that HIST is able to identify code smells that cannot be identified by competitive approaches solely based on code analysis of a single system's snapshot. Then, we conducted a second study aimed at investigating to what extent the code smells detected by HIST (and by competitive code analysis techniques) reflect developers' perception of poor design and implementation choices. We involved 12 developers of four open source projects that recognized more than 75 percent of the code smell instances identified by HIST as actual design/implementation problems.",Propose,,Academia,"2,015.00",IEEE TRANSACTIONS ON SOFTWARE ENGINEERING,Journal,,"@ARTICLE{6963448,  author={Palomba, Fabio and Bavota, Gabriele and Penta, Massimiliano Di and Oliveto, Rocco and Poshyvanyk, Denys and De Lucia, Andrea},  journal={IEEE Transactions on Software Engineering},   title={Mining Version Histories for Detecting Code Smells},   year={2015},  volume={41},  number={5},  pages={462-489},  doi={10.1109/TSE.2014.2372760}}",,"Jdeodorant
Ptidej"
32,S33,Hotspot Patterns: The Formal Definition and Automatic Detection of Architecture Smells,"In this paper, we Propose and empirically validate a suite of hotspot patterns: recurring architecture problems that occur in most complex systems and incur high maintenance costs. In particular, we introduce two novel hotspot patterns, Unstable Interface and Implicit Cross-module Dependency. These patterns are defined based on Baldwin and Clark's design rule theory, and detected by the combination of history and architecture information. Through our tool-supported evaluations, we show that these patterns not only identify the most error-prone and change-prone files, they also pinCite specific architecture problems that may be the root caUses of bug-proneness and change-proneness. Significantly, we show that 1) these structure-history integrated patterns contribute more to error- and change-proneness than other hotspot patterns, and 2) the more hotspot patterns a file is involved in, the more error- and change-prone it is. Finally, we report on an industrial case study to demonstrate the practicality of these hotspot patterns. The architect and developers confirmed that our hotspot detector discovered the majority of the architecture problems causing maintenance pain, and they have started to improve the system's maintainability by refactoring and fixing the identified architecture issues.",Propose,,Academia,"2,015.00",Conference on Software Architecture,Conference,,"@INPROCEEDINGS{7158503,  author={Mo, Ran and Cai, Yuanfang and Kazman, Rick and Xiao, Lu},  booktitle={2015 12th Working IEEE/IFIP Conference on Software Architecture},   title={Hotspot Patterns: The Formal Definition and Automatic Detection of Architecture Smells},   year={2015},  volume={},  number={},  pages={51-60},  doi={10.1109/WICSA.2015.12}}",,
33,S34,Tool support for evaluating architectural debt of an existing system: An experience report,"During software development, maintenance and evolution, we can assess the quality of code, design and architecture to capture hints of possible problems and face them as soon as possible. We can capture signals of architecture erosion in different ways by exploiting several tools with the aim to identify architectural violations, architectural smells or other relevant features. In this paper, we provide our experience report in using three known tools to capture information that can be Useful to identify and evaluate the architectural debt of an application. We outline the main differences among these tools and the results they produce.",Compare,"Francesca Arcelli Fontana
Riccardo Roveda
Marco Zanoni",Academia,"2,016.00",ACM/SIGAPP Symposium on Applied Computing,Conference,http://dx.doi.org/10.1145/2851613.2851963,"@INPROCEEDINGS{Fontana2016-mt,
  title           = ""Tool support for evaluating architectural debt of an
                     existing system"",
  booktitle       = ""Proceedings of the 31st Annual {ACM} Symposium on Applied
                     Computing"",
  author          = ""Fontana, Francesca Arcelli and Roveda, Riccardo and
                     Zanoni, Marco"",
  publisher       = ""ACM"",
  month           =  apr,
  year            =  2016,
  address         = ""New York, NY, USA"",
  copyright       = ""http://www.acm.org/publications/policies/copyright\_policy\#Background"",
  conference      = ""SAC 2016: Symposium on Applied Computing"",
  location        = ""Pisa Italy""
}
","This paper aims to describe our experimentation using these tools, by ana-
lyzing different systems.","Sonargraph-Quality
SonarQube
inFusion"
34,S35,Technical Debt Indexes provided by tools: a preliminary discussion,"In software maintenance and evolution, it is important to assess both code and architecture in order to identify issues to be solved to improve software quality. Different tools provide some kind of index giving us an overall evaluation of a project to be Used when managing its technical debt. In this paper, we outline how the indexes, that we call in general Technical Debt Indexes, provided by five different tools are computed. We describe their principal features and differences, what aspects they are missing, and we outline if (and how) the indexes take into account architectural problems that could have a major impact on the architectural debt. We show that the indexes rely on different information sources and measure different quantities.",Compare,"Francesca Arcelli Fontana
Riccardo Roveda
Marco Zanoni",Academia,"2,016.00",International Workshop on Managing Technical Debt,Workshop,https://doi.org/10.1109/MTD.2016.11,"@INPROCEEDINGS{Fontana2016-ag,
  title           = ""Technical debt indexes provided by tools: A preliminary
                     discussion"",
  booktitle       = ""2016 {IEEE} 8th International Workshop on Managing
                     Technical Debt ({MTD})"",
  author          = ""Fontana, Francesca Arcelli and Roveda, Riccardo and
                     Zanoni, Marco"",
  publisher       = ""IEEE"",
  month           =  oct,
  year            =  2016,
  conference      = ""2016 IEEE 8th International Workshop on Managing Technical
                     Debt (MTD)"",
  location        = ""Raleigh, NC, USA""
}
","We focus our attention on the TDI provided by known tools, with the aim to understand what
exactly each index takes into account, what the value of the index represents, and its completeness w.r.t. the information that can be exploited to estimate Technical Debt.","CAST
inFusion
Sonargraph
SonarQube
Structure101"
35,S36,"Minimizing refactoring effort through prioritization of classes based on historical, architectural and code smell information","—Improving a software system’s internal structure
through regular refactoring is considered vital for its long and
healthy life. However, despite its amenities, refactoring is not
readily adopted by software development teams in industry
mainly due to strict project deadlines and limited resources.
Hence, they look for optimal refactoring recommendations that
would incur minimal effort overhead while outputting decent
benefits in terms of enhanced software quality. To this end, we
Propose an approach for identifying and prioritizing objectoriented software classes in need of refactoring. Our approach
first identifies the most refactoring-prone as well as
architecturally relevant classes, and then generates class ranks
based on the code smell information. In addition to locating
classes with the most significant incremental refactoring
opportunities, this work contributes through suggesting
developers on estimating maximum code smell correction (paying
off maximum technical debt) with minimum refactoring effort.
We evaluated the Proposed approach on a sample of 1621 classes
and 2358 code smell instances, distributed over 28 versions of
four open source java systems.",Propose,"Aabha Choudhary
Paramvir Singh",Academia,"2,016.00",International Workshop on Technical Debt Analytics,Workshop,https://www.semanticscholar.org/paper/Minimizing-Refactoring-Effort-through-of-Classes-on-Choudhary-Singh/aa6626d94135fa3b565690c5fa1187d7f8611c4d,"@inproceedings{Choudhary2016MinimizingRE,
  title={Minimizing Refactoring Effort through Prioritization of Classes based on Historical, Architectural and Code Smell Information},
  author={Aabha Choudhary and Paramvir Singh},
  booktitle={QuASoQ/TDA@APSEC},
  year={2016}
}",They Proposed an approach to identify and prioritize classes that need refactoring.,JSpIRIT
36,S37,Designite - A Software Design Quality Assessment Tool,"Poor design quality and huge technical debt are common issues perceived in real-life software projects. Design smells are indicators of poor design quality and the volume of design smells found could be treated as the design debt of the software system. The existing smell detection tools focus largely on implementation smells and do not reveal a comprehensive set of smells that arise at design level. In this paper, we present Designite - a software design quality assessment tool. It not only supports comprehensive design smells detection but also provides a detailed metrics analysis. Further, it offers various features to help identify issues contributing to design debt and improve the design quality of the analyzed software system.",Propose,"Tushar Sharma
Pratibha Mishra
Rohit Tiwari",Both,"2,016.00",International Workshop on Bringing Architectural Design Thinking Into Developers' Daily Activities,Workshop,http://dx.doi.org/10.1145/2896935.2896938,"@INPROCEEDINGS{Sharma2016-ca,
  title           = ""Designite"",
  booktitle       = ""Proceedings of the 1st International Workshop on Bringing
                     Architectural Design Thinking into Developers' Daily
                     Activities - {BRIDGE} '16"",
  author          = ""Sharma, Tushar and Mishra, Pratibha and Tiwari, Rohit"",
  publisher       = ""ACM Press"",
  year            =  2016,
  address         = ""New York, New York, USA"",
  copyright       = ""http://www.acm.org/publications/policies/copyright\_policy\#Background"",
  conference      = ""the 1st International Workshop"",
  location        = ""Austin, Texas""
}","In this

paper, we present Designite - a software design quality as-
sessment tool.",Designite
37,S38,Technical debt reduction using search based automated refactoring,"Software refactoring has been recognized as a valuable process during software development and is often aimed at repaying technical debt. Technical debt arises when a software product has been built or amended without full care for structure and extensibility. Refactoring is Useful to keep technical debt low and if it can be automated there are obvious efficiency benefits. Using a combination of automated refactoring techniques, software metrics and metaheuristic searches, an automated refactoring tool can improve the structure of a software system without affecting its functionality. In this paper, four different refactoring approaches are Compared using an automated software refactoring tool. Weighted sums of metrics are Used to form different fitness functions that drive the search process towards certain aspects of software quality. Metrics are combined to measure coupling, abstraction and inheritance and a fourth fitness function is Proposed to measure reduction in technical debt. The 4 functions are Compared against each other using 3 different searches on 6 different open source programs. Four out of the 6 programs show a larger improvement in the technical debt function after the search based refactoring process. The results show that the technical debt function is Useful for assessing improvement in quality.",Compare,"Michael Mohan
Des Greer
Paul McMullan",Academia,"2,016.00",The Journal of Systems and Software,Journal,http://dx.doi.org/10.1016/j.jss.2016.05.019,"@ARTICLE{Mohan2016-xp,
  title     = ""Technical debt reduction using search based automated
               refactoring"",
  author    = ""Mohan, Michael and Greer, Des and McMullan, Paul"",
  journal   = ""J. Syst. Softw."",
  publisher = ""Elsevier BV"",
  volume    =  120,
  pages     = ""183--194"",
  month     =  oct,
  year      =  2016,
  language  = ""en""
}
","In this paper, four different refactoring approaches are Compared using an automated software refactoring tool.",A-CMA
38,S39,An experience report on detecting and repairing software architecture erosion,"Architecture erosion constitutes the most visible effect of the degradation of design. It is a major reason to address the design debt, often caUsed by architectural mismatch problems. Today, the identification of design erosion is a major concern for designers and software maintainers. Adequate tools are necessary to identify and repair the debt. This paper describes our experience on identifying architectural erosion problems on existing open source software applications through the support of two well known tools. Moreover, we outline if the tools provide Useful hints in repairing some of the detected problems.",Compare,"Francesca Arcelli Fontana 
Riccardo Roveda
Marco Zanoni
Claudia Raibulet
Rafael Capilla",Academia,"2,016.00",Working IEEE/IFIP Conference on Software Architecture,Conference,http://doi.org/10.1109/WICSA.2016.37,"@INPROCEEDINGS{Fontana2016-ta,
  title           = ""An experience report on detecting and repairing software
                     architecture erosion"",
  booktitle       = ""2016 13th Working {IEEE/IFIP} Conference on Software
                     Architecture ({WICSA})"",
  author          = ""Fontana, Francesca Arcelli and Roveda, Riccardo and
                     Zanoni, Marco and Raibulet, Claudia and Capilla, Rafael"",
  publisher       = ""IEEE"",
  month           =  apr,
  year            =  2016,
  conference      = ""2016 13th Working IEEE/IFIP Conference on Software
                     Architecture (WICSA)"",
  location        = ""Venice, Italy""
}
","This paper describes
our experience on identifying architectural erosion problems on
existing open source software applications through the support
of two well known tools.","Sonargraph
Structure101"
39,S40,Pragmatic Approach for Managing Technical Debt in Legacy Software Project,"Tackling the issues of technical debt in a large system in parallel with continuing to enable it to evolve is a challenging problem.

In this paper, we are describing a case study of managing technical debt on a legacy project referred here as Global Configurator Project (GCP) using pragmatic approach. The paper presents holistic lifecycle approach with four stages and various practices in each stage for managing technical debt. Given life cycle approach and practices will be Useful for any software project. In particular, these practices will be significant to any legacy project towards repaying debt. These methods can also be applied to continuously improve code quality and product quality. This paper also focus on technical debt User stories to gain business buy-in and share few 'best in market' tools that we Used in repaying technical debt. It also focUses on sensitizing developers to the concept of debt and improving their skills. This paper describes the process Used by a separate team formed to reduce technical debt in a large legacy system.

The paper targets to the Project Managers, Test Managers architects and Scrum Masters in agile software development.",Use,"Rajeev Kumar Gupta
Prabhulinga Manikreddy
Sandesh Naik
Arya K",Academia,"2,016.00",India Software Engineering Conference,Conference,https://doi.org/10.1145/2856636.2856655,"@INPROCEEDINGS{Gupta2016-kv,
  title           = ""Pragmatic approach for managing technical debt in legacy
                     software project"",
  booktitle       = ""Proceedings of the 9th India Software Engineering
                     Conference"",
  author          = ""Gupta, Rajeev Kumar and Manikreddy, Prabhulinga and Naik,
                     Sandesh and Arya, K"",
  publisher       = ""ACM"",
  month           =  feb,
  year            =  2016,
  address         = ""New York, NY, USA"",
  copyright       = ""http://www.acm.org/publications/policies/copyright\_policy\#Background"",
  conference      = ""ISEC '16: 9th India Software Engineering Conference"",
  location        = ""Goa India""
}
","In this paper, we are describing a case study of managing
technical debt on a legacy project referred here as Global
Configurator Project (GCP) using pragmatic approach. The paper
presents holistic lifecycle approach with four stages and various
practices in each stage for managing technical debt.","GDI handle
IBM Rational Purify
Coverity
Findbugs
Simian
source monitor
Perfmon
Apache JMeter
PCLint
FxCop
Intel thread checker
Cppcheck"
40,S41,Technical Debt Prioritization using Predictive Analytics,"Recently, Technical Debt (TD) has gained popularity in the Software Engineering community to describe design decisions that allow software development teams to achieve short term benefits such as expedited release of code. Technical debt accrued should be managed to avoid the disastrous consequences of these temporary workarounds. Management of technical debt involve documenting the debt item in the backlog including some type of quantification in terms of person-hours or story Cites for example. Subsequently, the debt items are prioritized and addressed. Developers or project managers face problems to decide which debt is higher priority or more ""problematic"" and which one needs to be addressed first. This decision-making process is not standardized and is currently context dependent in most organizations. This paper bridge this gap by proposing a framework which makes Use of a plethora of techniques ranging from data mining to prediction and decision models that project managers can Use in their decision-making process to determine which technical debt is more critical and should be addressed first.",Propose,"Zadia Codabux
Byron J. Williams",Academia,"2,016.00",International Conference on Software Engineering Companion,Conference,http://dx.doi.org/10.1145/2889160.2892643,"@inproceedings{Codabux_2016,
	doi = {10.1145/2889160.2892643},
	url = {https://doi.org/10.1145%2F2889160.2892643},
	year = 2016,
	month = {may},
	publisher = {{ACM}},
	author = {Zadia Codabux and Byron J. Williams},
	title = {Technical debt prioritization using predictive analytics},
	booktitle = {Proceedings of the 38th International Conference on Software Engineering Companion}
}",This paper bridge this gap by proposing a framework which makes Use of a plethora of techniques ranging from data mining to prediction and decision models that project managers can Use in their decision-making process to determine which technical debt is more critical and should be addressed first.,Understand
41,S42,Does Your Configuration Code Smell?,"Infrastructure as Code (IaC) is the practice of specifying computing system configurations through code, and managing them through traditional software engineering methods. The wide adoption of configuration management and increasing size and complexity of the associated code, prompt for assessing, maintaining, and improving the configuration code's quality. In this context, traditional software engineering knowledge and best practices associated with code quality management can be leveraged to assess and manage configuration code quality. We Propose a catalog of 13 implementation and 11 design configuration smells, where each smell violates recommended best practices for configuration code. We analyzed 4,621 Puppet repositories containing 8.9 million lines of code and detected the cataloged implementation and design configuration smells. Our analysis reveals that the design configuration smells show 9% higher average co-occurrence among themselves than the implementation configuration smells. We also observed that configuration smells belonging to a smell category tend to co-occur with configuration smells belonging to another smell category when correlation is computed by volume of identified smells. Finally, design configuration smell density shows negative correlation whereas implementation configuration smell density exhibits no correlation with the size of a configuration management system.",Use,"Tushar Sharma
Marios Fragkoulis
Diomidis Spinellis",Academia,"2,016.00",Working Conference on Mining Software Repositories,Conference,https://doi.org/10.1145/2901739.2901761,"@inproceedings{Sharma_2016,
	doi = {10.1145/2901739.2901761},
	url = {https://doi.org/10.1145%2F2901739.2901761},
	year = 2016,
	month = {may},
	publisher = {{ACM}},
	author = {Tushar Sharma and Marios Fragkoulis and Diomidis Spinellis},
	title = {Does your configuration code smell?},
	booktitle = {Proceedings of the 13th International Conference on Mining Software Repositories}
}","We Propose a catalog of 13 implementation and 11 design configuration smells, where each
smell violates recommended best practices for configuration code.","Puppeteer
Puppet-Lint"
42,S43,Technical Debt in MDE: A Case Study on GMF/EMF-Based Projects,"Technical Debt (TD) is a metaphor referring to immature software artifacts that can hurt the long-term maintenance of a system. Model-Driven Engineering (MDE) is a model-centric software development approach, which promises better maintainability. However, there is a lack of empirical evidence on the existence and influence of TD in the context of MDE. This paper investigates the code-level TD in MDE projects, which is incurred during code generation. We evaluated 16 open-source and non-trivial GMF/EMF-based MDE projects using bad smells, which are widely-accepted TD indicators. The results demonstrate that MDE is not TD-free, and code generators also incur TD, similarly to developers. In fact, the generated code usually contains more TD than handwritten code, which influences significantly the maintenance of MDE projects.",Use,"Xiao He
Paris Avgeriou
Peng Liang
Zengyang Li",Academia,"2,016.00",International Conference on Model Driven Engineering Languages and Systems,Conference,https://doi.org/10.1145/2976767.2976806,"@inproceedings{He_2016,
	doi = {10.1145/2976767.2976806},
	url = {https://doi.org/10.1145%2F2976767.2976806},
	year = 2016,
	month = {oct},
	publisher = {{ACM}},
	author = {Xiao He and Paris Avgeriou and Peng Liang and Zengyang Li},
	title = {Technical debt in {MDE}},
	booktitle = {Proceedings of the {ACM}/{IEEE} 19th International Conference on Model Driven Engineering Languages and Systems}
}","This paper investigates the code-level TD in MDE projects, which is incurred during code generation. We evaluated 16 open-source and non-trivial GMF/EMF-based MDE projects using bad smells, which are widely-accepted TD indicators.",PMD
43,S44,How do software development teams manage technical debt? – An empirical study,"Technical debt (TD) is a metaphor for taking shortcuts or workarounds in technical decisions to gain short-term benefit in time-to-market and earlier software release. In this study, one large software development organization is investigated to gather empirical evidence related to the concept of technical debt management (TDM). We Used the exploratory case study method to collect and analyze empirical data in the case organization by interviewing a total of 25 persons in eight software development teams. We were able to identify teams where the current strategy for TDM was only to fix TD when necessary, when it started to caUse too much trouble for development. We also identified teams where the management had a systematic strategy to identify, measure and monitor TD during the development process. It seems that TDM can be associated with a similar maturity concept as software development in general. Development teams may raise their maturity by increasing their awareness and applying more advanced processes, techniques and tools in TDM. TDM is an essential part of sustainable software development, and companies have to find right approaches to deal with TD to produce healthy software that can be developed and maintained in the future.",Cite,"Jesse Yli-Huumo
Andrey Maglyas
Kari Smolander",Academia,"2,016.00",The Journal of Systems and Software,Journal,http://dx.doi.org/10.1016/j.jss.2016.05.018,"@article{Yli_Huumo_2016,
	doi = {10.1016/j.jss.2016.05.018},
	url = {https://doi.org/10.1016%2Fj.jss.2016.05.018},
	year = 2016,
	month = {oct},
	publisher = {Elsevier {BV}},
	volume = {120},
	pages = {195--218},
	author = {Jesse Yli-Huumo and Andrey Maglyas and Kari Smolander},
	title = {How do software development teams manage technical debt? {\textendash} An empirical study},
	journal = {Journal of Systems and Software}
}","We Used the exploratory case study method to collect and analyze empirical
data in the case organization by interviewing a total of 25 persons in eight software development teams.","SonarQube
DebtFlag
JIRA
CheckStyle
FindBugs"
44,S45,Automatic Detection of Instability Architectural Smells,"Code smells represent well known symptoms of problems at code level, and architectural smells can be seen as their counterpart at architecture level. If identified in a system, they are usually considered more critical than code smells, for their effect on maintainability issues. In this paper, we introduce a tool for the detection of architectural smells that could have an impact on the stability of a system. The detection techniques are based on the analysis of dependency graphs extracted from compiled Java projects and stored in a graph database. The results combine the information gathered from dependency and instability metrics to identify flaws hidden in the software architecture. We also Propose some filters trying to avoid possible false positives.",Propose,"Francesca Arcelli Fontana
Ilaria Pigazzini
Riccardo Roveda
Marco Zanoni",Academia,"2,016.00",International Conference on Software Maintenance and Evolution,Conference,,"@inproceedings{Fontana2016,
  doi = {10.1109/icsme.2016.33},
  url = {https://doi.org/10.1109/icsme.2016.33},
  year = {2016},
  month = oct,
  publisher = {{IEEE}},
  author = {Francesca Arcelli Fontana and Ilaria Pigazzini and Riccardo Roveda and Marco Zanoni},
  title = {Automatic Detection of Instability Architectural Smells},
  booktitle = {2016 {IEEE} International Conference on Software Maintenance and Evolution ({ICSME})}
}",,"Arcan
Ai Reviewer
Understand"
45,S46,Refactoring for Software Architecture Smells,"Code smells and refactoring have received considerable interest from the academia as well as from the industry in the past two decades. The interest has given birth to various tools, processes, techniques, and practices to identify smells and refactor them. Despite the high interest, architecture smells and corresponding refactorings haven't received as much focus and adoption from the software engineering community. In this paper, we motivate the need of architecture refactoring, discuss the current related research, and present a few potential research directions for architecture refactoring.",Cite,,Academia,"2,016.00",International Workshop on Software Refactoring,Conference,,"@inproceedings{10.1145/2975945.2975946,
author = {Samarthyam, Ganesh and Suryanarayana, Girish and Sharma, Tushar},
title = {Refactoring for Software Architecture Smells},
year = {2016},
isbn = {9781450345095},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/2975945.2975946},
doi = {10.1145/2975945.2975946},
booktitle = {Proceedings of the 1st International Workshop on Software Refactoring},
pages = {1–4},
numpages = {4},
keywords = {Architecture refactoring, Software ar- chitecture, Architecture smells},
location = {Singapore, Singapore},
series = {IWoR 2016}
}",,
46,S47,Technical Debt Principal Assessment through Structural Metrics,"One of the first steps towards the effective Technical Debt (TD) management is the quantification and continuous monitoring of the TD principal. In the current state-ofresearch and practice the most common ways to assess TD principal are the Use of: (a) structural proxies—i.e., most commonly through quality metrics; and (b) monetized proxies—i.e., most commonly through the Use of the SQALE (Software Quality Assessment based on Lifecycle Expectations) method. Although both approaches have merit, they seem to rely on different viewCites of TD and their levels of agreement have not been evaluated so far. Therefore, in this paper, we empirically explore this relation by analyzing data obtained from 20 open source software projects and build a regression model that establishes a relationship between them. The results of the study suggest that a model of seven structural metrics, quantifying different aspects of quality (i.e., coupling, cohesion, complexity, size, and inheritance) can accurately estimate TD principal as appraised by SonarQube. The results of this case study are Useful to both academia and industry. In particular, academia can gain knowledge on: (a) the reliability and agreement of TD principal assessment methods and (b) the structural characteristics of software that contribute to the accumulation of TD, whereas practitioners are provided with an alternative evaluation model with reduced number of parameters that can accurately assess TD, through traditional software quality metrics and tools.",Use,"Makrina Viola Kosti
Apostolos Ampatzoglou
Alexander Chatzigeorgiou
Georgios Pallas
Ioannis Stamelos
Lefteris Angelis",Academia,"2,017.00",Euromicro Conference on Software Engineering and Advanced Applications,Conference,http://doi.org/10.1109/SEAA.2017.59,"@inproceedings{Kosti2017,
  doi = {10.1109/seaa.2017.59},
  url = {https://doi.org/10.1109/seaa.2017.59},
  year = {2017},
  month = aug,
  publisher = {{IEEE}},
  author = {Makrina Viola Kosti and Apostolos Ampatzoglou and Alexander Chatzigeorgiou and Georgios Pallas and Ioannis Stamelos and Lefteris Angelis},
  title = {Technical Debt Principal Assessment Through Structural Metrics},
  booktitle = {2017 43rd Euromicro Conference on Software Engineering and Advanced Applications ({SEAA})}
}","Specifically, we investigate if the monetized TD principal assessments can be subsumed by metric scores.",SonarQube
47,S48,SonarQube as a Tool to Identify Software Metrics and Technical Debt in the Source Code through Static Analysis,"Technical Debt (TD), also known as technical debt design or technical debt code, analyze the
consequence that could have a system once it has been designed architecturally, coding or implemented. TD
refers to work to be performed rather than software design or coding is considered complete or correct. Static
analysis is a technique to identify and analyze software characteristics from source code; through static
analysis we can identify elements such as packages, classes, relationships, lines of code (LOC’s), bugs,
complexity, coding violations and others. In addition, subsystems, components and their relationships
supported by tools, algorithms, frameworks to analyze the code were identified. SQALE is a quality and
analysis model contains the internal properties expected from the code in the context of the evaluation, it has
been Used to perform many assessments of software source code, of various sizes in different application
domains and programming language. SonarQube is an open source platform to manage the source code
quality, this cover seven axes of code quality among which stand: architecture and design, duplications, unit
test, complexity, potential bugs, codifications rules, comments, among others; this platform work with over
20 programming languages.
This paper, Use as input the source code of the software applications written in different programming
language for through static analysis identify metrics, characteristics, and technical debt with the aim to
improve the quality when writing code, also supported in static analysis identify aspects such as correct apply
of quality attributes, standards and best practices of programming that based in ISO 9126 and SQALE ensure
the correct software development in terms of design and coding. ",Use,"Daniel Guaman
Pablo Alejandro-Quezada Sarmiento
Luis Barba-Guamán
Paola Cabrera
Liliana Enciso",Academia,"2,017.00",International Workshop on Computer Science and Engineering,Workshop,http://doi.org/10.18178/wcse.2017.06.030,"@INPROCEEDINGS{Guaman2017,
  title      = ""{SonarQube} as a tool to identify software metrics and
                technical debt in the source code through static analysis"",
  booktitle  = ""Proceedings of 2017 the 7th International Workshop on Computer
                Science and Engineering"",
  publisher  = ""WCSE"",
  year       =  2017,
  conference = ""2017 the 7th International Workshop on Computer Science and
                Engineering"",
  author = ""Daniel Guaman, and Pablo Alejandro-Quezada Sarmiento, and Luis Barba-Guamán, and Paola Cabrera, and Liliana Enciso""
}","This paper exposes the search, classify and analysis of aspects related to technical debt in the code, also showed the Use of SonarQube combined with static analysis as a technique to analyze the software characteristics from the source code to determine possible issues in the people that develop software.",SonarQube
48,S49,Towards Triaging Code-Smell Candidates via Runtime Scenarios and Method-Call Dependencies,"Managing technical debt includes the detection and assessment of debt at the code and design levels (such as bad smells). Existing approaches and tools for smell detection primarily Use static program data for decision support. While a static analysis allows for identifying smell candidates without executing and instrumenting the system, such approaches also come with the risk of missing candidates or of producing false positives. Moreover, smell candidates might result from a deliberate design decision (e.g., of applying a particular design pattern). Such risks and the general ambivalence of smell detection require a manual design and/or code inspection for reviewing all alleged smells.

In this paper, we Propose an approach to obtain tailorable design documentation for object-oriented systems based on runtime tests. In particular, the approach supports a tool-supported triaging of code-smell candidates. We Use runtime scenario tests to extract execution traces. Based on these execution traces, different (automatically derived) model perspectives on method-call dependencies (e.g., dependency structure matrices, DSMs; UML2 sequence diagrams) are then Used as decision support for assessing smell candidates. Our approach is implemented as part of the KaleidoScope tool which is publicly available for download.",Propose,"Thorsten Haendler
Stefan Sobernig
Mark Strembeck",Academia,"2,017.00",International Conference on Agile Software Development: Companion,Conference,https://doi.org/10.1145/3120459.3120468,"@INPROCEEDINGS{Haendler2017-qd,
  title           = ""Towards triaging code-smell candidates via runtime
                     scenarios and method-call dependencies"",
  booktitle       = ""Proceedings of the {XP2017} Scientific Workshops"",
  author          = ""Haendler, Thorsten and Sobernig, Stefan and Strembeck,
                     Mark"",
  publisher       = ""ACM"",
  month           =  may,
  year            =  2017,
  address         = ""New York, NY, USA"",
  copyright       = ""http://www.acm.org/publications/policies/copyright\_policy\#Background"",
  conference      = ""XP '17 Workshops: Proceedings of the Scientific Workshops
                     of XP2017"",
  location        = ""Cologne Germany""
}
","In this paper, we Propose an approach to obtain tailorable design
documentation for object-oriented systems based on runtime tests.
In particular, the approach supports a tool-supported triaging of
code-smell candidates.",KaleidoScope
49,S50,Toward Technical Debt Aware Software Modeling,"Over the last decade, the technical debt metaphor has gained in popularity, and many tools exist today that can calculate the debt associated with a miscellany of source code. However, no corpus of studies has investigated the effects that
creation and refactoring of conceptual models have on technical debt of corresponding code. Our work addresses this fundamental gap by first providing a map of correspondences between recognized model smells of UML Class Diagrams and Java
source code issues. We then describe a set of empirical studies to calculate the technical debt of generated source code as a result of refactorings performed on their
corresponding models. Our results reveal a significant disconnect between model
smells and technical debt values of resultant generated source code, and little effect
of model refactorings on reducing these values. However, once correspondences between model smells and code issues are defined, model refactoring proves helpful in
preventing technical debt from a high abstraction level. We exemplify this scenario
by providing an in-depth example, and conclude with a discussion of results.
",Use,"Gonzalo Rojas
Clemente Izurieta
Isaac Griffith",Academia,"2,017.00",Iberoamerican Conference on Software Engineering,Conference,https://www.semanticscholar.org/paper/Toward-Technical-Debt-Aware-Software-Modeling-Rojas-Izurieta/11bbc831715fab2e3f30a999fc3968a39a331ae8,"@inproceedings{Rojas2017TowardTD,
  title={Toward Technical Debt Aware Software Modeling},
  author={Gonzalo Rojas and Clemente Izurieta and Isaac Griffith},
  booktitle={CIbSE},
  year={2017}
}","Our work addresses this fundamental gap by first providing a map of cor-
respondences between recognized model smells of UML Class Diagrams and Java

source code issues.","EMF Refactor
SonarQube"
50,S51,Recommending when Design Technical Debt Should be Self-Admitted,"Previous research has shown how developers ""selfadmit"" technical debt introduced in the source code, commenting why such code represents a workaround or a temporary, incomplete solution. This paper investigates the extent to which previously self-admitted technical debt can be Used to provide recommendations to developers when they write new source code, suggesting them when to ""self-admit"" design technical debt, or possibly when to improve the code being written. To achieve this goal, we have developed a machine learning approach named TEDIOUS (TEchnical Debt IdentificatiOn System), which leverages various kinds of method-level features as independent variables, including source code structural metrics, readability metrics and, last but not least, warnings raised by static analysis tools. We assessed TEDIOUS on data from nine open source projects for which there are available tagged self-admitted technical debt instances, also comparing the performances of different machine learners. Results of the study indicate that TEDIOUS achieves, when recommending self-admitted technical debts within a single project, an average precision of about 50% and a recall of 52%. When predicting cross-projects, TEDIOUS improves, achieving an average precision of 67% and a recall of 55%. Last, but not least, we noticed how TEDIOUS leverages readability, size and complexity metrics, as well as some warnings raised by static analysis tools.",Propose,"Fiorella Zampetti
Cedric Noiseux
Giuliano Antoniol
Foutse Khomh
Massimiliano Di Penta",Academia,"2,017.00",International Conference on Software Maintenance and Evolution,Conference,http://doi.org/10.1109/ICSME.2017.44,"@INPROCEEDINGS{Zampetti2017-bi,
  title           = ""Recommending when Design Technical Debt Should be
                     {Self-Admitted}"",
  booktitle       = ""2017 {IEEE} International Conference on Software
                     Maintenance and Evolution ({ICSME})"",
  author          = ""Zampetti, Fiorella and Noiseux, Cedric and Antoniol,
                     Giuliano and Khomh, Foutse and Di Penta, Massimiliano"",
  publisher       = ""IEEE"",
  month           =  sep,
  year            =  2017,
  conference      = ""2017 IEEE International Conference on Software Maintenance
                     and Evolution (ICSME)"",
  location        = ""Shanghai""
}","To achieve this

goal, we have developed a machine learning approach named TE-
DIOUS (TEchnical Debt IdentificatiOn System), which leverages

various kinds of method-level features as independent variables,
including source code structural metrics, readability metrics and,
last but not least, warnings raised by static analysis tools.","CheckStyle
PMD"
51,S52,Compiling Static Software Metrics for Reliability and Maintainability from GitHub Repositories,"This paper identifies a small, essential set of static software code metrics linked to the software product quality characteristics of reliability and maintainability and to the most commonly identified sources of technical debt. A plug-in is created for the Understand code visualization and static analysis tool that calculates and aggregates the metrics. The plug-in produces a high-level interactive html report as well as developer-level information needed to address quality issues using Understand. A script makes Use of Git, Understand, and the plug-in to compile results for a list of GitHub repositories into a single file. The primary contribution of this work is to describe an open-source plug-in to measure and visualize architectural complexity based on the propagation cost and core size metrics, which are not currently found in other tools. The plug-in should be Useful to researchers and practitioners interested in these two metrics and as an expedient starting Cite to experimentation with metric collection and aggregation for groups of GitHub repositories. The plug-in was developed as a first step in an ongoing project aimed at applying case-based reasoning to the issue of software product quality.",Use,"Jeremy Ludwig
Steven Xu
Frederick Webber",Both,"2,017.00","International Conference on Systems, Man, and Cybernetics",Conference,https://doi.org/10.1109/SMC.2017.8122569,"@INPROCEEDINGS{Ludwig2017-dp,
  title           = ""Compiling static software metrics for reliability and
                     maintainability from {GitHub} repositories"",
  booktitle       = ""2017 {IEEE} International Conference on Systems, Man, and
                     Cybernetics ({SMC})"",
  author          = ""Ludwig, Jeremy and Xu, Steven and Webber, Frederick"",
  publisher       = ""IEEE"",
  month           =  oct,
  year            =  2017,
  conference      = ""2017 IEEE International Conference on Systems, Man and
                     Cybernetics (SMC)"",
  location        = ""Banff, AB""
}","A plug-in is
created for the Understand code visualization and static analysis
tool that calculates and aggregates the metrics. The plug-in
produces a high-level interactive html report as well as
developer-level information needed to address quality issues
using Understand.","Understand
CBR Insight"
52,S53,Improving Object-Oriented Design ality: A Portfolio and Measurement-Based Approach,"Current software development trends have shortened release cycles and forced developers to implement short-term solutions that cannot cope with increasing product complexity. This phenomenon of introducing hasty design choices or applying bad design practices becomes something known as technical debt, in particular design debt. To pay off this debt, the literature offers approaches for identifying these design flaws; however, few methods for properly prioritizing investment efforts are available. In this paper, we Propose an approach that supports the decision-making process regarding design improvements. It identifies violations of design best practices that are then arranged within a two-dimensional portfolio matrix. This matrix combines the importance of practices of design quality with actual achievement relative to a benchmark suite. To show the application of the approach in a quality-improvement process, we performed a feasibility study on three open-source projects and a benchmark suite containing 50 projects. This study clearly shows that the importance of the design best practices greatly impacts the improvement decisions and must be aligned with the strategic quality goals of the product.",Propose,"Johannes Bräuer
Reinhold Plösch
Matthias Saft
Christian Körner",Both,"2,017.00",International Workshop on Software Measurement,Workshop,http://doi.org/10.1145/3143434.3143454,"@INPROCEEDINGS{Brauer2017-ja,
  title           = ""Improving object-oriented design quality"",
  booktitle       = ""Proceedings of the 27th International Workshop on Software
                     Measurement and 12th International Conference on Software
                     Process and Product Measurement"",
  author          = ""Br{\""a}uer, Johannes and Saft, Matthias and Pl{\""o}sch,
                     Reinhold and K{\""o}rner, Christian"",
  publisher       = ""ACM"",
  month           =  oct,
  year            =  2017,
  address         = ""New York, NY, USA"",
  copyright       = ""http://www.acm.org/publications/policies/copyright\_policy\#Background"",
  conference      = ""IWSM/Mensura '17: 27th International Workshop on Software
                     Measurement and 12th International Conference on Software
                     Process and Product Measurement"",
  location        = ""Gothenburg Sweden""
}","In this paper, we Propose an approach that supports the decision-making process re-
garding design improvements. It identies violations of design best practices that are then arranged within a two-dimensional portfolio matrix.","MUSE
SonarQube"
53,S54,What if I had no smells?,"What would have happened if I did not have any code smell? This is an interesting question that no previous study, to the best of our knowledge, has tried to answer. In this paper, we present a method for implementing a what-if scenario analysis estimating the number of defective files in the absence of smells. Our industrial case study shows that 20% of the total defective files were likely avoidable by avoiding smells. Such estimation needs to be Used with the due care though as it is based on a hypothetical history (i.e., zero number of smells and same process and product change characteristics). Specifically, the number of defective files could even increase for some types of smells. In addition, we note that in some circumstances, accepting code with smells might still be a good option for a company.",Use,"Davide Falessi
Barbara Russo
Kathleen Mullen",Both,"2,017.00",International Symposium on Empirical Software Engineering and Measurement,Conference,https://doi.org/10.1109/esem.2017.14,"@inproceedings{Falessi_2017,
	doi = {10.1109/esem.2017.14},
	url = {https://doi.org/10.1109/esem.2017.14},
	year = 2017,
	month = {nov},
	publisher = {{IEEE}},
	author = {Davide Falessi and Barbara Russo and Kathleen Mullen},
	title = {What if I Had No Smells?},
	booktitle = {2017 {ACM}/{IEEE} International Symposium on Empirical Software Engineering and Measurement ({ESEM})}
}
","This is an interesting question that no previous study, to
the best of our knowledge, has tried to answer. In this paper, we
present a method for implementing a what-if scenario analysis
estimating the number of defective files in the absence of smells.",SonarQube
54,S55,Who is Producing More Technical Debt? A Personalized Assessment of TD Principal,"Technical debt (TD) impedes software projects by reducing the velocity of development teams during software evolution. Although TD is usually assessed on either the entire system or on individual software artifacts, it is the actual craftsmanship of developers that caUses the accumulation of TD. In the light of extremely high maintenance costs, efficient software project management cannot occur without recognizing the relation between developer characteristics and the tendency to evoke violations that lead to TD. In this paper, we investigate three research questions related to the distribution of TD among the developers of a software project, the types of violations caUsed by each developer and the relation between developers’ maturity and the tendency to accumulate TD. The study has been performed on four widely employed PHP open-source projects. All developers’ personal characteristics have been anonymized in the study.",Use,"Theodoros Amanatidis
Alexander Chatzigeorgiou
Apostolos Ampatzoglou
Ioannis Stamelos",Academia,"2,017.00",International Conference on Agile Software Development,Conference,https://doi.org/10.1145/3120459.3120464,"@INPROCEEDINGS{Amanatidis2017-yd,
  title           = ""Who is producing more technical debt?"",
  booktitle       = ""Proceedings of the {XP2017} Scientific Workshops"",
  author          = ""Amanatidis, Theodoros and Chatzigeorgiou, Alexander and
                     Ampatzoglou, Apostolos and Stamelos, Ioannis"",
  publisher       = ""ACM"",
  month           =  may,
  year            =  2017,
  address         = ""New York, NY, USA"",
  copyright       = ""http://www.acm.org/publications/policies/copyright\_policy\#Background"",
  conference      = ""XP '17 Workshops: Proceedings of the Scientific Workshops
                     of XP2017"",
  location        = ""Cologne Germany""
}","In this paper, we investigate three
research questions related to the distribution of TD among the
developers of a software project, the types of violations caUsed by
each developer and the relation between developers’ maturity and
the tendency to accumulate TD.",SonarQube
55,S56,Correlations of Software Code Metrics: An Empirical Study,"Background: The increasing up-trend of software size brings about challenges related to release planning and maintainability. Foreseeing the growth of software metrics can assist in taking proactive decisions regarding different areas where software metrics play vital roles. For example, source code metrics are Used to automatically calculate technical debt related to code quality which may indicate how maintainable a software is. Thus, predicting such metrics can give us an indication of technical debt in the future releases of software. Objective: Estimation or prediction of software metrics can be performed more meaningfully if the relationships between different domains of metrics and relationships between the metrics and different domains are well understood. To understand such relationships, this empirical study has collected 25 metrics classified into four domains from 9572 software revisions of 20 open source projects from 8 well-known companies. Results: We found software size related metrics are most correlated among themselves and with metrics from other domains. Complexity and documentation related metrics are more correlated with size metrics than themselves. Metrics in the duplications domain are observed to be more correlated to themselves on a domain-level. However, a metric to domain level relationship exploration reveals that metrics with most strong correlations are in fact connected to size metrics. The Overall correlation ranking of duplication metrics are least among all domains and metrics. Contribution: Knowledge earned from this research will help to understand inherent relationships between metrics and domains. This knowledge together with metric-level relationships will allow building better predictive models for software code metrics.",Use,"Md Abdullah Al Mamun
Christian Berger
Jörgen Hansson",Academia,"2,017.00",International Workshop on Software Measurement,Conference,https://doi.org/10.1145/3143434.3143445,"@inproceedings{10.1145/3143434.3143445,
author = {Mamun, Md Abdullah Al and Berger, Christian and Hansson, J\""{o}rgen},
title = {Correlations of Software Code Metrics: An Empirical Study},
year = {2017},
isbn = {9781450348539},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3143434.3143445},
doi = {10.1145/3143434.3143445},
booktitle = {Proceedings of the 27th International Workshop on Software Measurement and 12th International Conference on Software Process and Product Measurement},
pages = {255–266},
numpages = {12},
keywords = {software engineering, spearman's rank correlation, correlation of metrics, software code metrics},
location = {Gothenburg, Sweden},
series = {IWSM Mensura '17}
}","To understand such relationships, this empirical study has collected 25 metrics classi-
fied into four domains from 9572 software revisions of 20 open source projects from 8 well-known companies.",SonarQube
56,S57,Identifying self-admitted technical debt in open source projects using text mining,"Technical debt is a metaphor to describe the situation in which long-term code quality is traded for short-term goals in software projects. Recently, the concept of self-admitted technical debt (SATD) was Proposed, which considers debt that is intentionally introduced, e.g., in the form of quick or temporary fixes. Prior work on SATD has shown that source code comments can be Used to successfully detect SATD, however, most current state-of-the-art classification approaches of SATD rely on manual inspection of the source code comments. In this paper, we Proposed an automated approach to detect SATD in source code comments using text mining. In our approach, we utilize feature selection to select Useful features for classifier training, and we combine multiple classifiers from different source projects to build a composite classifier that identifies SATD comments in a target project. We investigate the performance of our approach on 8 open source projects that contain 212,413 comments. Our experimental results show that, on every target project, our approach outperforms the state-of-the-art and the baselines approaches in terms of F1-score. The F1-score achieved by our approach ranges between 0.518 - 0.841, with an average of 0.737, which improves over the state-of-the-art approach Proposed by Potdar and Shihab by 499.19%. When Compared with the text mining-based baseline approaches, our approach significantly improves the average F1-score by at least 58.49%. When Compared with a natural language processing-based baseline, our approach also significantly improves its F1-score by 27.95%. Our Proposed approach can be Used by project personnel to effectively identify SATD with minimal manual effort.",Propose,"Qiao Huang
Emad Shihab
Xin Xia
David Lo
Shanping Li",Academia,"2,017.00",Empirical Software Engineering,Journal,http://doi.org/10.1007/s10664-017-9522-4,"@article{Huang_2017,
	doi = {10.1007/s10664-017-9522-4},
	url = {https://doi.org/10.1007%2Fs10664-017-9522-4},
	year = 2017,
	month = {may},
	publisher = {Springer Science and Business Media {LLC}},
	volume = {23},
	number = {1},
	pages = {418--451},
	author = {Qiao Huang and Emad Shihab and Xin Xia and David Lo and Shanping Li},
	title = {Identifying self-admitted technical debt in open source projects using text mining},
	journal = {Empirical Software Engineering}
}","In this paper, we Proposed an automated approach to detect SATD in source code comments",Proposed by the author
57,S58,SATD Detector: A Text-Mining-Based Self-Admitted Technical Debt Detection Tool,"In software projects, technical debt metaphor is Used to describe the situation where developers and managers have to accept compromises in long-term software quality to achieve short-term goals. There are many types of technical debt, and self-admitted technical debt (SATD) was Proposed recently to consider debt that is introduced intentionally (e.g., through temporary fix) and admitted by developers themselves. Previous work has shown that SATD can be successfully detected using source code comments. However, most current state-of-the-art approaches identify SATD comments through pattern matching, which achieve high precision but very low recall. That means they may miss many SATD comments and are not practical enough. In this paper, we Propose SATD Detector, a tool that is able to (i) automatically detect SATD comments using text mining and (ii) highlight, list and manage detected comments in an integrated development environment (IDE). This tool consists of a Java library and an Eclipse plug-in. The Java library is the back-end, which provides command-line interfaces and Java APIs to re-train the text mining model using Users' data and automatically detect SATD comments using either the build-in model or a User-specified model. The Eclipse plug-in, which is the front-end, first leverages our pre-trained composite classifier to detect SATD comments, and then highlights and marks these detected comments in the source code editor of Eclipse. In addition, the Eclipse plug-in provides a view in IDE which collects all detected comments for management.",Propose,"Zhongxin Liu
Qiao Huang
Xin Xia
Emad Shihab
David Lo
Shanping Li",Academia,"2,018.00",International Conference on Software Engineering,Conference,https://doi.org/10.1145/3183440.3183478,"@INPROCEEDINGS{Liu2018-ci,
  title           = ""{SATD} detector"",
  booktitle       = ""Proceedings of the 40th International Conference on
                     Software Engineering: Companion Proceeedings"",
  author          = ""Liu, Zhongxin and Huang, Qiao and Xia, Xin and Shihab,
                     Emad and Lo, David and Li, Shanping"",
  publisher       = ""ACM"",
  month           =  may,
  year            =  2018,
  address         = ""New York, NY, USA"",
  copyright       = ""http://www.acm.org/publications/policies/copyright\_policy\#Background"",
  conference      = ""ICSE '18: 40th International Conference on Software
                     Engineering"",
  location        = ""Gothenburg Sweden""
}
","In this paper, we Propose SATD Detector, a tool that is able to (i) automatically detect SATD comments using text mining and (ii) highlight, list and manage detected comments in an integrated development environment (IDE). This tool consists of a Java library and an Eclipse plug-in.",SATD Detector
58,S59,Identifying and Prioritizing Architectural Debt Through Architectural Smells: A Case Study in a Large Software Company,"Architectural technical debt can have a huge impact on software maintainability and evolution. Hence, di↵erent architectural violations, detected as architectural smells, need to be identified and refactored. In this paper, we conducted a multiple case-study on several architectural smells detected in four industrial projects. We conducted an
in-depth investigation with a questionnaire, interviews and thorough inspection of the code with the practitioners. We evaluated the negative
impact of the technical debt detected by the architectural smells, their
diculty to be refactored and the Usefulness of the detection tool. The
results show that practitioners appreciated the help of automatic detection, and that they prioritize refactoring architectural debt that caUses
more negative impact despite the higher refactoring e↵ort",Use,"Antonio Martini
Francesca Arcelli Fontana
Andrea Biaggi
Riccardo Roveda",Both,"2,018.00",European Conference on Software Architecture,Conference,https://doi.org/10.1007/978-3-030-00761-4_21,"@INCOLLECTION{Martini2018-hy,
  title     = ""Identifying and prioritizing architectural debt through
               architectural smells: A case study in a large software company"",
  booktitle = ""Software Architecture"",
  author    = ""Martini, Antonio and Fontana, Francesca Arcelli and Biaggi,
               Andrea and Roveda, Riccardo"",
  publisher = ""Springer International Publishing"",
  pages     = ""320--335"",
  series    = ""Lecture notes in computer science"",
  year      =  2018,
  address   = ""Cham""
}
","In this paper, we conducted a multiple case-study on several architectural smells detected in four industrial projects.",Arcan
59,S60,An Architectural Smells Detection Tool for C and C++ projects,"Architectural smells gained great attention in the past few years since they directly affect software quality and increase architectural technical debt. However, while it is straightforward to understand why they are important, it is more difficult to find techniques and tools to detect and remove architectural smells. The purpose of this paper is to introduce an open-source tool for automatic architectural smells detection for C/C++ projects, by creating an abstraction of the project and defining the concept of dependency between elements belonging to the project in order to identify architectural smells. The tool has been validated on some open-source projects with promising results.",Propose,"Andrea Biaggi
Francesca Arcelli Fontana
Riccardo Roveda",Academia,"2,018.00",Euromicro Conference on Software Engineering and Advanced Applications,Conference,http://doi.org/10.1109/SEAA.2018.00074,"@INPROCEEDINGS{Biaggi2018-sk,
  title           = ""An architectural smells detection tool for {C} and C++
                     projects"",
  booktitle       = ""2018 44th Euromicro Conference on Software Engineering and
                     Advanced Applications ({SEAA})"",
  author          = ""Biaggi, Andrea and Arcelli Fontana, Francesca and Roveda,
                     Riccardo"",
  publisher       = ""IEEE"",
  month           =  aug,
  year            =  2018,
  conference      = ""2018 44th Euromicro Conference on Software Engineering and
                     Advanced Applications (SEAA)"",
  location        = ""Prague""
}","The purpose of this paper is to introduce an open-
source tool for automatic architectural smells detection for C/C++

projects, by creating an abstraction of the project and defining
the concept of dependency between elements belonging to the
project in order to identify architectural smells.",ARCAN FOR C/C++
60,S61,Experiences Applying Automated Architecture Analysis Tool Suites,"In this paper, we report our experiences of applying three complementary automated software architecture analysis techniques, supported by a tool suite, called DV8, to 8 industrial projects within a large company. DV8 includes two state-of-the-art architecture-level maintainability metrics-Decoupling Level and Propagation Cost, an architecture flaw detection tool, and an architecture root detection tool. We collected development process data from the project teams as input to these tools, reported the results back to the practitioners, and followed up with telephone conferences and interviews. Our experiences revealed that the metrics scores, quantitative debt analysis, and architecture flaw visualization can effectively bridge the gap between management and development, help them decide if, when, and where to refactor. In particular, the metrics scores, Compared against industrial benchmarks, faithfully reflected the practitioners' intuitions about the maintainability of their projects, and enabled them to better understand the maintainability relative to other projects internal to their company, and to other industrial products. The automatically detected architecture flaws and roots enabled the practitioners to precisely pinCite, visualize, and quantify the “hotspots” within the systems that are responsible for high maintenance costs. Except for the two smallest projects for which both architecture metrics indicated high maintainability, all other projects are planning or have already begun refactorings to address the problems detected by our analyses. We are working on further automating the tool chain, and transforming the analysis suite into deployable services accessible by all projects within the company.",Propose,"Ran Mo
Will Snipes
Yuanfang Cai
Srini Ramaswamy
Rick Kazman
Martin Naedele",Both,"2,018.00",International Conference on Automated Software Engineering,Conference,https://doi.org/10.1145/3238147.3240467,"@INPROCEEDINGS{Mo2018-us,
  title      = ""Experiences applying automated architecture analysis tool
                suites"",
  booktitle  = ""Proceedings of the 33rd {ACM/IEEE} International Conference on
                Automated Software Engineering"",
  author     = ""Mo, Ran and Snipes, Will and Cai, Yuanfang and Ramaswamy, Srini
                and Kazman, Rick and Naedele, Martin"",
  publisher  = ""ACM"",
  month      =  sep,
  year       =  2018,
  address    = ""New York, NY, USA"",
  copyright  = ""http://www.acm.org/publications/policies/copyright\_policy\#Background"",
  conference = ""ASE '18: 33rd ACM/IEEE International Conference on Automated
                Software Engineering"",
  location   = ""Montpellier France""
}","In this paper, we report our experiences of applying three com-
plementary automated software architecture analysis techniques,

supported by a tool suite, called DV8, to 8 industrial projects within

a large company.","DV8
Understand"
61,S62,Towards an Architectural Debt Index,"Different indexes have been Proposed to evaluate software quality and technical debt. Usually these indexes take into account different code level issues and several metrics, well known software metrics or new ones defined ad hoc for a specific purpose. In this paper we Propose and define a new index, more oriented to the evaluation of architectural violations. We describe in detail the index, called Architectural Debt Index, that we integrated in a tool developed for architectural smell detection. The index is based on the detection of architectural smells, their criticality and their history. Currently only dependency architectural smells have been considered, but other architectural debt indicators can be considered and integrated in the index computation.",Propose,"Riccardo Roveda
Francesca Arcelli Fontana
Ilaria Pigazzini
Marco Zanoni",Both,"2,018.00",Euromicro Conference on Software Engineering and Advanced Applications,Conference,http://doi.org/10.1109/SEAA.2018.00073,"@INPROCEEDINGS{Roveda2018-dj,
  title           = ""Towards an Architectural Debt Index"",
  booktitle       = ""2018 44th Euromicro Conference on Software Engineering and
                     Advanced Applications ({SEAA})"",
  author          = ""Roveda, Riccardo and Arcelli Fontana, Francesca and
                     Pigazzini, Ilaria and Zanoni, Marco"",
  publisher       = ""IEEE"",
  month           =  aug,
  year            =  2018,
  conference      = ""2018 44th Euromicro Conference on Software Engineering and
                     Advanced Applications (SEAA)"",
  location        = ""Prague""
}","In this paper we Propose and define a new index, more
oriented to the evaluation of architectural violations. We describe
in detail the index, called Architectural Debt Index, that we
integrated in a tool developed for architectural smell detection.","Arcan
Sonargraph
SonarQube
CAST
Structure101
Massey Architecture Explorer
Lattix
STAN"
62,S63,Technical Debt in Model Transformation Specifications,"Model transformations (MT), as with any other software artifact, may contain quality flaws. Even if a transformation is functionally correct, such flaws will impair maintenance activities such as enhancement and porting. The concept of technical debt (TD) models the impact of such flaws as a burden carried by the software which must either be settled in a ‘lump sum’ to eradicate the flaw, or paid in the ongoing additional costs of maintaining the software with the flaw. In this paper we investigate the characteristics of technical debt in model transformations, analysing a range of MT cases in different MT languages, and using measures of quality flaws or ‘bad smells’ for MT, adapted from code measures.

Based on these measures we identify significant differences in the level and kinds of technical debt in different MT languages, and we Propose ways in which TD can be reduced.",Use,"Kevin Lano
Shekoufeh Kolahdouz-Rahimi
Mohammadreza Sharbaf
Hessa Alfraihi",Academia,"2,018.00",International Conference on Theory and Practice of Model Transformations,Conference,https://doi.org/10.1007/978-3-319-93317-7_6,"@incollection{Lano2018,
  doi = {10.1007/978-3-319-93317-7_6},
  url = {https://doi.org/10.1007/978-3-319-93317-7_6},
  year = {2018},
  publisher = {Springer International Publishing},
  pages = {127--141},
  author = {Kevin Lano and Shekoufeh Kolahdouz-Rahimi and Mohammadreza Sharbaf and Hessa Alfraihi},
  title = {Technical Debt in Model Transformation Specifications},
  booktitle = {Theory and Practice of Model Transformation}
}","Based on these measures we identify significant differences in the level
and kinds of technical debt in different MT languages, and we Propose
ways in which TD can be reduced.",PMD
63,S64,Smelly Relations: Measuring and Understanding Database Schema Quality,"Context: Databases are an integral element of enterprise applications. Similarly to code, database schemas are also prone to smells - best practice violations. Objective: We aim to explore database schema quality, associated characteristics and their relationships with other software artifacts. Method: We present a catalog of 13 database schema smells and elicit developers' perspective through a survey. We extract embedded SQL statements and identify database schema smells by employing the DbDeo tool which we developed. We analyze 2925 production-quality systems (357 industrial and 2568 well-engineered open-source projects) and empirically study quality characteristics of their database schemas. In total, we analyze 629 million lines of code containing more than 393 thousand SQL statements. Results: We find that the index abUse smell occurs most frequently in database code, that the Use of an ORM framework doesn't immune the application from database smells, and that some database smells, such as adjacency list, are more prone to occur in industrial projects Compared to open-source projects. Our co-occurrence analysis shows that whenever the clone table smell in industrial projects and the values in attribute definition smell in open-source projects get spotted, it is very likely to find other database smells in the project. Conclusion: The awareness and knowledge of database smells are crucial for developing high-quality software systems and can be enhanced by the adoption of better tools helping developers to identify database smells early.",Propose,"Tushar Sharma
Marios Fragkoulis
Stamatia Rizou
Magiel Bruntink
Diomidis Spinellis",Academia,"2,018.00",International Conference on Software Engineering: Software Engineering in Practice,Conference,https://doi.org/10.1145/3183519.3183529,"@inproceedings{Sharma_2018,
	doi = {10.1145/3183519.3183529},
	url = {https://doi.org/10.1145%2F3183519.3183529},
	year = 2018,
	month = {may},
	publisher = {{ACM}},
	author = {Tushar Sharma and Marios Fragkoulis and Stamatia Rizou and Magiel Bruntink and Diomidis Spinellis},
	title = {Smelly relations},
	booktitle = {Proceedings of the 40th International Conference on Software Engineering: Software Engineering in Practice}
}
","We aim to explore database schema quality, associated characteristics and their relationships with other software artifacts.",DbDeo
64,S65,Evaluating Domain-Specific Metric Thresholds: An Empirical Study,"Software metrics and thresholds provide means to quantify several quality attributes of software systems. Indeed, they have been Used in a wide variety of methods and tools for detecting different sorts of technical debts, such as code smells. Unfortunately, these methods and tools do not take into account characteristics of software domains, as the intrinsic complexity of geo-localization and scientific software systems or the simple protocols employed by messaging applications. Instead, they rely on generic thresholds that are derived from heterogeneous systems. Although derivation of reliable thresholds has long been a concern, we still lack empirical evidence about threshold variation across distinct software domains. To tackle this limitation, this paper investigates whether and how thresholds vary across domains by presenting a large-scale study on 3,107 software systems from 15 domains. We analyzed the derivation and distribution of thresholds based on 8 well-known source code metrics. As a result, we observed that software domain and size are relevant factors to be considered when building benchmarks for threshold derivation. Moreover, we also observed that domain-specific metric thresholds are more appropriated than generic ones for code smell detection.",Use,"Allan Mori
Gustavo Vale
Markos Viggiato
Johnatan Oliveira
Eduardo Figueiredo
Elder Cirilo
Pooyan Jamshidi
Christian Kastner",Academia,"2,018.00",International Conference on Technical Debt,Conference,https://doi.org/10.1145/3194164.3194173,"@inproceedings{Mori_2018,
	doi = {10.1145/3194164.3194173},
	url = {https://doi.org/10.1145%2F3194164.3194173},
	year = 2018,
	month = {may},
	publisher = {{ACM}},
	author = {Allan Mori and Gustavo Vale and Markos Viggiato and Johnatan Oliveira and Eduardo Figueiredo and Elder Cirilo and Pooyan Jamshidi and Christian Kastner},
	title = {Evaluating domain-specific metric thresholds},
	booktitle = {Proceedings of the 2018 International Conference on Technical Debt}
}","To tackle this limitation, this paper investigates whether and how
thresholds vary across domains by presenting a large-scale study on
3,107 software systems from 15 domains.",CK
65,S66,Code smells and their collocations: A large-scale experiment on open-source systems,"Code smells indicate possible flaws in software design, that could negatively affect system’s maintainability. Interactions among smells located in the same classes (i.e., collocated smells) have even more detrimental effect on quality. Extracted frequent patterns of collocated smells could help to understand practical consequences of collocations. In this paper we identify and empirically validate frequent collocations of 14 code smells detected in 92 Java systems, using three approaches: pairwise correlation analysis, PCA and associative rules. To cross-validate the results, we Used up to 6 detectors for each smell. Additionally, we examine and Compare techniques Used to extract the relationships. The contribution is three-fold: (1) we identify and empirically validate relationships among the examined code smells on a large dataset that we made publicly available, (2) we discuss how the choice of code smell detectors affects results, and (3) we analyze the impact of software domain on existence of the smell collocations. Additionally, we found that analytical methods we Used to discover collocations, are complementary. Smells collocations display recurring patterns that could help prioritizing the classes affected by code smells to be refactored and developing or enhancing detectors exploiting information about collocations. They can also help the developers focusing on classes deserving more maintenance effort.",Use,"Bartosz Walter
Francesca Arcelli Fontana 
Vincenzo Ferme",Academia,"2,018.00",Journal of Systems and Software,Journal,,"@article{WALTER20181,
title = {Code smells and their collocations: A large-scale experiment on open-source systems},
journal = {Journal of Systems and Software},
volume = {144},
pages = {1-21},
year = {2018},
issn = {0164-1212},
doi = {https://doi.org/10.1016/j.jss.2018.05.057},
url = {https://www.sciencedirect.com/science/article/pii/S0164121218301109},
author = {Bartosz Walter and Francesca Arcelli Fontana and Vincenzo Ferme},
keywords = {Code smells, Inter-smell relationships, Smell interaction, Collocated smells, Code smell detectors, Source code quality}
}",,"Ai Reviewer
PMD
CheckStyle"
66,S67,Support for Architectural Smell Refactoring,"To preserve high quality of a project, it is necessary to perform many refactoring steps during the development and maintenance phases. Code refactoring received a great attention in the literature, often directed to the refactoring of code smells. While at the architectural level, architectural smells received less attention. One of the most common architectural smell which may affect many parts of a software application is the Cyclic Dependency smell. This position paper presents a tool prototype that suggests which path a developer could follow to remove Cyclic Dependency smells in Java applications. The tool has been developed as an extension of the Arcan tool for architectural smells detection. In this paper we describe how the tool identifies the path to follow for the refactoring of Cyclic Dependency on real projects. The tool has been thought only to suggest a possible refactoring approach which a developer could considerate to resolve Cyclic Dependency.",Propose,,Academia,"2,018.00",International Workshop on Refactoring,Conference,,"@inproceedings{10.1145/3242163.3242165,
author = {Rizzi, Luca and Fontana, Francesca Arcelli and Roveda, Riccardo},
title = {Support for Architectural Smell Refactoring},
year = {2018},
isbn = {9781450359740},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3242163.3242165},
doi = {10.1145/3242163.3242165},
booktitle = {Proceedings of the 2nd International Workshop on Refactoring},
pages = {7–10},
numpages = {4},
keywords = {Cyclic Dependency, Architectural Smells, Architectural Refactoring},
location = {Montpellier, France},
series = {IWoR 2018}
}",,
67,S68,Towards anticipation of architectural smells using link prediction  techniques,"Software systems naturally evolve, and this evolution often brings design problems that caUse system degradation. Architectural smells are typical symptoms of such problems, and several of these smells are related to undesired dependencies among modules. The early detection of these smells is important for developers, becaUse they can plan ahead for maintenance or refactoring efforts, thus preventing system degradation. Existing tools for identifying architectural smells can detect the smells once they exist in the source code. This means that their undesired dependencies are already created. In this work, we explore a forward-looking approach that is able to infer groups of likely module dependencies that can anticipate architectural smells in a future system version. Our approach considers the current module structure as a network, along with information from previous versions, and applies link prediction techniques (from the field of social network analysis). In particular, we focus on dependency-related smells, such as Cyclic Dependency and Hub-like Dependency, which fit well with the link prediction model. An initial evaluation with two open-source projects shows that, under certain considerations, the predictions of our approach are satisfactory. Furthermore, the approach can be extended to other types of dependency-based smells or metrics.",Propose,,Academia,"2,018.00",International Working Conference on Source Code Analysis and Manipulation,Conference,,"@INPROCEEDINGS{8530719,  author={Díaz-Pace, Jorge Andrés and Tommasel, Antonela and Godoy, Daniela},  booktitle={2018 IEEE 18th International Working Conference on Source Code Analysis and Manipulation (SCAM)},   title={[Research Paper] Towards Anticipation of Architectural Smells Using Link Prediction Techniques},   year={2018},  volume={},  number={},  pages={62-71},  doi={10.1109/SCAM.2018.00015}}",,
68,S69,SARIF-enabled Tooling to Encourage Gradual Technical Debt Reduction,"SARIF is an emerging standard for representing the results of program analysis tools. This tool demo shows how it can enable integration between static analysis tools and version control systems such as GitHub, and by doing so, encourage developers to reduce technical debt in a gradual non-invasive fashion.",Propose,"Paul Anderson
Làucja Kot
Neil Gilmore
David Vitek",Industry,"2,019.00",International Conference on Technical Debt,Conference,http://doi.org/10.1109/TechDebt.2019.00024,"@INPROCEEDINGS{Anderson2019-iv,
  title           = ""{SARIF-enabled} tooling to encourage gradual technical
                     debt reduction"",
  booktitle       = ""2019 {IEEE/ACM} International Conference on Technical Debt
                     ({TechDebt})"",
  author          = ""Anderson, Paul and Kot, Lucja and Gilmore, Neil and Vitek,
                     David"",
  publisher       = ""IEEE"",
  month           =  may,
  year            =  2019,
  conference      = ""2019 IEEE/ACM International Conference on Technical Debt
                     (TechDebt)"",
  location        = ""Montreal, QC, Canada""
}
","This tool demo shows how analysis tool findings can be
automatically contributed as comments to the review process in
a similar way to how a human would make comments on the
parts of the code that have been changed.","SARIF
CodeSonarTM
Clang Static Analyzer
Pylint"
69,S70,TEAMSCALE: Tackle Technical Debt and Control the Quality of Your Software,"Teamscale is a software intelligence platform, that is, it creates transparency on code quality and the underlying software development process. This makes it possible for developers, testers and managers to better understand and control technical debt of their systems. In this paper, we give an overview of Teamscale and how this tool can be Used in practice to control and lower technical debt in the long run. We explain which code analyses can be Used to identify and address technical debt. Teamscale is available for free for research and teaching purposes at www.teamscale.io.",Propose,"Roman Haas
Rainer Niedermayr
Elmar Juergens",Industry,"2,019.00",International Conference on Technical Debt,Conference,http://doi.org/10.1109/TechDebt.2019.00016,"@INPROCEEDINGS{Haas2019-mx,
  title           = ""Teamscale: Tackle technical debt and control the quality
                     of your software"",
  booktitle       = ""2019 {IEEE/ACM} International Conference on Technical Debt
                     ({TechDebt})"",
  author          = ""Haas, Roman and Niedermayr, Rainer and Juergens, Elmar"",
  publisher       = ""IEEE"",
  month           =  may,
  year            =  2019,
  conference      = ""2019 IEEE/ACM International Conference on Technical Debt
                     (TechDebt)"",
  location        = ""Montreal, QC, Canada""
}
","In this paper, we give an overview
of TEAMSCALE and how this tool can be Used in practice to
control and lower technical debt in the long run. We explain
which code analyses can be Used to identify and address technical
debt.",TEAMSCALE
70,S71,How Deep is the Mud: Fathoming Architecture Technical Debt Using Designite,"The quality of software architecture is an important concern for any software development team. Architecture smells represent quality issues at architecture granularity. Identifying and refactoring them periodically is a necessity to keep architecture quality high. We present Designite, a software design quality assessment tool, that identifies seven well-known architecture smells. Along with the identification, the tool provides supplementary information such as caUse and responsible classes for each identified smell instance to help developers understand and refactor the smell. The tool is relevant and Useful in both research and practice context. Software developers may Use it to identify technical debt instances and to refactor them. On the other hand, software engineering researchers may Use the tool to carry out large-scale empirical studies concerning code smells.",Propose,Tushar Sharma,Academia,"2,019.00",International Conference on Technical Debt,Conference,http://doi.org/10.1109/TechDebt.2019.00018,"""@INPROCEEDINGS{Sharma2019-ew,
  title           = """"How deep is the mud: Fathoming architecture technical debt
                     using designite"""",
  booktitle       = """"2019 {IEEE/ACM} International Conference on Technical Debt
                     ({TechDebt})"""",
  author          = """"Sharma, Tushar"""",
  publisher       = """"IEEE"""",
  month           =  may,
  year            =  2019,
  conference      = """"2019 IEEE/ACM International Conference on Technical Debt
                     (TechDebt)"""",
  location        = """"Montreal, QC, Canada""""
}
""","""We present Designite, a software design

quality assessment tool, that identifies seven well-known archi-
tecture smells.""",Designite
71,S72,Mitigating Technical and Architectural Debt with Sonargraph,"Sonargraph is a static analyzer with a focus on software architecture and metrics. The motivation to create Sonargraph came from the assumption that architectural debt (aka structural debt) is the most toxic form of technical debt. Repairing a broken architecture requires global and high-risk changes, while fixing other forms of technical debt mostly involves low-risk local changes. Therefore, the tool enables architects and developers to formally describe their architectural blueprint using a custom DSL (domain specific language). Once defined architectural rules can be checked and enforced in an automated way in all stages of the development process. This guarantees that a software system will never end up as the notorious ""big ball of mud"". Sonargraph currently supports Java, C#, C/C++ and Python and is Used by hundreds of organizations worldwide.",Propose,Alexander von Zitzewitz,Industry,"2,019.00",International Conference on Technical Debt,Conference,http://doi.org/10.1109/TechDebt.2019.00022,"@INPROCEEDINGS{Von_Zitzewitz2019-xg,
  title           = ""Mitigating technical and architectural debt with
                     sonargraph"",
  booktitle       = ""2019 {IEEE/ACM} International Conference on Technical Debt
                     ({TechDebt})"",
  author          = ""von Zitzewitz, Alexander"",
  publisher       = ""IEEE"",
  month           =  may,
  year            =  2019,
  conference      = ""2019 IEEE/ACM International Conference on Technical Debt
                     (TechDebt)"",
  location        = ""Montreal, QC, Canada""
}
","Therefore, the tool enables
architects and developers to formally describe their
architectural blueprint using a custom DSL (domain specific
language). ",Sonargraph
72,S73,"TETRA, as a set of techniques and tools for calculating technical debt principal and interest","The paper covers the company's proprietary approach to the assessment of software product quality and measurement of technical debt. In the paper, the authors state that the software product quality is the amount of various technical debts embedded into the product and delivered to end-Users. Similar to the fact that any debt can be paid, the software product quality can be efficiently managed and measured by a set of techniques, parameters, and dimensions. The authors share the details of the company proprietary approach to technical debt management done with the help of the Technical DebT Reduction plAtform, TETRA. They share the measurement parameters, tools and major dimension for the assessment.",Propose,"Boris Kontsevoi
Elizabeth Soroka
Sergei Terekhov",Industry,"2,019.00",International Conference on Technical Debt,Conference,http://doi.org/10.1109/TechDebt.2019.00021,"@INPROCEEDINGS{Kontsevoi2019-ci,
  title           = ""{TETRA}, as a set of techniques and tools for calculating
                     technical debt principal and interest"",
  booktitle       = ""2019 {IEEE/ACM} International Conference on Technical Debt
                     ({TechDebt})"",
  author          = ""Kontsevoi, Boris and Soroka, Elizabeth and Terekhov,
                     Sergei"",
  publisher       = ""IEEE"",
  month           =  may,
  year            =  2019,
  conference      = ""2019 IEEE/ACM International Conference on Technical Debt
                     (TechDebt)"",
  location        = ""Montreal, QC, Canada""
}","The authors
share the details of the company proprietary approach to
technical debt management done with the help of the
Technical DebT Reduction plAtform, TETRA. They share the
measurement parameters, tools and major dimension for the
assessment.","SonarQube
TETRA"
73,S74,On the Accuracy of SonarQube Technical Debt Remediation Time,"[Context] The popularity of tools for software quality analysis has increased over the years, with special attention to tools that calculate technical debt based on violations of a set of rules. SonarQube is one of the most Used tools and provides an estimation of the time needed to remediate technical debt. However, practitioners are still skeptical about the accuracy of its remediation time estimation. [Objective] In this paper, we analyze the accuracy of SonarQube remediation time on a set of 15 open source Java projects. [Method] We designed and conducted a case study where we asked 65 novice developers to remove rule violations and reduce the technical debt of 15 projects. [Results] The results Cite out that SonarQube remediation time, Compared to the actual time for reducing technical debt, is generally overestimated, and that the most accurate estimation relates to code smells, while the least accurate concerns bugs. [Conclusions] Practitioners and researchers could benefit from the results of this work to understand up to which extent technical debt is overestimated and have a more accurate estimation of the remediation time.?",Compare,"Nyyti Saarimaki
Maria Teresa Baldassarre
Valentina Lenarduzzi
Simone Romano",Academia,"2,019.00",Euromicro Conference on Software Engineering and Advanced Applications,Conference,http://doi.org/10.1109/SEAA.2019.00055,"@INPROCEEDINGS{Saarimaki2019-kc,
  title           = ""On the accuracy of {SonarQube} technical debt remediation
                     time"",
  booktitle       = ""2019 45th Euromicro Conference on Software Engineering and
                     Advanced Applications ({SEAA})"",
  author          = ""Saarimaki, Nyyti and Baldassarre, Maria Teresa and
                     Lenarduzzi, Valentina and Romano, Simone"",
  publisher       = ""IEEE"",
  month           =  aug,
  year            =  2019,
  conference      = ""2019 45th Euromicro Conference on Software Engineering and
                     Advanced Applications (SEAA)"",
  location        = ""Kallithea-Chalkidiki, Greece""
}
","In this paper, we analyze
the accuracy of SonarQube remediation time on a set of 15
open source Java projects.",SonarQube
74,S75,PageRank and Criticality of Architectural Smells,"Architectural smells represent symptoms of problems at architectural level that can negatively impact internal software qualities and lead to architectural debt. Detecting architectural smells and identifying the most critical ones is the key to prioritize refactoring efforts and prevent software architecture erosion. In this paper we focus our attention on three architectural smells based on dependency issues, called Cyclic Dependency, Unstable Dependency, and Hub-Like Dependency. Moreover, we evaluate the PageRank and Criticality of these smells through the analysis of six projects. PageRank is a measure that estimates whether an architectural smell is located in an important part of the project, where the importance is evaluated according to how many parts of a project depend on the one involved in the architectural smell. We describe a case study on the analysis of the possible relation existing between the PageRank and Criticality of the smells. The results show how the two measures can be both Used to locate the architectural smells that need particular inspections and attention.",Use,"Francesca Arcelli Fontana
Ilaria Pigazzini
Claudia Raibulet
Stefano Basciano
Riccardo Roveda",Both,"2,019.00",European Conference on Software Architecture,Conference,https://doi.org/10.1145/3344948.3344982,"@inproceedings{Fontana2019,
  doi = {10.1145/3344948.3344982},
  url = {https://doi.org/10.1145/3344948.3344982},
  year = {2019},
  publisher = {{ACM} Press},
  author = {Francesca Arcelli Fontana and Ilaria Pigazzini and Claudia Raibulet and Stefano Basciano and Riccardo Roveda},
  title = {{PageRank} and criticality of architectural smells},
  booktitle = {Proceedings of the 13th European Conference on Software Architecture  - {ECSA} {\textquotesingle}19 - volume 2}
}","In this paper

we focus our attention on three architectural smells based on de-
pendency issues, called Cyclic Dependency, Unstable Dependency,

and Hub-Like Dependency. Moreover, we evaluate the PageRank
and Criticality of these smells through the analysis of six projects.","Arcan
Gephi"
75,S76,Are Static Analysis Violations Really Fixed? A Closer Look at Realistic Usage of SonarQube,"The Use of automatic static analysis tools (ASATs) has gained increasing attention in the last few years. Even though available research have already explored ASATs issues and how they are fixed, these studies rely on revisions of the software, instead of mining real usage of these tools and real issue reports. In this paper we contribute with a comprehensive, multi-method study about the usage of SonarQube (a popular static analysis tool), mining 421,976 issues from 246 projects in four different instance of SonarQube: two hosted in open-source communities (Eclipse and Apache) and two hosted in Brazilian government institutions (Brazilian Court of Account (TCU) and Brazilian Federal Police (PF)). We first surveyed team leaders of the analyzed projects and found that they mostly consider ASATs warning messages as relevant for overall software improvement. Second, we found that both Eclipse and TCU employ highly customized instance of SonarQube, with more than one thousand distinct checkers-though just a subset of these checkers actually led to issues' reports. Surprisingly, we found a low resolution rate per project in all organizations-on average, 13% of the issues have been solved in the systems. We conjecture that just a subset of the checkers reveal real design and coding flaws, and this might artificially increase the technical debt of the systems. Nevertheless, considering all systems, there is a central tendency(median) of fixing issues after 18.99 days they had been reported, faster than the period for fixing bugs as reported in previous studies.",Use,"Diego Marcilio
Rodrigo Bonifacio
Eduardo Monteiro
Edna Canedo
Welder Luz
Gustavo Pinto",Academia,"2,019.00",International Conference on Program Comprehension,Conference,http://doi.org/10.1109/ICPC.2019.00040,"@INPROCEEDINGS{Marcilio2019-mj,
  title           = ""Are static analysis violations really fixed? A closer look
                     at realistic usage of {SonarQube}"",
  booktitle       = ""2019 {IEEE/ACM} 27th International Conference on Program
                     Comprehension ({ICPC})"",
  author          = ""Marcilio, Diego and Bonifacio, Rodrigo and Monteiro,
                     Eduardo and Canedo, Edna and Luz, Welder and Pinto,
                     Gustavo"",
  publisher       = ""IEEE"",
  month           =  may,
  year            =  2019,
  copyright       = ""https://ieeexplore.ieee.org/Xplorehelp/downloads/license-information/IEEE.html"",
  conference      = ""2019 IEEE/ACM 27th International Conference on Program
                     Comprehension (ICPC)"",
  location        = ""Montreal, QC, Canada""
}","In this paper we contribute with a comprehensive, multi-method
study about the usage of SonarQube (a popular static analysis
tool), mining 421,976 issues from 246 projects in four different
instance of SonarQube: two hosted in open-source communities
(Eclipse and Apache) and two hosted in Brazilian government
institutions (Brazilian Court of Account (TCU) and Brazilian
Federal Police (PF)).","SonarQube
sonar-issues-miner"
76,S77,Reusing Code from StackOverflow: The Effect on Technical Debt,"Software reUse is a well-established software engineering process that aims at improving development productivity. Although reUse can be performed in a systematic way (e.g., through product lines), in practice, reUse is performed in many cases opportunistically, i.e., copying small code chunks either from the web or in-hoUse developed projects. Knowledge sharing communities and especially StackOverflow constitute the primary source of code-related information for amateur and professional software developers. Despite the obvious benefit of increased productivity, reUse can have a mixed effect on the quality of the resulting code depending on the properties of the reUsed solutions. An efficient concept for capturing a wide-range of internal software qualities is the metaphor of Technical Debt which expresses the impact of shortcuts in software development on its maintenance costs. In this paper, we present the results of an empirical study on the relation between the existence of reusing code retrieved from StackOverflow on the technical debt of the target system. In particular, we study several open-source projects and identify non-trivial pieces of code that exhibit a perfect or near-perfect match with code provided in the context of answers in StackOverflow. Then, we Compare the technical debt density of the reUsed fragments, obtained as the ratio of inefficiencies identified by SonarQube over the lines of reUsed code, to the technical debt density of the target codebase. The results provide insights to the potential impact of small-scale code reUse on technical debt and highlight the benefits of assessing code quality before committing changes to a repository.",Use,"Nikolaos Nikolaidis
Georgios Digkas
Apostolos Ampatzoglou
Alexander Chatzigeorgiou",Academia,"2,019.00",Euromicro Conference on Software Engineering and Advanced Applications,Conference,http://doi.org/10.1109/SEAA.2019.00022,"@INPROCEEDINGS{Digkas2019-gr,
  title           = ""Reusing code from {StackOverflow}: The effect on technical
                     debt"",
  booktitle       = ""2019 45th Euromicro Conference on Software Engineering and
                     Advanced Applications ({SEAA})"",
  author          = ""Digkas, Georgios and Nikolaidis, Nikolaos and Ampatzoglou,
                     Apostolos and Chatzigeorgiou, Alexander"",
  publisher       = ""IEEE"",
  month           =  aug,
  year            =  2019,
  copyright       = ""https://ieeexplore.ieee.org/Xplorehelp/downloads/license-information/IEEE.html"",
  conference      = ""2019 45th Euromicro Conference on Software Engineering and
                     Advanced Applications (SEAA)"",
  location        = ""Kallithea-Chalkidiki, Greece""
}","In this paper, we present the results
of an empirical study on the relation between the existence of
reusing code retrieved from StackOverflow on the technical debt
of the target system.","PMD
SonarQube"
77,S78,CBR Insight: Measure and Visualize Source Code Quality,"A critical aspect of software development is creating high-quality source code that is reliable, maintainable, and has limited technical debt. Software development teams generally employ a variety of design techniques, processes, and tools to continually work towards quality code while balancing the overall time and budget demands of the project. The goal of CBR Insight (CBRI) is to provide an objective and understandable measure of software quality that can help guide decisions and direct limited resources during software acquisition, development, and sustainment. CBRI supports the ability of technical and non-technical decision makers to verify that a project's software implementation follows through on promises around developing and sustaining reliable and maintainable software while managing technical debt.",Propose,"Jeremy Ludwig
Devin Cline",Industry,"2,019.00",International Conference on Technical Debt,Conference,http://doi.org/10.1109/TechDebt.2019.00017,"@INPROCEEDINGS{Ludwig2019-zx,
  title           = ""{CBR} insight: Measure and visualize source code quality"",
  booktitle       = ""2019 {IEEE/ACM} International Conference on Technical Debt
                     ({TechDebt})"",
  author          = ""Ludwig, Jeremy and Cline, Devin"",
  publisher       = ""IEEE"",
  month           =  may,
  year            =  2019,
  copyright       = ""https://ieeexplore.ieee.org/Xplorehelp/downloads/license-information/IEEE.html"",
  conference      = ""2019 IEEE/ACM International Conference on Technical Debt
                     (TechDebt)"",
  location        = ""Montreal, QC, Canada""
}","The goal of CBR Insight
(CBRI) is to provide an objective and understandable measure of
software quality that can help guide decisions and direct limited
resources during software acquisition, development, and

sustainment.",CBR Insight
78,S79,DV8: Automated Architecture Analysis Tool Suites,"This paper present our tool suite called DV8. The objective of DV8 is to measure software modularity, detect architecture anti-patterns as technical debts, quantify the maintenance cost of each instance of an anti-pattern, and enable return on investment analyses of architectural debts. Different from other tools, DV8 integrates data from both source code and revision history. We now elaborate on each of DV8's capabilities.",Propose,"Yuanfang Cai
Rick Kazman",Academia,"2,019.00",International Conference on Technical Debt,Conference,http://doi.org/10.1109/TechDebt.2019.00015,"@INPROCEEDINGS{Cai2019-da,
  title           = ""{DV8}: Automated architecture analysis tool suites"",
  booktitle       = ""2019 {IEEE/ACM} International Conference on Technical Debt
                     ({TechDebt})"",
  author          = ""Cai, Yuanfang and Kazman, Rick"",
  publisher       = ""IEEE"",
  month           =  may,
  year            =  2019,
  copyright       = ""https://ieeexplore.ieee.org/Xplorehelp/downloads/license-information/IEEE.html"",
  conference      = ""2019 IEEE/ACM International Conference on Technical Debt
                     (TechDebt)"",
  location        = ""Montreal, QC, Canada""
}","Here we present our tool suite called DV81. The objective
of DV8 is to measure software modularity, detect architecture
anti-patterns as technical debts, quantify the maintenance cost
of each instance of an anti-pattern, and enable return on
investment analyses of architectural debts.",DV8
79,S80,A Study on Architectural Smells Prediction,"Architectural smells can be detrimental to the system maintainability, evolvability and represent a source of architectural debt. Thus, it is very important to be able to understand how they evolved in the past and to predict their future evolution. In this paper, we evaluate if the existence of architectural smells in the past versions of a project can be Used to predict their presence in the future. We analyzed four Java projects in 295 Github releases and we applied for the prediction four different supervised learning models in a repeated cross-validation setting. We found that historical architectural smell information can be Used to predict the presence of architectural smells in the future. Hence, practitioners should carefully monitor the evolution of architectural smells and take preventative actions to avoid introducing them and stave off their progressive growth.",Use,"Francesca Arcelli Fontana
Paris Avgeriou
Ilaria Pigazzini
Riccardo Roveda",Both,"2,019.00",Euromicro Conference on Software Engineering and Advanced Applications,Conference,http://doi.org/10.1109/SEAA.2019.00057,"@INPROCEEDINGS{Arcelli_Fontana2019-hp,
  title           = ""A study on architectural smells prediction"",
  booktitle       = ""2019 45th Euromicro Conference on Software Engineering and
                     Advanced Applications ({SEAA})"",
  author          = ""Arcelli Fontana, Francesca and Avgeriou, Paris and
                     Pigazzini, Ilaria and Roveda, Riccardo"",
  publisher       = ""IEEE"",
  month           =  aug,
  year            =  2019,
  conference      = ""2019 45th Euromicro Conference on Software Engineering and
                     Advanced Applications (SEAA)"",
  location        = ""Kallithea-Chalkidiki, Greece""
}","In this paper, we evaluate if the existence of
architectural smells in the past versions of a project can be Used
to predict their presence in the future.","Arcan
Machine Learning Packages R"
80,S81,Towards an Autonomous Bot for Automatic Source Code Refactoring,"Continuous refactoring is necessary to maintain source code quality and to cope with technical debt. Since manual refactoring is inefficient and error-prone, various solutions for automated refactoring have been Proposed in the past. However, empirical studies have shown that these solutions are not widely accepted by software developers and most refactorings are still performed manually. For example, developers reported that refactoring tools should support functionality for reviewing changes. They also criticized that introducing such tools would require substantial effort for configuration and integration into the current development environment. In this paper, we present our work towards the Refactoring-Bot, an autonomous bot that integrates into the team like a human developer via the existing version control platform. The bot automatically performs refactorings to resolve code smells and presents the changes to a developer for asynchronous review via pull requests. This way, developers are not interrupted in their workflow and can review the changes at any time with familiar tools. Proposed refactorings can then be integrated into the code base via the push of a button. We elaborate on our vision, discuss design decisions, describe the current state of development, and give an outlook on planned development and research activities.",Propose,"Marvin Wyrich
Justus Bogner",Academia,"2,019.00",International Workshop on Bots in Software Engineering,Workshop,http://doi.org/10.1109/BotSE.2019.00015,"@INPROCEEDINGS{Wyrich2019-oh,
  title           = ""Towards an autonomous bot for automatic source code
                     refactoring"",
  booktitle       = ""2019 {IEEE/ACM} 1st International Workshop on Bots in
                     Software Engineering ({BotSE})"",
  author          = ""Wyrich, Marvin and Bogner, Justus"",
  publisher       = ""IEEE"",
  month           =  may,
  year            =  2019,
  copyright       = ""https://ieeexplore.ieee.org/Xplorehelp/downloads/license-information/IEEE.html"",
  conference      = ""2019 IEEE/ACM 1st International Workshop on Bots in
                     Software Engineering (BotSE)"",
  location        = ""Montreal, QC, Canada""
}","In this paper, we present our work towards the RefactoringBot, an autonomous bot that integrates into the team like a
human developer via the existing version control platform. The
bot automatically performs refactorings to resolve code smells
and presents the changes to a developer for asynchronous review
via pull requests.","Refactoring-Bot
SonarQube"
81,S82,Is Self-Admitted Technical Debt a Good Indicator of Architectural Divergences?,"Large software systems tend to be highly complex and often contain unaddressed issues that evolve from bad design practices or architectural implementations that drift from definition. These design flaws can originate from quick fixes, hacks or shortcuts to a solution, hence they can be seen as Technical Debt. Recently, new work has focUsed on studying source code comments that indicate Technical Debt, i.e., Self-Admitted Technical Debt (SATD). However, it is not known if addressing information left by developers in the form source code comments can give insight about the design flaws in a system and have the potential to provide fixes for bad architectural implementations. This paper investigates the possibility of using SATD comments to resolve architectural divergences. We leverage a data set of previously classified SATD comments to trace them to the architectural divergences of a large open source system, namely ArgoUML. We extract its conceptual and concrete architectures based on available design documentation and source code, and contrast both to expose divergences, trace them to SATD comments, and investigate their resolution. We found 7 high-level divergences in ArgoUML and 22 others among its subsystems, observing that merely 4 out of 29 (14%) divergences can be directly traced to SATD. Although using SATD as an indicator of architectural divergences is viable, the effort of doing so is time-intensive, and in general, will not lend to a significant reduction of architectural flaws in a software system.",Propose,"Giancarlo Sierra
Ahmad Tahmid
Emad Shihab
Nikolaos Tsantalis",Academia,"2,019.00","International Conference on Software Analysis, Evolution and Reengineering",Conference,https://doi.org/10.1109/SANER.2019.8667999,"@INPROCEEDINGS{Sierra2019-kq,
  title           = ""Is self-admitted technical debt a good indicator of
                     architectural divergences?"",
  booktitle       = ""2019 {IEEE} 26th International Conference on Software
                     Analysis, Evolution and Reengineering ({SANER})"",
  author          = ""Sierra, Giancarlo and Tahmid, Ahmad and Shihab, Emad and
                     Tsantalis, Nikolaos"",
  publisher       = ""IEEE"",
  month           =  feb,
  year            =  2019,
  copyright       = ""https://ieeexplore.ieee.org/Xplorehelp/downloads/license-information/IEEE.html"",
  conference      = ""2019 IEEE 26th International Conference on Software
                     Analysis, Evolution and Reengineering (SANER)"",
  location        = ""Hangzhou, China""
}","This paper investigates the possibility of using SATD comments to resolve architectural divergences. We leverage a data set of previously classified SATD comments to trace them
to the architectural divergences of a large open source system, namely ArgoUML.",Understand
82,S83,Understanding automated and human-based technical debt identification approaches-a two-phase study,"Context
The technical debt (TD) concept inspires the development of Useful methods and tools that support TD identification and management. However, there is a lack of evidence on how different TD identification tools could be complementary and, also, how human-based identification Compares with them.

Objective
To understand how to effectively elicit TD from humans, to investigate several types of tools for TD identification, and to understand the developers’ Cite of view about TD indicators and items reported by tools.

Method
We asked developers to identify TD items from a real software project. We also collected the output of three tools to automatically identify TD and Compared the results in terms of their locations in the source code. Then, we collected developers’ opinions on the identification process through a focus group.

Results
Aggregation seems to be an appropriate way to combine TD reported by developers. The tools Used cannot help in identifying many important TD types, so involving humans is necessary. Developers reported that the tools would help them to identify TD faster or more accurately and that project priorities and current development activities are important to be considered together, along with the values of principal and interest, when deciding to pay off a debt.

Conclusion
This work contributes to the TD landscape, which depicts an understanding between different TD types and how they are best discovered.",Cite,"Rodrigo O. Spínola
Nico Zazworka
Antonio Vetro
Forrest Shull
Carolyn Seaman",Academia,"2,019.00",Journal of the Brazilian Computer Society,Journal,https://doi.org/10.1186/s13173-019-0087-5,"@article{Sp_nola_2019,
	doi = {10.1186/s13173-019-0087-5},
	url = {https://doi.org/10.1186%2Fs13173-019-0087-5},
	year = 2019,
	month = {jun},
	publisher = {Springer Science and Business Media {LLC}},
	volume = {25},
	number = {1},
	author = {Rodrigo O. Sp{\'{\i}}nola and Nico Zazworka and Antonio Vetro and Forrest Shull and Carolyn Seaman},
	title = {Understanding automated and human-based technical debt identification approaches-a two-phase study},
	journal = {Journal of the Brazilian Computer Society}
}","To understand how to effectively elicit TD from humans, to investigate several types of tools for TD identification, and to understand the developers’ Cite of view about TD indicators and items reported by tools.","CodeVizard
FindBugs"
83,S84,VisminerTD: a tool for automatic identification and interactive monitoring of the evolution of technical debt items,"Technical debt (TD) contextualizes problems faced during software evolution considering the tasks that are not carried out adequately during software development. Software TD is a type of debt that brings a short-term benefit, but which may have to be paid with interest later on in the software development life cycle. Its presence brings risks to the project and can reduce its quality. It is worthwhile to have automatic mechanisms to monitor it, as TD monitoring requires the analysis of large amounts of complex data. Therefore, the combination of software metrics and code comment analysis, in the identification, and information visualization techniques, in monitoring, present themselves as a promising strategy to manage TD. This work presents VisminerTD, a tool that allows the automatic identification and interactive monitoring of the evolution of TD items by combining software metrics, code comment analysis, and information visualization. To evaluate its applicability, a feasibility study was carried out considering JUnit 4 and Apache Ant software projects. The results indicated that VisminerTD can support software development teams in monitoring TD items. In addition, a second case study was performed to assess the feasibility of the Proposed tool regarding its Usefulness, ease of Use, and self-predicted future Use. The results provided positive evidence on the Use of the Proposed tool, indicating (i) that it can be Useful in supporting TD Identification and TD monitoring activities and (ii) that it can bring gains in terms of comprehensiveness and efficacy when evaluating the desirable time to identify and monitor different types of debt. Given the current scenario characterized by limited options of tools that combine different information to support automatic identification and monitoring of the evolution of TD items in software projects, VisminerTD can approximate the state-of-the-art and the state-of-the-practice in the TD area, contributing to a wider dissemination of the concept.",Propose,"Thiago S. Mendes
Felipe G. S. Gomes
David P. Gonçalves
Manoel G. Mendonça
Renato L. Novais
Rodrigo O. Spínola",Academia,"2,019.00",Journal of the Brazilian Computer Society,Journal,https://doi.org/10.1186/s13173-018-0083-1,"@article{Mendes_2019,
        doi = {10.1186/s13173-018-0083-1},
        url = {https://doi.org/10.1186%2Fs13173-018-0083-1},
        year = 2019,
        month = {jan},
        publisher = {Springer Science and Business Media {LLC}},
        volume = {25},
        number = {1},
        author = {Thiago S. Mendes and Felipe G. S. Gomes and David P. Gon{\c{c}}alves and Manoel G. Mendon{\c{c}}a and Renato L. Novais and Rodrigo O. Sp{\'{\i}}nola},
        title = {{VisminerTD}: a tool for automatic identification and interactive monitoring of the evolution of technical debt items},
        journal = {Journal of the Brazilian Computer Society}
}","This work presents VisminerTD, a tool that allows the automatic identification and interactive monitoring of the evolution of TD items by combining software metrics, code comment analysis, and information visualization.",VisminerTD
84,S85,The Technical Debt Dataset,"Technical Debt analysis is increasing in popularity as nowadays
researchers and industry are adopting various tools for static code
analysisto evaluate the quality of their code. Despite this, empirical
studies on software projects are expensive becaUse of the time
needed to analyze the projects. In addition, the results are difficult
to Compare as studies commonly consider different projects. In
this work, we Propose the Technical Debt Dataset, a curated set of
project measurement data from 33 Java projects from the Apache
Software Foundation. In the Technical Debt Dataset, we analyzed
all commits from separately defined time frames with SonarQube
to collect Technical Debt information and with Ptidej to detect code
smells. Moreover, we extracted all available commit information
from the git logs, the refactoring applied with Refactoring Miner,
and fault information reported in the issue trackers (Jira). Using
this information, we executed the SZZ algorithm to identify the
fault-inducing and -fixing commits.Weanalyzed78Kcommitsfrom
the selected 33 projects, detecting 1.8M SonarQube issues, 38K code
smells, 28K faults and 57K refactorings. The project analysis took
more than 200 days. In this paper, we describe the data retrieval
pipeline together with the tools Used for the analysis. The dataset
is made available through CSV files and an SQLite database to
facilitate queries on the data. The Technical Debt Dataset aims to
open up diverse opportunitiesfor Technical Debtresearch, enabling
researchers to Compare results on common projects",Cite,"Valentina Lenarduzzi
Nyyti Saarimäki
Davide Taibi",Academia,"2,019.00",International Conference on Predictive Models and Data Analytics in Software Engineering,Conference,https://doi.org/10.1145/3345629.3345630,"@inproceedings{Lenarduzzi_2019,
	doi = {10.1145/3345629.3345630},
	url = {https://doi.org/10.1145%2F3345629.3345630},
	year = 2019,
	month = {sep},
	publisher = {{ACM}},
	author = {Valentina Lenarduzzi and Nyyti Saarimäki and Davide Taibi},
	title = {The Technical Debt Dataset},
	booktitle = {Proceedings of the Fifteenth International Conference on Predictive Models and Data Analytics in Software Engineering}
}","In this work, we Propose the Technical Debt Dataset, a curated set of
project measurement data from 33 Java projects from the Apache
Software Foundation.","Ptidej
SonarQube
RMiner
BetterCodeHub
CoverityScan"
85,S86,Software Architecture Social Debt: Managing the Incommunicability Factor,"Architectural technical debt is the additional project
cost connected to technical issues nested in software architectures.
Similarly, many practitioners have already experienced that there
exists within software architectures a form of social debt, that is,
the additional project cost connected to sociotechnical and organizational issues evident in or related to software architectures.
This paper illustrates four recurrent antipatterns or community
smells connected to such architectural social debt and outlines
a means to measure the additional project cost connected to
their underlying caUse: decision incommunicability. Evaluating
the results in multiple focus groups, this paper concludes that
studying social debt and community smells at the architecture
level may prove vital to rid software development communities
of critical organizational flaws incurring considerable additional
cost.",Cite,Damian A. Tamburri,Academia,"2,019.00",IEEE TRANSACTIONS ON COMPUTATIONAL SOCIAL SYSTEMS,Journal,http://doi.org/10.1109/TCSS.2018.2886433,"@article{Tamburri_2019,
	doi = {10.1109/tcss.2018.2886433},
	url = {https://doi.org/10.1109%2Ftcss.2018.2886433},
	year = 2019,
	month = {feb},
	publisher = {Institute of Electrical and Electronics Engineers ({IEEE})},
	volume = {6},
	number = {1},
	pages = {20--37},
	author = {Damian A. Tamburri},
	title = {Software Architecture Social Debt: Managing the Incommunicability Factor},
	journal = {{IEEE} Transactions on Computational Social Systems}
}",This paper illustrates four recurrent antipatterns or community smells connected to such architectural social debt and outlines a means to measure the additional project cost connected to their underlying caUse: decision incommunicability.,Understand
86,S87,Towards Surgically-Precise Technical Debt Estimation: Early Results and Research Roadmap,"The concept of technical debt has been explored from many perspectives but its precise estimation is still under heavy empirical and experimental inquiry. We aim to understand whether, by harnessing approximate, data-driven, machine-learning approaches it is possible to improve the current techniques for technical debt estimation, as represented by a top industry quality analysis tool such as SonarQube. For the sake of simplicity, we focus on relatively simple regression modelling techniques and apply them to modelling the additional project cost connected to the sub-optimal conditions existing in the projects under study. Our results shows that current techniques can be improved towards a more precise estimation of technical debt and the case study shows promising results towards the identification of more accurate estimation of technical debt.",Propose,"Valentina Lenarduzzi
Antonio Martini
Davide Taibi
Damian Andrew Tamburri",Academia,"2,019.00",International Workshop on Machine Learning Techniques for Software Quality Evaluation,Conference,https://doi.org/10.1145/3340482.3342747,"@INPROCEEDINGS{Lenarduzzi2019-hx,
  title           = ""Towards surgically-precise technical debt estimation:
                     early results and research roadmap"",
  booktitle       = ""Proceedings of the 3rd {ACM} {SIGSOFT} International
                     Workshop on Machine Learning Techniques for Software
                     Quality Evaluation - {MaLTeSQuE} 2019"",
  author          = ""Lenarduzzi, Valentina and Martini, Antonio and Taibi,
                     Davide and Tamburri, Damian Andrew"",
  publisher       = ""ACM Press"",
  year            =  2019,
  address         = ""New York, New York, USA"",
  copyright       = ""http://www.acm.org/publications/policies/copyright\_policy\#Background"",
  conference      = ""the 3rd ACM SIGSOFT International Workshop"",
  location        = ""Tallinn, Estonia""
}
","For the sake of simplicity, we focus on relatively simple regression modelling techniques and apply them to modelling the additional project cost connected to the sub-optimal
conditions existing in the projects under study.",SonarQube
87,S88,Investigating instability architectural smells evolution: an exploratory case study,"Architectural smells may substantially increase maintenance effort and thus require extra attention for potential refactoring. While we currently understand this concept and have identified different types of such smells, we have not yet studied their evolution in depth. This is necessary to inform their prioritisation and refactoring. This study analyses the evolution of individual architectural smell instances over time, and the characteristics that define these instances. Three different types of architectural smells are taken into consideration and mined from a total of 524 versions across 14 different projects. The results show how different smell types differ in multiple aspects, such as their growth rate, the importance of the affected elements over time in the dependency network of the system, and the time each instance affects the system. They also cast valuable insights on what aspects are the most important to consider during prioritisation and refactoring activities.",Propose,"Darius Sas
Paris Avgeriou
Francesca Arcelli Fontana",Academia,"2,019.00",International Conference on Software Maintenance and Evolution,Conference,http://doi.org/10.1109/ICSME.2019.00090,"@inproceedings{Sas_2019,
	doi = {10.1109/icsme.2019.00090},
	url = {https://doi.org/10.1109%2Ficsme.2019.00090},
	year = 2019,
	month = {sep},
	publisher = {{IEEE}},
	author = {Darius Sas and Paris Avgeriou and Francesca Arcelli Fontana},
	title = {Investigating Instability Architectural Smells Evolution: An Exploratory Case Study},
	booktitle = {2019 {IEEE} International Conference on Software Maintenance and Evolution ({ICSME})}
}","This study analyses the evolution of individual architectural smell instances over time, and the characteristics that define these instances.","Arcan
ASTracker"
88,S89,Are architectural smells independent from code smells? An empirical study,"Background. Architectural smells and code smells are symptoms of bad code or design that can caUse different quality problems, such as faults, technical debt, or difficulties with maintenance and evolution. Some studies show that code smells and architectural smells often appear together in the same file. The correlation between code smells and architectural smells, however, is not clear yet; some studies on a limited set of projects have claimed that architectural smells can be derived from code smells, while other studies claim the opposite.

Objective. The goal of this work is to understand whether architectural smells are independent from code smells or can be derived from a code smell or from one category of them.

Method. We conducted a case study analyzing the correlations among 19 code smells, six categories of code smells, and four architectural smells.

Results. The results show that architectural smells are correlated with code smells only in a very low number of occurrences and therefore cannot be derived from code smells.

Conclusion. Architectural smells are independent from code smells, and therefore deserve special attention by researchers, who should investigate their actual harmfulness, and practitioners, who should consider whether and when to remove them.",Use,"Francesca Arcelli Fontana
Valentina Lenarduzzi
Riccardo Roveda
Davide Taibi",Academia,"2,019.00",The Journal of Systems and Software,Journal,https://doi.org/10.1016/j.jss.2019.04.066,"@article{Arcelli_Fontana_2019,
	doi = {10.1016/j.jss.2019.04.066},
	url = {https://doi.org/10.1016%2Fj.jss.2019.04.066},
	year = 2019,
	month = {aug},
	publisher = {Elsevier {BV}},
	volume = {154},
	pages = {139--156},
	author = {Francesca Arcelli Fontana and Valentina Lenarduzzi and Riccardo Roveda and Davide Taibi},
	title = {Are architectural smells independent from code smells? An empirical study},
	journal = {Journal of Systems and Software}
}",The goal of this work is to understand whether architectural smells are independent from code smells or can be derived from a code smell or from one category of them.,"SonarQube
Plugin for SonarQube
Arcan"
89,S90,Evolution of Technical Debt: An Exploratory Study,"Abstract. Context: Technical debt is known to impact maintainability of software. As source code files grow in size, maintainability becomes
more challenging. Therefore, it is expected that the density of technical
debt in larger files would be reduced for the sake of maintainability. Objective: This exploratory study investigates whether a newly introduced
metric ‘technical debt density trend’ helps to better understand and explain the evolution of technical debt. The ‘technical debt density trend’
metric is the slope of the line of two successive ‘technical debt density’
measures corresponding to the ‘lines of code’ values of two consecutive
revisions of a source code file. Method: This study has Used 11,822 commits or revisions of 4,013 Java source files from 21 open source projects.
For the technical debt measure, SonarQube tool is Used with 138 code
smells. Results: This study finds that ‘technical debt density trend’ metric has interesting characteristics that make it particularly attractive to
understand the pattern of accrual and repayment of technical debt by
breaking down a technical debt measure into multiple components, e.g.,
‘technical debt density’ can be broken down into two components showing mean density corresponding to revisions that accrue technical debt
and mean density corresponding to revisions that repay technical debt.
The Use of ‘technical debt density trend’ metric helps us understand the
evolution of technical debt with greater insights.",Use,"Md Abdullah Al Mamun
Antonio Martini
Miroslaw Staron
Christian Berger
J ̈orgen Hansson",Academia,"2,019.00",International Workshop on Software Measurement,Workshop,https://research.chalmers.se/publication/524998/file/524998_Fulltext.pdf,"@inproceedings{inproceedings,
author = {Mamun, Md Abdullah and Martini, Antonio and Staron, Miroslaw and Berger, Christian and Hansson, Jörgen},
year = {2019},
month = {10},
pages = {},
title = {Evolution of Technical Debt: An Exploratory Study}
}",This exploratory study investigates whether a newly introduced metric ‘technical debt density trend’ helps to better understand and explain the evolution of technical debt.,SonarQube
90,S91,On the DiffUseness of Code Technical Debt in Java Projects of the Apache Ecosystem,"Background. Companies commonly invest major effort into removing, respectively not introducing, technical debt issues detected by static analysis tools such as SonarQube, Cast, or Coverity. These tools classify technical debt issues into categories according to severity, and developers commonly pay attention to not introducing issues with a high level of severity that could generate bugs or make software maintenance more difficult. Objective. In this work, we aim to understand the diffUseness of Technical Debt (TD) issues and the speed with which developers remove them from the code if they introduced such an issue. The goal is to understand which type of TD is more diffUsed and how much attention is paid by the developers, as well as to investigate whether TD issues with a higher level of severity are resolved faster than those with a lower level of severity. We conducted a case study across 78K commits of 33 Java projects from the Apache Software Foundation Ecosystem to investigate the distribution of 1.4M TD items. Results. TD items introduced into the code are mostly related to code smells (issues that can increase the maintenance effort). Moreover, developers commonly remove the most severe issues faster than less severe ones. However, the time needed to resolve issues increases when the level of severity increases (minor issues are removed faster that blocker ones). Conclusion. One possible answer to the unexpected issue of resolution time might be that severity is not correctly defined by the tools. Another possible answer is that the rules at an intermediate severity level could be the ones that technically require more time to be removed. The classification of TD items, including their severity and type, require thorough investigation from a research Cite of view.",Use,"Nyyti Saarimaki
Valentina Lenarduzzi
Davide Taibi",Academia,"2,019.00",International Conference on Technical Debt,Conference,http://doi.org/10.1109/TechDebt.2019.00028,"@inproceedings{Lenarduzzi_2019,
	doi = {10.1109/techdebt.2019.00028},
	url = {https://doi.org/10.1109%2Ftechdebt.2019.00028},
	year = 2019,
	month = {may},
	publisher = {{IEEE}},
	author = {Valentina Lenarduzzi and Nyyti Saarimaki and Davide Taibi},
	title = {On the DiffUseness of Code Technical Debt in Java Projects of the Apache Ecosystem},
	booktitle = {2019 {IEEE}/{ACM} International Conference on Technical Debt ({TechDebt})}
}","In this work, we aim to understand the diffUseness of
Technical Debt (TD) issues and the speed with which developers
remove them from the code if they introduced such an issue.",SonarQube
91,S92,Influence of Developer Factors on Code Quality: A Data Study,"Automatic source-code inspection tools help to assess, monitor and improve code quality. Since these tools only examine the software project's codebase, they overlook other possible factors that may impact code quality and the assessment of the technical debt (TD). Our initial hypothesis is that human factors associated with the software developers, like coding expertise, communication skills, and experience in the project have some measurable impact on the code quality. In this exploratory study, we test this hypothesis on two large open source repositories, using TD as a code quality metric and the data that may be inferred from the version control systems. The preliminary results of our statistical analysis suggest that the level of participation of the developers and their experience in the project have a positive correlation with the amount of TD that they introduce. On the contrary, communication skills have barely any impact on TD.",Use,"Maria Jose Salamea
Carles Farre",Academia,"2,019.00","International Conference on Software Quality, Reliability and Security Companion",Conference,http://doi.org/10.1109/QRS-C.2019.00035,"@inproceedings{Salamea_2019,
	doi = {10.1109/qrs-c.2019.00035},
	url = {https://doi.org/10.1109%2Fqrs-c.2019.00035},
	year = 2019,
	month = {jul},
	publisher = {{IEEE}},
	author = {Maria Jose Salamea and Carles Farre},
	title = {Influence of Developer Factors on Code Quality: A Data Study},
	booktitle = {2019 {IEEE} 19th International Conference on Software Quality, Reliability and Security Companion ({QRS}-C)}
}","Our initial hypothesis is that human
factors associated with the software developers, like coding
expertise, communication skills, and experience in the project
have some measurable impact on the code quality. In this
exploratory study, we test this hypothesis on two large open
source repositories, using TD as a code quality metric and the
data that may be inferred from the version control systems.",SonarQube
92,S93,Improving Code Smell Predictions in Continuous Integration by Differentiating Organic from Cumulative Measures,"Continuous integration and deployment are enablers of quick innovation cycles of software and systems through incremental releases of a product within short periods of time. If software qualities can be predicted for the next release, quality managers can plan ahead with resource allocation for concerning issues. Cumulative metrics are observed to have much higher correlation coefficients Compared to non-cumulative metrics. Given the difference in correlation coefficients of cumulative and noncumulative metrics, this study investigates the difference between metrics of these two categories concerning the correctness of predicting code smell which is internal software quality. This study considers 12 metrics from each measurement category, and 35 code smells collected from 36,217 software revisions (commits) of 242 open source Java projects. We build 8,190 predictive models and evaluate them to determine how measurement categories of predictors and targets affect model accuracies predicting code smells. To further validate our approach, we Compared our results with Principal Component Analysis (PCA), a statistical procedure for dimensionality reduction. Results of the study show that within the context of continuous integration, non-cumulative metrics as predictors build better predictive models with respect to model accuracy Compared to cumulative metrics. When the results are Compared with models built from extracted PCA components, we found better results using our approach.",Use,,Academia,"2,019.00",International Conference on Advances and Trends in Software Engineering,Conference,,"@inproceedings{Mamun2019,
author = {Mamun, Md Abdullah and Staron, Miroslaw and Berger, Christian and Hebig, Regina and Hansson, Jörgen},
year = {2019},
month = {03},
pages = {},
title = {Improving Code Smell Predictions in Continuous Integration by Differentiating Organic from Cumulative Measures}
}",,SpotBugs
93,S94,Quality-Driven Detection and Resolution of Metamodel Smells,"In model-driven engineering, analogously to any software development practice, metamodel design must be accurate and performed by considering relevant quality factors, including maintainability, reusability, and understandability. The quality of metamodels might be compromised by the introduction of smells that can be the result of inappropriate design decisions. Detecting and resolving metamodel smells are a complex task. The existing approaches deal with this problem by supporting the identification and resolution of smells without providing the means to explicitly trace them with the quality attributes that can be potentially affected. In this paper, we present an approach to defining extensible catalogues of metamodel smells. Each smell can be linked to the corresponding quality attributes. Such links are exploited to automatically select only those smells that have to be necessarily resolved for enhancing the quality factors that are of interest for the modeler. The implementation of the approach is based on the Edelta language, and it has been validated on a corpus of metamodels retrieved from a publicly available repository.",Propose,,Academia,"2,019.00",IEEE Access,Journal,,"@ARTICLE{8632659,  author={Bettini, Lorenzo and Di Ruscio, Davide and Iovino, Ludovico and Pierantonio, Alfonso},  journal={IEEE Access},   title={Quality-Driven Detection and Resolution of Metamodel Smells},   year={2019},  volume={7},  number={},  pages={16364-16376},  doi={10.1109/ACCESS.2019.2891357}}",,
94,S95,Toward a smell-aware bug prediction model,"Code smells are symptoms of poor design and implementation choices. Previous studies empirically assessed the impact of smells on code quality and clearly indicate their negative impact on maintainability, including a higher bug-proneness of components affected by code smells. In this paper, we capture previous findings on bug-proneness to build a specialized bug prediction model for smelly classes. Specifically, we evaluate the contribution of a measure of the severity of code smells (i.e., code smell intensity) by adding it to existing bug prediction models based on both product and process metrics, and comparing the results of the new model against the baseline models. Results indicate that the accuracy of a bug prediction model increases by adding the code smell intensity as predictor. We also Compare the results achieved by the Proposed model with the ones of an alternative technique which considers metrics about the history of code smells in files, finding that our model works generally better. However, we observed interesting complementarities between the set of buggy and smelly classes correctly classified by the two models. By evaluating the actual information gain provided by the intensity index with respect to the other metrics in the model, we found that the intensity index is a relevant feature for both product and process metrics-based models. At the same time, the metric counting the average number of code smells in previous versions of a class considered by the alternative model is also able to reduce the entropy of the model. On the basis of this result, we devise and evaluate a smell-aware combined bug prediction model that included product, process, and smell-related features. We demonstrate how such model classifies bug-prone code components with an F-Measure at least 13 percent higher than the existing state-of-the-art models.",Propose,,Academia,"2,019.00",IEEE TRANSACTIONS ON SOFTWARE ENGINEERING,Journal,,"@ARTICLE{8097044,  author={Palomba, Fabio and Zanoni, Marco and Fontana, Francesca Arcelli and De Lucia, Andrea and Oliveto, Rocco},  journal={IEEE Transactions on Software Engineering},   title={Toward a Smell-Aware Bug Prediction Model},   year={2019},  volume={45},  number={2},  pages={194-218},  doi={10.1109/TSE.2017.2770122}}",,
95,S96,Overview of an Automated Framework to Measure and Track the Quality Level of a Product,"Product owners need to comprehend the product quality level, in a synthetic and intuitive way to facilitate the decision of accepting or rejecting the iteration. This article presents the basis of an automated framework to measure and monitor the quality level of a software product, within each iteration. This framework is based on the Product Quality Evaluation Method (PQEM), which was designed by the authors and it allows the evaluation of the quality characteristics of a software product, using the Goal-Question-Metric approach, the ISO/IEC 25010, ISO/IEC 25023, the extension made of test coverage concept to quality coverage applied to each quality characteristic, and technical debt and waste. Within the automated framework, the measurement is semi-automatic which is shown in the illustrative example. The development of the framework will begin shortly, and it is expected to carry on new measurements on new iterations of an application.",Cite,"Mariana Falco
Ezequiel Scott
Gabriela Robiolo",Academia,"2,020.00",Biennial Congress of Argentina,Conference,https://doi.org/10.1109/ARGENCON49523.2020.9505405,"@INPROCEEDINGS{Falco2020-vt,
  title           = ""Overview of an automated framework to measure and track
                     the quality level of a product"",
  booktitle       = ""2020 {IEEE} Congreso Bienal de Argentina ({ARGENCON})"",
  author          = ""Falco, Mariana and Scott, Ezequiel and Robiolo, Gabriela"",
  publisher       = ""IEEE"",
  month           =  dec,
  year            =  2020,
  conference      = ""2020 IEEE Congreso Bienal de Argentina (ARGENCON)"",
  location        = ""Resistencia, Argentina""
}","This
framework is based on the Product Quality Evaluation Method
(PQEM), which was designed by the authors and it allows the
evaluation of the quality characteristics of a software product,
using the Goal-Question-Metric approach, the ISO/IEC 25010,
ISO/IEC 25023, the extension made of test coverage concept
to quality coverage applied to each quality characteristic, and
technical debt and waste.","SonarQube
Sikuli
JMeter"
96,S97,Software Architecture Reconstruction via a Genetic Algorithm: Applying the Move Class Refactoring,"Modularity is one of the four key principles of software design and architecture. According to this principle, software should be organized into modules that are tightly linked internally (high cohesion), whereas at the same time as independent from other modules as possible (low coupling). However, in practice, this principle is violated due to poor architecting design decisions, lack of time, or coding shortcuts, leading to a phenomenon termed as architectural technical debt (ATD). To alleviate this problem (lack of architectural modularity), the most common solution is the application of a software refactoring, namely Move Class—i.e., moving classes (the core artifact in object-oriented systems) from one module to another. To identify Move Class refactoring opportunities, we employ a search-based optimization process, relying on optimization metrics, through which optimal moves are derived. Given the extensive search space required for applying a brute-force search strategy, in this paper, we Propose the Use of a genetic algorithm that re-arranges existing software classes into existing or new modules (software packages in Java, or folders in C++). To validate the Usefulness of the Proposed refactorings, we performed an industrial case study on three projects (from the Aviation, Healthcare, and Manufacturing application domains). The results of the study indicate that the Proposed architecture reconstruction is able to improve modularity, improving both coupling and cohesion. The obtained results can be Useful to practitioners through an open source tool; whereas at the same Cite, they open interesting future work directions.",Propose,"Theodoros Maikantis
Angeliki-Agathi Tsintzira
Apostolos Ampatzoglou
Elvira-Maria Ar-Vanitou
Alexander Chatzigeorgiou
Ioannis Stamelos
Stamatia Bibi
Ignatios Deligiannis",Academia,"2,020.00",Pan-Hellenic Conference on Informatics,Conference,https://doi.org/10.1145/3437120.3437292,"@INPROCEEDINGS{Maikantis2020-hr,
  title      = ""Software architecture reconstruction via a genetic algorithm:
                Applying the move class refactoring"",
  booktitle  = ""24th {Pan-Hellenic} Conference on Informatics"",
  author     = ""Maikantis, Theodoros and Tsintzira, Angeliki-Agathi and
                Ampatzoglou, Apostolos and Arvanitou, Elvira-Maria and
                Chatzigeorgiou, Alexander and Stamelos, Ioannis and Bibi,
                Stamatia and Deligiannis, Ignatios"",
  publisher  = ""ACM"",
  month      =  nov,
  year       =  2020,
  address    = ""New York, NY, USA"",
  conference = ""PCI 2020: 24th Pan-Hellenic Conference on Informatics"",
  location   = ""Athens Greece""
}","To alleviate this problem (lack of architectural modularity), the most common solution is the application of a software refactoring, namely Move Class—i.e., moving classes
(the core artifact in object-oriented systems) from one module to another. To identify Move Class refactoring opportunities, we employ a search-based optimization process, relying on optimization metrics, through which optimal moves are derived.",DeRecGEA
97,S98,On the Influence of UML Class Diagrams Refactoring on Code Debt: A Family of Replicated Empirical Studies,"Context: System modeling usually precedes coding activities during software development. Addressing model smells in the upfront can avoid their propagation to the source code. Technical debt (TD) affects several software development phases, including design, but little is still known about it at the modeling level. Goal: Investigate whether applying refactoring procedures in UML class diagrams improves the quality of the automatically generated code in terms of TD (code debt) reduction. Method: We perform three replications of an empirical study following the same protocol Used in the original study, but with variations on the: (1) round- trip engineering tool, (2) code issue identification tool, and (3) analyzed class diagram. Each study considered two sets of refactoring tasks. The first applied successive model refactoring sessions in a class diagram and analyzed their resulting automatically generated code. The second applied successive code refactoring sessions and analyzed their resulting automatically generated model. Results: There is a weak relationship between the analyzed model smells and code issues. Round-trip engineering tools influence the presence of code issues. Lastly, code issues identification tools mostly consider code formatting problems, in detriment of design issues smells. Conclusion: Results confirm the findings of the original study and motivate further investigation on the correspondence between model smells and code issues to prevent code debt at the model level.",Use,"Sávio Freire
Amanda Passos
Manoel Mendonça
Cláudio Sant’Anna
Rodrigo O. Spínola",Academia,"2,020.00",Euromicro Conference on Software Engineering and Advanced Applications,Conference,http://doi.org/10.1109/SEAA51224.2020.00064,"@INPROCEEDINGS{Freire2020-ch,
  title           = ""On the influence of {UML} class diagrams refactoring on
                     code debt: A family of replicated empirical studies"",
  booktitle       = ""2020 46th Euromicro Conference on Software Engineering and
                     Advanced Applications ({SEAA})"",
  author          = ""Freire, Savio and Passos, Amanda and Mendonca, Manoel and
                     Sant'Anna, Claudio and Spinola, Rodrigo O"",
  publisher       = ""IEEE"",
  month           =  aug,
  year            =  2020,
  conference      = ""2020 46th Euromicro Conference on Software Engineering and
                     Advanced Applications (SEAA)"",
  location        = ""Portoroz, Slovenia""
}
",,"SonarQube
PMD
Enterprise Architect
EMF Refactor"
98,S99,Piranha: Reducing Feature Flag Debt at Uber,"Feature flags are commonly Used in mobile app development and can introduce technical debt related to deleting their usage from the codebase. This can adversely affect the overall reliability of the apps and increase their maintenance complexity. Reducing this debt without imposing additional overheads on the developers necessitates the design of novel tools and automated workflows.In this paper, we describe the design and implementation of PIRANHA, an automated code refactoring tool which is Used to automatically generate differential revisions (a.k. a diffs) to delete code corresponding to stale feature flags. PIRANHA takes as input the name of the flag, expected treatment behavior, and the name of the flag’s author. It analyzes the ASTs of the program to generate appropriate refactorings which are packaged into a diff. The diffis assigned to the author of the flag for further processing, who can land it after performing any additional refactorings.We have implemented PIRANHA to delete code in Objective-C, Java, and Swift programs, and deployed it to handle stale flags in multiple Uber apps. We present our experiences with the deployment of PIRANHA from Dec 2017 to May 2019, including the following highlights: (a) generated code cleanup diffs for 1381 flags (17% of total flags), (b) 65% of the diffs landed without any changes, (c) over 85% of the generated diffs compile and pass tests successfully, (d) around 80% of the diffs affect more than one file, (e) developers process more than 88% of the generated diffs, (f) 75% of the generated diffs are processed within a week, and (g) PIRANHA diffs have been interacted with by~200 developers across Uber. Piranha is available as open source at https://github.com/uber/ piranha.CCS CONCEPTS• Software and its engineering → Software maintenance tools.",Propose,"Murali Krishna Ramanathan
Lazaro Clapp, Rajkishore Barik
Manu Sridharan",Both,"2,020.00",International Conference on Software Engineering: Software Engineering in Practice,Conference,https://doi.org/10.1145/3377813.3381350,"@INPROCEEDINGS{Ramanathan2020-xh,
  title      = ""Piranha"",
  booktitle  = ""Proceedings of the {ACM/IEEE} 42nd International Conference on
                Software Engineering: Software Engineering in Practice"",
  author     = ""Ramanathan, Murali Krishna and Clapp, Lazaro and Barik,
                Rajkishore and Sridharan, Manu"",
  publisher  = ""ACM"",
  month      =  jun,
  year       =  2020,
  address    = ""New York, NY, USA"",
  conference = ""ICSE '20: 42nd International Conference on Software Engineering"",
  location   = ""Seoul South Korea""
}","In this paper, we describe the design and implementation of
Piranha, an automated code refactoring tool which is Used to
automatically generate differential revisions (a.k.a diffs) to delete
code corresponding to stale feature flags.",Piranha
99,S100,Predicting technical debt from commit contents: reproduction and extension with automated feature selection,"Self-admitted technical debt refers to sub-optimal development solutions that are expressed in written code comments or commits. We reproduce and improve on a prior work by Yan et al. (2018) on detecting commits that introduce self-admitted technical debt. We Use multiple natural language processing methods: Bag-of-Words, topic modeling, and word embedding vectors. We study 5 open-source projects. Our NLP approach Uses logistic Lasso regression from Glmnet to automatically select best predictor words. A manually labeled dataset from prior work that identified self-admitted technical debt from code level commits serves as ground truth. Our approach achieves + 0.15 better area under the ROC curve performance than a prior work, when comparing only commit message features, and + 0.03 better result overall when replacing manually selected features with automatically selected words. In both cases, the improvement was statistically significant (p < 0.0001). Our work has four main contributions, which are comparing different NLP techniques for SATD detection, improved results over previous work, showing how to generate generalizable predictor words when using multiple repositories, and producing a list of words correlating with SATD. As a concrete result, we release a list of the predictor words that correlate positively with SATD, as well as our Used datasets and scripts to enable replication studies and to aid in the creation of future classifiers.",Propose,"Leevi Rantala
Mika Mantyl",Academia,"2,020.00",Software Quality Journal,Journal,https://doi.org/10.1007/s11219-020-09520-3,"@article{Rantala_2020,
	doi = {10.1007/s11219-020-09520-3},
	url = {https://doi.org/10.1007%2Fs11219-020-09520-3},
	year = 2020,
	month = {jul},
	publisher = {Springer Science and Business Media {LLC}},
	volume = {28},
	number = {4},
	pages = {1551--1579},
	author = {Leevi Rantala and Mika Mäntylä},
	title = {Predicting technical debt from commit contents: reproduction and extension with automated feature selection},
	journal = {Software Quality Journal}
}","We reproduce and improve on a prior work by Yan
et al. (2018) on detecting commits that introduce self-admitted technical debt. We Use
multiple natural language processing methods: Bag-of-Words, topic modeling, and word
embedding vectors.","SonarQube
Machine Learning Model"
100,S101,Does migrating a monolithic system to microservices decrease the technical debt?,"Background:
The migration from a monolithic system to microservices requires a deep refactoring of the system. Therefore, such a migration usually has a big economic impact and companies tend to postpone several activities during this process, mainly to speed up the migration itself, but also becaUse of the demand for releasing new features.

Objective:
We monitored the technical debt of an SME while it migrated from a legacy monolithic system to an ecosystem of microservices. Our goal was to analyze changes in the code technical debt before and after the migration to microservices.

Method:
We conducted a case study analyzing more than four years of the history of a twelve-year-old project (280K Lines of Code) where two teams extracted five business processes from the monolithic system as microservices. For the study, we first analyzed the technical debt with SonarQube and then performed a qualitative study with company members to understand the perceived quality of the system and the motivation for possibly postponed activities.

Results:
The migration to microservices helped to reduce the technical debt in the long run. Despite an initial spike in the technical debt due to the development of the new microservice, after a relatively short period of time the technical debt tended to grow slower than in the monolithic system.",Use,"Valentina Lenarduzzi
Francesco Lomio
Nyyti Saarimäki
Davide Taibi",Academia,"2,020.00",The Journal of Systems and Software,Journal,https://doi.org/10.1016/j.jss.2020.110710,"@article{Lenarduzzi_2020,
	doi = {10.1016/j.jss.2020.110710},
	url = {https://doi.org/10.1016%2Fj.jss.2020.110710},
	year = 2020,
	month = {nov},
	publisher = {Elsevier {BV}},
	volume = {169},
	pages = {110710},
	author = {Valentina Lenarduzzi and Francesco Lomio and Nyyti Saarimäki and Davide Taibi},
	title = {Does migrating a monolithic system to microservices decrease the technical debt?},
	journal = {Journal of Systems and Software}
}","We monitored the technical debt of an SME while it migrated from a legacy monolithic
system to an ecosystem of microservices. Our goal was to analyze changes in the code technical debt before and after the migration to microservices.","CAST Software
Coverity Scan
SQUORE
Designite
SonarQube"
101,S102,"Software Archinaut: A Tool to Understand Architecture, Identify Technical Debt Hotspots and Manage Evolution","In this paper we present Software Archinaut--a tool Used to help
identify technical debt hotspots in an architecture, and manage the
evolution of the architecture once these hotspots are discovered.
Archinaut is a platform that integrates analyses from different tools.
It supports three main usage scenarios: 1) understanding the
architecture, 2) identifying technical debt hotspots, and 3)
monitoring and controlling the evolution of the architecture. We
illustrate these scenarios by using Apache Kafka as an example.",Propose,"Humberto Cervantes
Rick Kazman",Academia,"2,020.00",International Conference on Technical Debt,Conference,https://doi.org/10.1145/3387906.3388633,"@inproceedings{Cervantes_2020,
	doi = {10.1145/3387906.3388633},
	url = {https://doi.org/10.1145%2F3387906.3388633},
	year = 2020,
	month = {jun},
	publisher = {{ACM}},
	author = {Humberto Cervantes and Rick Kazman},
	title = {Software archinaut},
	booktitle = {Proceedings of the 3rd International Conference on Technical Debt}
}","In this paper we present Software Archinaut--a tool Used to help
identify technical debt hotspots in an architecture, and manage the
evolution of the architecture once these hotspots are discovered.","Software Archinaut
Depends
Designite
SCC
GitLog
DV8
RMiner
SonarQube
Understand
Lattix
Structure 101
CodeScene"
102,S103,Are SonarQube Rules Inducing Bugs?,"The popularity of tools for analyzing Technical Debt, and particularly the popularity of SonarQube, is increasing rapidly. SonarQube Proposes a set of coding rules, which represent something wrong in the code that will soon be reflected in a fault or will increase maintenance effort. However, our local companies were not confident in the Usefulness of the rules Proposed by SonarQube and contracted us to investigate the fault-proneness of these rules. In this work we aim at understanding which SonarQube rules are actually fault-prone and to understand which machine learning models can be adopted to accurately identify fault-prone rules. We designed and conducted an empirical study on 21 well-known mature open-source projects. We applied the SZZ algorithm to label the fault-inducing commits. We analyzed the fault-proneness by comparing the classification power of seven machine learning models. Among the 202 rules defined for Java by SonarQube, only 25 can be considered to have relatively low fault-proneness. Moreover, violations considered as “bugs” by SonarQube were generally not fault-prone and, consequently, the fault-prediction power of the model Proposed by SonarQube is extremely low. The rules applied by SonarQube for calculating technical debt should be thoroughly investigated and their harmfulness needs to be further confirmed. Therefore, companies should carefully consider which rules they really need to apply, especially if their goal is to reduce fault-proneness.",Use,"Valentina Lenarduzzi
Francesco Lomio
Heikki Huttunen
Davide Taibi",Academia,"2,020.00","International Conference on Software Analysis, Evolution and Reengineering",Conference,http://doi.org/10.1109/SANER48275.2020.9054821,"@INPROCEEDINGS{Lenarduzzi2020-dh,
  title           = ""Are {SonarQube} Rules Inducing Bugs?"",
  booktitle       = ""2020 {IEEE} 27th International Conference on Software
                     Analysis, Evolution and Reengineering ({SANER})"",
  author          = ""Lenarduzzi, Valentina and Lomio, Francesco and Huttunen,
                     Heikki and Taibi, Davide"",
  publisher       = ""IEEE"",
  month           =  feb,
  year            =  2020,
  copyright       = ""https://ieeexplore.ieee.org/Xplorehelp/downloads/license-information/IEEE.html"",
  conference      = ""2020 IEEE 27th International Conference on Software
                     Analysis, Evolution and Reengineering (SANER)"",
  location        = ""London, ON, Canada""
}","In this work we aim at understanding which SonarQube rules are
actually fault-prone and to understand which machine learning
models can be adopted to accurately identify fault-prone rules.",SonarQube
103,S104,On the Relationship between Self-Admitted Technical Debt Removals and Technical Debt Measures,"The technical debt (TD) in a software project refers to the adoption of an inadequate solution from its design to the source code. When developers admit the presence of technical debt in the source code, through comments or commit messages, it is called self-admitted technical debt (SATD). This aspect of TD has been the subject of numerous research studies, which have investigated its distribution, the impact on software quality, and removal. Therefore, this work focUses on the relationship between SATD and TD values. In particular, the study aims to Compare the admitted technical debt with respect to its objective measure. In fact, the trends of TD values during SATD removals have been studied. This was done thanks to the Use of an SATD dataset and their related removals in four open source projects. Instead, the SonarQube tool was Used to measure TD values. Thanks to this work, it turned out that SATD removals in a few cases correspond to an effective reduction of TD values, while in numerous cases, the classes indicated are removed.",Propose,"Lerina Aversano
Martina Iammarino
Mimmo Carapella
Andrea Del Vecchio
Laura Nardi",Academia,"2,020.00",Algorithms,Journal,http://doi.org/10.3390/a13070168,"@ARTICLE{Aversano2020-nx,
  title     = ""On the relationship between self-admitted technical debt
               removals and technical debt measures"",
  author    = ""Aversano, Lerina and Iammarino, Martina and Carapella, Mimmo and
               Vecchio, Andrea Del and Nardi, Laura"",
  journal   = ""Algorithms"",
  publisher = ""MDPI AG"",
  volume    =  13,
  number    =  7,
  pages     = ""168"",
  month     =  jul,
  year      =  2020,
  language  = ""en""
}
","Therefore, this work focUses on the
relationship between SATD and TD values.","SonarQube
CK"
104,S105,Evaluating the agreement among technical debt measurement tools: building an empirical benchmark of technical debt liabilities,"Software teams are often asked to deliver new features within strict deadlines leading developers to deliberately or inadvertently serve “not quite right code” compromising software quality and maintainability. This non-ideal state of software is efficiently captured by the Technical Debt (TD) metaphor, which reflects the additional effort that has to be spent to maintain software. Although several tools are available for assessing TD, each tool essentially checks software against a particular ruleset. The Use of different rulesets can often be beneficial as it leads to the identification of a wider set of problems; however, for the common usage scenario where developers or researchers rely on a single tool, diverse estimates of TD and the identification of different mitigation actions limits the credibility and applicability of the findings. The objective of this study is two-fold: First, we evaluate the degree of agreement among leading TD assessment tools. Second, we Propose a framework to capture the diversity of the examined tools with the aim of identifying few “reference assessments” (or class/file profiles) representing characteristic cases of classes/files with respect to their level of TD. By extracting sets of classes/files exhibiting similarity to a selected profile (e.g., that of high TD levels in all employed tools) we establish a basis that can be Used either for prioritization of maintenance activities or for training more sophisticated TD identification techniques. The Proposed framework is illustrated through a case study on fifty (50) open source projects and two programming languages (Java and JavaScript) employing three leading TD tools.",Compare,"Theodoros Amanatidis
Nikolaos Mittas
Athanasia Moschou
Alexander Chatzigeorgiou
Apostolos Ampatzoglou
Lefteris Angelis",Academia,"2,020.00",Empirical Software Engineering,Journal,https://doi.org/10.1007/s10664-020-09869-w,"@ARTICLE{Amanatidis2020-vo,
  title     = ""Evaluating the agreement among technical debt measurement tools:
               building an empirical benchmark of technical debt liabilities"",
  author    = ""Amanatidis, Theodoros and Mittas, Nikolaos and Moschou,
               Athanasia and Chatzigeorgiou, Alexander and Ampatzoglou,
               Apostolos and Angelis, Lefteris"",
  journal   = ""Empir. Softw. Eng."",
  publisher = ""Springer Science and Business Media LLC"",
  volume    =  25,
  number    =  5,
  pages     = ""4161--4204"",
  month     =  sep,
  year      =  2020,
  language  = ""en""
}","The objective of this study is two-fold: First, we evaluate the degree of agreement among leading TD assessment tools. Second, we Propose a framework to capture the diversity
of the examined tools with the aim of identifying few “reference assessments” (or class/file
profiles) representing characteristic cases of classes/files with respect to their level of TD.","AnaConDebt
CAST
CodeScene
DebtFlag
Debtgrep
DV8
Kiuwan
NDepend
SonarQube
Squore
TD-Tracker
TEDMA
VisminerTD"
105,S106,On Energy Debt: Managing Consumption on Evolving Software,"This paper introduces the concept of energy debt: a new metric, reflecting the implied cost in terms of energy consumption over time, of choosing a flawed implementation of a software system rather than a more robust, yet possibly time consuming, approach. A flawed implementation is considered to contain code smells, known to have a negative influence on the energy consumption.

Similar to technical debt, if energy debt is not properly addressed, it can accumulate an energy ""interest"". This interest will keep increasing as new versions of the software are released, and eventually reach a Cite where the interest will be higher than the initial energy debt. Addressing the issues/smells at such a Cite can remove energy debt, at the cost of having already consumed a significant amount of energy which can translate into high costs. We present all underlying concepts of energy debt, bridging the connection with the existing concept of technical debt and show how to compute the energy debt through a motivational example.",Cite,"Marco Couto
Daniel Maia
João Saraiva
Rui Pereira",Industry,"2,020.00",International Conference on Technical Debt,Conference,https://doi.org/10.1145/3387906.3388628,"@inproceedings{Couto_2020,
	doi = {10.1145/3387906.3388628},
	url = {https://doi.org/10.1145/3387906.3388628},
	year = 2020,
	month = {jun},
	publisher = {{ACM}},
	author = {Marco Couto and Daniel Maia and Jo{\~{a}}o Saraiva and Rui Pereira},
	title = {On energy debt},
	booktitle = {Proceedings of the 3rd International Conference on Technical Debt}
}","Similar to technical debt, if energy debt is not properly addressed, it can accumulate an energy “interest”. This interest will keep increasing as new versions of the software are released, and eventually reach a Cite where the interest will be higher than the initial en-
ergy debt.",SonarQube
106,S107,Longitudinal Evaluation of Open-source Software Maintainability,"We present a longitudinal study on the long-term evolution of maintainability in open-source software. Quality assessment remains at the forefront of both software research and practice, with many models and assessment methodologies Proposed and Used over time. Some of them helped create and shape standards such as ISO 9126 and 25010, which are well established today. Both describe software quality in terms of characteristics such as reliability, security or maintainability. An important body of research exists linking these characteristics with software metrics, and proposing ways to automate quality assessment by aggregating software metric values into higher-level quality models. We employ the Maintainability Index, technical debt ratio and a maintainability model based on the ARiSA Compendium. Our study covers the entire 18 year development history and all released versions for three complex, open-source applications. We determine the maintainability for each version using the Proposed models, we Compare obtained results and Use manual source code examination to put them into context. We examine the common development patterns of the target applications and study the relation between refactoring and maintainability. Finally, we study the strengths and weaknesses of each maintainability model using manual source code examination as the baseline.",Use,"Arthur-Jozsef Molnar 
Simona Motogna",Academia,"2,020.00",International Conference on Evaluation of Novel Approaches to Software Engineering,Conference,http://doi.org/10.5220/0009393501200131,"@inproceedings{Molnar_2020,
	doi = {10.5220/0009393501200131},
	url = {https://doi.org/10.5220%2F0009393501200131},
	year = 2020,
	publisher = {{SCITEPRESS} - Science and Technology Publications},
	author = {Arthur-Jozsef Molnar and Simona Motogna},
	title = {Longitudinal Evaluation of Open-source Software Maintainability},
	booktitle = {Proceedings of the 15th International Conference on Evaluation of Novel Approaches to Software Engineering}
}
","An important body of research exists linking these characteristics with software metrics, and proposing ways to automate quality assessment by aggregating software metric values into higher-level quality models. We employ the Maintainability Index, technical debt ratio and a maintainability model based on the ARiSA Compendium.","MetricsReloaded IntelliJ plugin 
VizzMaintainance Eclipse plugin."
107,S108,Towards a Model-based Fuzzy Software Quality Metrics," Code smells and Technical debt are two common notions that are often referred to for quantifying codebase
quality. Quality metrics based on such notions often reply on rigid thresholds and are insensitive to the project
unique context, such as development technologies, team size, and the desired code qualities. This challenge
often manifest itself in inadequate quantification of code qualities and potentially numerous false positives
cases. This paper presents a novel approach that formulates code quality metrics with thresholds that are
derived from software design models. This method results in metrics that, instead of adopting rigid thresholds,
formulates unique and evolving thresholds specific to each code module. This paper presents the novel
methodology and introduces some novel code quality formulas. To evaluate the Proposed formulas, we
evaluate them against open source codebase developed by experienced software engineers. The results suggest
that the Proposed methodology results in code quality quantification that provides more adequate
characterization. ",Propose,"Omar Masmali
Omar Badreddin",Academia,"2,020.00",International Conference on Model-Driven Engineering and Software Development,Conference,http://doi.org/10.5220/0008913701390148,"@inproceedings{Masmali_2020,
	doi = {10.5220/0008913701390148},
	url = {https://doi.org/10.5220%2F0008913701390148},
	year = 2020,
	publisher = {{SCITEPRESS} - Science and Technology Publications},
	author = {Omar Masmali and Omar Badreddin},
	title = {Towards a Model-based Fuzzy Software Quality Metrics},
	booktitle = {Proceedings of the 8th International Conference on Model-Driven Engineering and Software Development}
}","This paper presents a novel approach that formulates code quality metrics with thresholds that are
derived from software design models.",Understand
108,S109,A comparison of quality flaws and technical debt in model transformation specifications,"The quality of model transformations (MT) has high impact on model-driven engineering (MDE) software development approaches, becaUse of the central role played by transformations in MDE for refining, migrating, refactoring and other operations on models.

For programming languages, a popular paradigm for code quality is the concept of technical debt (TD), which Uses the analogy that quality flaws in code are a debt burden carried by the software, which must either be ‘redeemed’ by expending specific effort to remove its flaws, or be tolerated, with ongoing additional costs to maintenance due to the flaws.

Whilst the analysis and management of quality flaws and TD in programming languages has been investigated in depth over several years, less research on the topic has been carried out for model transformations. In this paper we investigate the characteristics of quality flaws and technical debt in model transformation languages, based upon systematic analysis of over 100 transformation cases in four leading MT languages.

Based on quality flaw indicators for TD, we identify significant differences in the level and kinds of technical debt in different MT languages, and we Propose ways in which TD in MT can be reduced and managed.",Use,"Shekoufeh Kolahdouz-Rahimi
Kevin Lano
Mohammadreza Sharbaf
Meysam Karimi
Hessa Alfraihi",Academia,"2,020.00",The Journal of Systems and Software,Journal,https://doi.org/10.1016/j.jss.2020.110684,"@ARTICLE{Kolahdouz-Rahimi2020-bq,
  title     = ""A comparison of quality flaws and technical debt in model
               transformation specifications"",
  author    = ""Kolahdouz-Rahimi, Shekoufeh and Lano, Kevin and Sharbaf,
               Mohammadreza and Karimi, Meysam and Alfraihi, Hessa"",
  journal   = ""J. Syst. Softw."",
  publisher = ""Elsevier BV"",
  volume    =  169,
  number    =  110684,
  pages     = ""110684"",
  month     =  nov,
  year      =  2020,
  language  = ""en""
}",,PMD
109,S110,ATDx: Building an Architectural Technical Debt Index,"Architectural technical debt (ATD) in software-intensive systems refers to the architecture design decisions
which work as expedient in the short term, but later negatively impact system evolvability and maintainability.
Over the years numerous approaches have been Proposed to detect particular types of ATD at a refined level
of granularity via source code analysis. Nevertheless, how to gain an encompassing overview of the ATD
present in a software-intensive system is still an open question. In this study, we present a multi-step approach
designed to build an ATD index (ATDx), which provides insights into a set of ATD dimensions building
upon existing architectural rules by leveraging statistical analysis. The ATDx approach can be adopted by
researchers and practitioners alike in order to gain a better understanding of the nature of the ATD present in
software-intensive systems, and provides a systematic framework to implement concrete instances of ATDx
according to specific project and organizational needs.
",Propose,"Roberto Verdecchia
Patricia Lago
Ivano Malavolta
Ipek Ozkaya",Academia,"2,020.00",International Conference on Evaluation of Novel Approaches to Software Engineering,Conference,http://doi.org/10.5220/0009577805310539,"@INPROCEEDINGS{Verdecchia2020-xh,
  title           = ""{ATDx}: Building an Architectural Technical Debt Index"",
  booktitle       = ""Proceedings of the 15th International Conference on
                     Evaluation of Novel Approaches to Software Engineering"",
  author          = ""Verdecchia, Roberto and Lago, Patricia and Malavolta,
                     Ivano and Ozkaya, Ipek"",
  publisher       = ""SCITEPRESS - Science and Technology Publications"",
  year            =  2020,
  conference      = ""15th International Conference on Evaluation of Novel
                     Approaches to Software Engineering"",
  location        = ""Prague, Czech Republic""
}","In this study, we present a multi-step approach designed to build an ATD index (ATDx), which provides insights into a set of ATD dimensions building upon existing architectural rules by leveraging statistical analysis.","ATDx
SonarQube"
110,S111,The Quest for Introducing Technical Debt Management in a Large-Scale Industrial Company,"The long lifetime and the evolving nature of industrial products make them subject to technical debt management at different levels such as architecture and code. Although the classical steps to perform technical debt management are known, in a study that we have been performing in a large-scale industrial company as our client, we realized that finding a starting Cite, which leads to the desired outcome, is in fact a major challenge. This paper elaborates on various caUses that we have identified for this challenge, and discusses our stepwise approach to address them so that the software quality can be improved. We believe that our experiences can be beneficial for both practitioners and researchers to gain more insight into applying quality improvement in practice as well as indicating open areas for further research.",Propose,"Somayeh Malakuti
Sergey Ostroumov",Industry,"2,020.00",European Conference on Software Architecture,Conference,https://doi.org/10.1007/978-3-030-58923-3_20,"@INCOLLECTION{Malakuti2020-cr,
  title     = ""The quest for introducing technical debt management in a
               large-scale industrial company"",
  booktitle = ""Software Architecture"",
  author    = ""Malakuti, Somayeh and Ostroumov, Sergey"",
  publisher = ""Springer International Publishing"",
  pages     = ""296--311"",
  series    = ""Lecture notes in computer science"",
  year      =  2020,
  address   = ""Cham""
}","This paper elaborates on various caUses that we have identified for this challenge, and discusses our stepwise approach to address them so that the software quality can be improved.","Lattix
Understand
TeamScale
CppDepend"
111,S112,Technical debt in procedural model transformation languages,"Model transformations (MT) are a significant element of model-based and model-driven engineering approaches. Hence their quality is important for their effectiveness for Use in such developments. The concept of technical debt (TD) estimates the impact of quality flaws on the maintenance costs of software artefacts.

In this paper we define a quality model for model transformation languages, and define TD indicators for MT based on this model. We apply the indicators to evaluate the TD levels in 40 transformation cases in three procedural MT languages: QVT-O, Kermeta and EGL, and Compare these levels with results for the declarative QVT-R language.",Propose,"Shekoufeh Kolahdouz-Rahimi
Kevin Lano
Meysam Karimi",Academia,"2,020.00",Journal of Computer Languages,Journal,https://doi.org/10.1016/j.cola.2020.100971,"@article{Kolahdouz_Rahimi_2020,
	doi = {10.1016/j.cola.2020.100971},
	url = {https://doi.org/10.1016%2Fj.cola.2020.100971},
	year = 2020,
	month = {aug},
	publisher = {Elsevier {BV}},
	volume = {59},
	pages = {100971},
	author = {Shekoufeh Kolahdouz-Rahimi and Kevin Lano and Meysam Karimi},
	title = {Technical debt in procedural model transformation languages},
	journal = {Journal of Computer Languages}
}
","In this paper we define a quality model for model transformation languages, and define TD indicators for MT based on this model.","PMD
SonarQube"
112,S113,How Junior Developers Deal with Their Technical Debt?,"Technical debt is a metaphor that measures the additional effort needed to continue to add more features in a software due to its inherent decrease in code quality. Most software systems suffer from technical debt at some Cite so that dedicated tools and metrics have been developed to monitor such debt. Alongside tools, appropriate engineering practices must be put in place by the development team to keep that debt at an acceptable level. In this empirical study, we observed and surveyed Scrum development teams composed of experienced students in order to understand their quality-related processes on a year-long academic project. We found that (1) students do Use static analysis tools of many forms, but their actual usage is limited due to time pressure; (2) retrospective and non-constraining feedback on code quality has little to no effect, even when given regularly during the course of the project; and (3) junior developers value composite quality indicators (e.g., maintainability, reliability in SonarQube), even if they do not fully understand their meaning. From our findings, we Propose a series of recommendations, both technical and methodological, on how to train junior developers to understand and manage technical debt.",Cite,"Fabian Gilson
Miguel Morales-Trujillo
Moffat Mathews",Academia,"2,020.00",International Conference on Technical Debt,Conference,https://doi.org/10.1145/3387906.3388624,"@inproceedings{Gilson_2020,
	doi = {10.1145/3387906.3388624},
	url = {https://doi.org/10.1145%2F3387906.3388624},
	year = 2020,
	month = {jun},
	publisher = {{ACM}},
	author = {Fabian Gilson and Miguel Morales-Trujillo and Moffat Mathews},
	title = {How junior developers deal with their technical debt?},
	booktitle = {Proceedings of the 3rd International Conference on Technical Debt}
}","In this empirical study, we observed and surveyed Scrum development
teams composed of experienced students in order to understand
their quality-related processes on a year-long academic project.","SonarQube
Sonarlint
ESLint
Findbugs
Checkstyle"
113,S114,How long do Junior Developers take to Remove Technical Debt Items?,"Background. Software engineering is one of the engineering fields with the highest inflow of junior engineers. Tools that utilize source code analysis to provide feedback on internal software quality, i.e. Technical Debt (TD), are valuable to junior developers who can learn and improve their coding skills with minimal consultations with senior colleagues. Objective. We aim at understating which SonarQube TD items junior developers prioritize during the refactoring and how long they take to refactor them. Method. We designed a case study with replicated design and we conducted it with 185 junior developers in two countries, that developed 23 projects with different programming languages and architectures. Results. Junior developers focus homogeneously on different types of TD items. Moreover, they can refactor items in a fraction of the estimated time, never spending more than 50% of the time estimated by SonarQube. Conclusion. Junior Developers appreciate the usage of SonarQube and considered as a Useful tool. Companies might ask junior developers to quickly clean their code.",Cite,"Valentina Lenarduzzi
Vladimir Mandić
Andrej Katin
Davide Taibi",Academia,"2,020.00",International Symposium on Empirical Software Engineering and Measurement,Conference,https://doi.org/10.1145/3382494.3422169,"@inproceedings{Lenarduzzi_2020,
	doi = {10.1145/3382494.3422169},
	url = {https://doi.org/10.1145%2F3382494.3422169},
	year = 2020,
	month = {oct},
	publisher = {{ACM}},
	author = {Valentina Lenarduzzi and Vladimir Mandi{\'{c}} and Andrej Katin and Davide Taibi},
	title = {How long do Junior Developers take to Remove Technical Debt Items?},
	booktitle = {Proceedings of the 14th {ACM} / {IEEE} International Symposium on Empirical Software Engineering and Measurement ({ESEM})}
}",We aim at understating which SonarQube TD items junior developers prioritize during the refactoring and how long they take to refactor them.,SonarQube
114,S115,An Empirical Study on the Evolution of Design Smells,"The evolution of software systems often leads to its architectural degradation due to the presence of design problems. In the literature, design smells have been defined as indicators of such problems. In particular, the presence of design smells could indicate the Use of constructs that are harmful to system maintenance activities. In this work, an investigation on the nature and presence of design smells has been performed. An empirical study has been conducted considering the complete history of eight software systems, commit by commit. The detection of instances of multiple design smell types has been performed at each commit, and the analysis of the relationships between the detected smells and the maintenance activities, specifically due to refactoring activities, has been investigated. The Proposed study evidenced that classes affected by design smells are more subject to change, especially when multiple smells are detected in the same classes. Moreover, it emerged that in some cases these smells are removed, and this occurs involving more smells at the same time. Finally, results indicate that smells removals are not correlated to the refactoring activities",Use,"Lerina Aversano
Umberto Carpenito
Martina Iammarino",Academia,"2,020.00",Information,Journal,http://doi.org/10.3390/info11070348,"@article{Aversano_2020,
	doi = {10.3390/info11070348},
	url = {https://doi.org/10.3390%2Finfo11070348},
	year = 2020,
	month = {jul},
	publisher = {{MDPI} {AG}},
	volume = {11},
	number = {7},
	pages = {348},
	author = {Lerina Aversano and Umberto Carpenito and Martina Iammarino},
	title = {An Empirical Study on the Evolution of Design Smells},
	journal = {Information}
}","An empirical study has been conducted considering the complete
history of eight software systems, commit by commit.","RMiner
Designite"
115,S116,On the Diffusion and Impact of Code  Smells in Web Applications,"Web applications (web apps) have become one of the largest parts of the current software market over years. Modern web apps offer several business benefits over other traditional and standalone applications. Mainly, cross-platform compatibility and data integration are some of the critical features that encouraged businesses to shift towards the adoption of Web apps. Web apps are evolving rapidly to acquire new features, correct errors or adapt to new environment changes especially with the volatile context of the web development. These ongoing amends often affect software quality due to poor coding and bad design practices, known as code smells or anti-patterns. The presence of code smells in a software project is widely considered as form of technical debt and makes the software harder to understand, maintain and evolve, besides leading to failures and unforeseen costs. Therefore, it is critical for web apps to monitor the existence and spread of such anti-patterns. In this paper, we specifically target web apps built with PHP being the most Used server-side programming language. We conduct the first empirical study to investigate the diffUseness of code smells in Web apps and their relationship with the change proneness of affected code. We detect 12 types of common code smells across a total of 223 releases of 5 popular and long-lived open-source web apps. The key findings of our study include: 1) complex and large classes and methods are frequently committed in PHP files, 2) smelly files are more prone to change than non-smelly files, and 3) Too Many Methods and High Coupling are the most associated smells with files change-proneness.",Use,"Narjes Bessghaier
Ali Ouni
Mohamed Wiem Mkaouer",Academia,"2,020.00",International Conference on Services Computing,Conference,https://doi.org/10.1007/978-3-030-59592-0_5,"@incollection{Bessghaier_2020,
	doi = {10.1007/978-3-030-59592-0_5},
	url = {https://doi.org/10.1007%2F978-3-030-59592-0_5},
	year = 2020,
	publisher = {Springer International Publishing},
	pages = {67--84},
	author = {Narjes Bessghaier and Ali Ouni and Mohamed Wiem Mkaouer},
	title = {On the Diffusion and Impact of Code Smells in Web Applications},
	booktitle = {Services Computing {\textendash} {SCC} 2020}
}","In this paper,
we specifically target web apps built with PHP being the most Used
server-side programming language.",PHPMD
116,S117,Does code review really remove coding convention violations?,"Many software developers perceive technical debt as the biggest problems in their projects. They also perceive code reviews as the most important process to increase code quality. As inconsistent coding style is one source of technical debt, it is no surprise that coding convention violations can lead to patch rejection during code review. However, as most research has focUsed on developer's perception, it is not clear whether code reviews actually prevent the introduction of coding convention violations and the corresponding technical debt.Therefore, we investigated how coding convention violations are introduced, addressed, and removed during code review by developers. To do this, we analysed 16,442 code review requests from four projects of the Eclipse community for the introduction of convention violations. Our result shows that convention violations accumulate as code size increases despite changes being reviewed. We also manually investigated 1,268 code review requests in which convention violations disappear and observed that only a minority of them have been removed becaUse a convention violation has been flagged in a review comment. The investigation results also highlight that one can speed up the code review process by adopting tools for code convention violation detection.",Use,"DongGyun Han
Chaiyong Ragkhitwetsagul
Jens Krinke
Matheus Paixao
Giovanni Rosa",Academia,"2,020.00",International Working Conference on Source Code Analysis and Manipulation,Conference,http://doi.org/10.1109/SCAM51674.2020.00010,"@inproceedings{Han_2020,
	doi = {10.1109/scam51674.2020.00010},
	url = {https://doi.org/10.1109%2Fscam51674.2020.00010},
	year = 2020,
	month = {sep},
	publisher = {{IEEE}},
	author = {DongGyun Han and Chaiyong Ragkhitwetsagul and Jens Krinke and Matheus Paixao and Giovanni Rosa},
	title = {Does code review really remove coding convention violations?},
	booktitle = {2020 {IEEE} 20th International Working Conference on Source Code Analysis and Manipulation ({SCAM})}
}","Therefore, we investigated how coding convention violations
are introduced, addressed, and removed during code review
by developers. To do this, we analysed 16,442 code review
requests from four projects of the Eclipse community for the
introduction of convention violations.","Checkstyle
PMD
Gerrit
CodeFlow
Fabricator"
117,S118,An Empirical Study on Self-Fixed Technical Debt,"Technical Debt (TD) can be paid back either by those that incurred it or by others. We call the former self-fixed TD, and it is particularly effective, as developers are experts in their own code and are best-suited to fix the corresponding TD issues. To what extent is TD self-fixed, which types of TD are more likely to be self-fixed and is the remediation time of self-fixed TD shorter than non-self-fixed TD? This paper attempts to answer these questions. It reports on an empirical study that analyzes the self-fixed issues of five types of TD (i.e., Code, Defect, Design, Documentation and Test), captured via static analysis, in more than 17,000 commits from 20 Python projects of the Apache Software Foundation. The results show that more than two thirds of the issues are self-fixed and that the self-fixing rate is negatively correlated with the number of commits, developers and project size. Furthermore, the survival time of self-fixed issues is generally shorter than non-self-fixed issues. Moreover, the majority of Defect Debt tends to be self-fixed and has a shorter survival time, while Test Debt and Design Debt are likely to be fixed by other developers. These results can benefit both researchers and practitioners by aiding the prioritization of TD remediation activities within development teams, and by informing the development of TD management tools.",Use,"Jie Tan
Daniel Feitosa
Paris Avgeriou",Academia,"2,020.00",International Conference on Technical Debt,Conference,https://doi.org/10.1145/3387906.3388621,"@inproceedings{Tan_2020,
	doi = {10.1145/3387906.3388621},
	url = {https://doi.org/10.1145%2F3387906.3388621},
	year = 2020,
	month = {jun},
	publisher = {{ACM}},
	author = {Jie Tan and Daniel Feitosa and Paris Avgeriou},
	title = {An empirical study on self-fixed technical debt},
	booktitle = {Proceedings of the 3rd International Conference on Technical Debt}
}","This paper attempts to answer these questions. It reports on an
empirical study that analyzes the self-fixed issues of five types of
TD (i.e., Code, Defect, Design, Documentation and Test), captured
via static analysis, in more than 17,000 commits from 20 Python
projects of the Apache Software Foundation.","SonarQube
<Code from authors>"
118,S119,On the Temporality of Introducing Code Technical Debt,"Code Technical Debt (TD) is intentionally or unintentionally
created when developers introduce inefficiencies in the codebase. This can
be attributed to various reasons such as heavy work-load, tight delivery
schedule, unawareness of good practices, etc. To shed light into the context that leads to technical debt accumulation, in this paper we investigate: (a) the temporality of code technical debt introduction in new
methods, i.e., whether the introduction of technical debt is stable across
the lifespan of the project, or if its evolution presents spikes; and (b)
the relation of technical debt introduction and the development team’s
workload in a given period. To answer these questions, we perform a case
study on twenty-seven Apache projects, and inspect the number of Technical Debt Items introduced in 6-month sliding temporal windows. The
results of the study suggest that: (a) overall, the number of Technical
Debt Items introduced through new code is a stable metric, although it
presents some spikes; and (b) the number of commits performed is not
strongly correlated to the number of introduced Technical Debt Items",Use,"Georgios Digkas
Apostolos Ampatzoglou
Alexander Chatzigeorgiou
Paris Avgeriou",Academia,"2,020.00",International Conference on the Quality of Information and Communications Technology,Conference,https://doi.org/10.1007/978-3-030-58793-2_6,"@incollection{Digkas_2020,
	doi = {10.1007/978-3-030-58793-2_6},
	url = {https://doi.org/10.1007%2F978-3-030-58793-2_6},
	year = 2020,
	publisher = {Springer International Publishing},
	pages = {68--82},
	author = {Georgios Digkas and Apostolos Ampatzoglou and Alexander Chatzigeorgiou and Paris Avgeriou},
	title = {On the Temporality of Introducing Code Technical Debt},
	booktitle = {Communications in Computer and Information Science}
}
","To shed light into the context that leads to technical debt accumulation, in this paper we investigate: (a) the temporality of code technical debt introduction in new methods, i.e., whether the introduction of technical debt is stable across the lifespan of the project, or if its evolution presents spikes; and (b) the relation of technical debt introduction and the development team’s workload in a given period. To answer these questions, we perform a case study on twenty-seven Apache projects, and inspect the number of Technical Debt Items introduced in 6-month sliding temporal windows.",SonarQube
119,S120,"Refactoring, Bug Fixing, and New Development Effect on Technical Debt: An Industrial Case Study","Code evolution, whether related to the development of new features, bug fixing, or refactoring, inevitably changes the quality of the code. One particular type of such change is the accumulation of Technical Debt (TD) resulting from sub-optimal design decisions. Traditionally, refactoring is one of the means that has been acknowledged to help to keep TD under control. Developers refactor their code to improve its maintainability and to repay TD (e.g., by removing existing code smells and anti-patterns in the source code). While the accumulation of the TD and the effect of refactoring on TD have been studied before, there is a lack of empirical evidence from industrial projects on how the different types of code changes affect the TD and whether specific refactoring operations are more effective for repaying TD. To fill this gap, we conducted an empirical study on an industrial project and investigated how Refactoring, Bug Fixing, and New Development affect the TD. We have analyzed 2, 286 commits in total to identify which activities reduced, kept the same, or even increased the TD, further delving into specific refactoring operations to assess their impact. Our results suggest that TD in the studied project is mainly introduced in the development of new features (estimated in 72.8 hours). Counterintuitively, from the commits tagged as refactoring, only 22.90% repay TD (estimated to repay 8.30 hours of the TD). Moreover, while some types of refactoring operations (e.g., Extract Method), help repaying TD, other refactoring operations (e.g., Move Class) are highly prone to introduce more TD.",Use,"Ehsan Zabardast
Javier Gonzalez-Huerta
Darja Smite",Academia,"2,020.00",Euromicro Conference on Software Engineering and Advanced Applications,Conference,http://doi.org/10.1109/SEAA51224.2020.00068,"@inproceedings{Zabardast_2020,
	doi = {10.1109/seaa51224.2020.00068},
	url = {https://doi.org/10.1109%2Fseaa51224.2020.00068},
	year = 2020,
	month = {aug},
	publisher = {{IEEE}},
	author = {Ehsan Zabardast and Javier Gonzalez-Huerta and Darja Smite},
	title = {Refactoring, Bug Fixing, and New Development Effect on Technical Debt: An Industrial Case Study},
	booktitle = {2020 46th Euromicro Conference on Software Engineering and Advanced Applications ({SEAA})}
}","To fill this gap, we conducted an empirical study on an industrial
project and investigated how Refactoring, Bug Fixing, and New
Development affect the TD.","SonarQube
RefactoringMiner"
120,S121,Investigating the Relationship between Co-occurring Technical Debt in Python,"Technical debt (TD) reflects issues that may negatively affect software maintenance and evolution. There is currently little evidence on how the different types of TD co-occur; for example, how code smells and design smells affect the same part of the system. This paper investigates how different types of TD co-occur, as well as the time period of the co-occurrence. To that end, we analyzed the co-occurring associations between five types of TD, captured in 42 SonarQube rules, in 3862 files of 20 Python projects from the Apache Software Foundation. We found that this phenomenon is dominant, affecting more than 90% of Python files. We also found that Documentation Debt and Test Debt appear in the majority of the files, although it seems to be mostly by coincidence. Finally, we noticed that co-occurrence of TD seems to happen very quickly: co-occurring issues tend to be introduced within the same week. But once it does happen, it is hard to get rid of. These results can benefit both researchers and practitioners by: aiding the prioritization of TD remediation; leading to novel tools for detecting co-occurring TD and warning potential issues; shedding further light on the explanation of how TD is introduced and can be mitigated.",Use,"Jie Tan
Daniel Feitosa
Paris Avgeriou",Academia,"2,020.00",Euromicro Conference on Software Engineering and Advanced Applications,Conference,http://doi.org/10.1109/SEAA51224.2020.00082,"@inproceedings{Tan_2020,
	doi = {10.1109/seaa51224.2020.00082},
	url = {https://doi.org/10.1109%2Fseaa51224.2020.00082},
	year = 2020,
	month = {aug},
	publisher = {{IEEE}},
	author = {Jie Tan and Daniel Feitosa and Paris Avgeriou},
	title = {Investigating the Relationship between Co-occurring Technical Debt in Python},
	booktitle = {2020 46th Euromicro Conference on Software Engineering and Advanced Applications ({SEAA})}
}","This paper investigates how different types of TD co-occur, as well as the time period of the co-occurrence. To that end, we analyzed the co-occurring associations between five types of TD, captured in 42 SonarQube rules, in 3862 files of 20 Python projects from the Apache Software Foundation.","SonarQube
<Code from authors>"
121,S122,CODE reUse in practice: Benefiting or harming technical debt,"During the last years the TD community is striving to offer methods and tools for reducing the amount of TD, but also understand the underlying concepts. One popular practice that still has not been investigated in the context of TD, is software reUse. The aim of this paper is to investigate the relation between white-box code reUse and TD principal and interest. In particular, we target at unveiling if the reUse of code can lead to software with better levels of TD. To achieve this goal, we performed a case study on approximately 400 OSS systems, comprised of 897 thousand classes, and Compare the levels of TD for reUsed and natively-written classes. The results of the study suggest that reUsed code usually has less TD interest; however, the amount of principal in them is higher. A synthesized view of the aforementioned results suggest that software engineers shall opt to reUse code when necessary, since apart from the established reUse benefits (i.e., cost savings, increased productivity, etc.) are also getting benefits in terms of maintenance. Apart from understanding the phenomenon per se, the results of this study provide various implications to research and practice.",Use,"Daniel Feitosa
Apostolos Ampatzoglou
Antonios Gkortzis
Stamatia Bibi
Alexander Chatzigeorgiou",Academia,"2,020.00",The Journal of Systems and Software,Journal,https://doi.org/10.1016/j.jss.2020.110618,"@article{Feitosa_2020,
	doi = {10.1016/j.jss.2020.110618},
	url = {https://doi.org/10.1016%2Fj.jss.2020.110618},
	year = 2020,
	month = {sep},
	publisher = {Elsevier {BV}},
	volume = {167},
	pages = {110618},
	author = {Daniel Feitosa and Apostolos Ampatzoglou and Antonios Gkortzis and Stamatia Bibi and Alexander Chatzigeorgiou},
	title = {{CODE} reUse in practice: Benefiting or harming technical debt},
	journal = {Journal of Systems and Software}
}",The aim of this paper is to investigate the relation between white-box code reUse and TD principal and interest.,SonarQube
122,S123,Long-Term Evaluation of Technical Debt in Open-Source Software,"Background: A consistent body of research and practice have identified that technical debt provides valuable and actionable insight into the design and implementation deficiencies of complex software systems. Existing software tools enable characterizing and measuring the amount of technical debt at selective granularity levels; by providing a computational model, they enable stakeholders to measure and ultimately control this phenomenon. Aims: In this paper we aim to study the evolution and characteristics of technical debt in open-source software. For this, we carry out a longitudinal study that covers the entire development history of several complex applications. The goal is to improve our understanding of how the amount and composition of technical debt changes in evolving software. We also study how new technical debt is introduced in software, as well as identify how developers handle its accumulation over the long term. Method: We carried out our evaluation using three complex, open-source Java applications. All 110 released versions, covering more than 10 years of development history for each application were analyzed using SonarQube. We studied how the amount, composition and history of technical debt changed during development, Compared our results across the studied applications and present our most important findings. Results: For each application, we identified key versions during which large amounts of technical debt were added, removed or both. This had significantly more impact when Compared to the lines of code or class count increases that generally occurred during development. However, within each version, we found high correlation between file lines of code and technical debt. We observed that the Pareto principle was satisfied for the studied applications, as 20% of issue types generated around 80% of total technical debt. Interestingly, there was a large degree of overlap between the issues that generated most of the debt across the studied applications. Conclusions: Early application versions showed greater fluctuation in the amount of existing technical debt. We found application size to be an unreliable predictor for the quantity of technical debt. Most debt was introduced in applications as part of milestone releases that expanded their feature set; likewise, we identified releases where extensive refactoring significantly reduced the level of debt. We also discovered that technical debt issues persist for a long time in source code, and their removal did not appear to be prioritized according to type or severity.",Use,"Arthur-Jozsef Molnar
Simona Motogna",Academia,"2,020.00",International Symposium on Empirical Software Engineering and Measurement,Conference,https://doi.org/10.1145/3382494.3410673,"@inproceedings{Molnar_2020,
	doi = {10.1145/3382494.3410673},
	url = {https://doi.org/10.1145%2F3382494.3410673},
	year = 2020,
	month = {oct},
	publisher = {{ACM}},
	author = {Arthur-Jozsef Molnar and Simona Motogna},
	title = {Long-Term Evaluation of Technical Debt in Open-Source Software},
	booktitle = {Proceedings of the 14th {ACM} / {IEEE} International Symposium on Empirical Software Engineering and Measurement ({ESEM})}
}","In this paper we aim to study the evolution and characteristics of technical debt in open-source software. For this, we carry out a longitudinal study that covers the entire development history of several complex applications.","SonarQube
Squore
Kiuwan
Ndepend"
123,S124,Anticipating Identification of Technical Debt Items in Model-Driven Software Projects,"Model-driven development (MDD) and Technical Debt (TD) are software engineering approaches that look for promoting the quality of systems under development. Most research on TD focUses on application code as primary TD sources. In an MDD project, however, dealing with technical debt only on the source code may not be an adequate strategy becaUse MDD projects should focus their software building efforts on models. Besides, in MDD projects, code generation is often done at a later stage than creating models, then dealing with TD only in source code can lead to unnecessary interest payments due to unmanaged debts, such as model and source codes artifacts desynchronization. Recent works concluded that MDD project codes are not technical debt free, making it necessary to investigate the possibility and benefits of applying TD identification techniques in earlier stages of the development process, such as in modeling phases. The Use of TD concept in an MDD context is also known as Model-Driven Technical Debt (MDTD). This paper intends to analyze whether it is possible to Use source code technical debt detection strategies to identify TD on code-generating models in the context of model-driven development projects. A catalog of nine different model technical debt items for platform-independent code-generating models was specified. An evaluation was performed to observe the effectiveness of the Proposed catalog Compared to existing source code identification techniques found in the literature. Through three different open source software projects, more than 78 thousand lines of code were investigated. Results revealed that, although the catalog items present different precision rates, it is possible to identify these model-driven technical debts before source code is generated. We hope that sharing this catalog version provides future contributions and improvements.",Use,"Ramon Araújo Gomes
Larissa Barbosa L. Pinheiro
Rita Suzana Pitangueira Maciel",Academia,"2,020.00",Brazilian Symposium on Software Engineering,Conference,https://doi.org/10.1145/3422392.3422434,"@inproceedings{Gomes_2020,
	doi = {10.1145/3422392.3422434},
	url = {https://doi.org/10.1145%2F3422392.3422434},
	year = 2020,
	month = {oct},
	publisher = {{ACM}},
	author = {Ramon Ara{\'{u}}jo Gomes and Larissa Barbosa L. Pinheiro and Rita Suzana Pitangueira Maciel},
	title = {Anticipating Identification of Technical Debt Items in Model-Driven Software Projects},
	booktitle = {Proceedings of the 34th Brazilian Symposium on Software Engineering}
}","This paper intends to analyze whether it is possible to Use source code technical debt detection strategies to identify TD on code-generating models in the context of model-driven development projects. A catalog of nine different model technical debt items for platform-
independent code-generating models was specified.","EMF Refactor
PMD
Checkstyle
Jspirit
SonarQube"
124,S125,On the diffUseness of technical debt items and accuracy of remediation time when using SonarQube,"Context. Among the static analysis tools available, SonarQube is one of the most Used. SonarQube detects Technical Debt (TD) items—i.e., violations of coding rules—and then estimates TD as the time needed to remedy TD items. However, practitioners are still skeptical about the accuracy of remediation time estimated by the tool. Objective. In this paper, we analyze both diffUseness of TD items and accuracy of remediation time, estimated by SonarQube, to fix TD items on a set of 21 open-source Java projects. Method. We designed and conducted a case study where we asked 81 junior developers to fix TD items and reduce the TD of 21 projects. Results. We observed that TD items are diffUsed in the analyzed projects and most items are code smells. Moreover, the results Cite out that the remediation time estimated by SonarQube is inaccurate and, as Compared to the actual time spent to fix TD items, is in most cases overestimated. Conclusions. The results of our study are promising for practitioners and researchers. The former can make more aware decisions during project execution and resource management, the latter can Use this study as a starting Cite for improving TD estimation models.",Use,"Maria Teresa Baldassarre
Valentina Lenarduzzi
Simone Romanoa
Nyyti Saarimäki",Academia,"2,020.00",Information and Software Technology,Journal,https://doi.org/10.1016/j.infsof.2020.106377,"@article{Baldassarre_2020,
	doi = {10.1016/j.infsof.2020.106377},
	url = {https://doi.org/10.1016%2Fj.infsof.2020.106377},
	year = 2020,
	month = {dec},
	publisher = {Elsevier {BV}},
	volume = {128},
	pages = {106377},
	author = {Maria Teresa Baldassarre and Valentina Lenarduzzi and Simone Romano and Nyyti Saarimäki},
	title = {On the diffUseness of technical debt items and accuracy of remediation time when using {SonarQube}},
	journal = {Information and Software Technology}
}","In this paper, we analyze both diffUseness of TD items and accuracy of remediation time, estimated by SonarQube, to fix TD items on a set of 21 open-source Java projects.",SonarQube
125,S126,Technical debt forecasting: An empirical study on open-source repositories,"Technical debt (TD) is commonly Used to indicate additional costs caUsed by quality compromises that can yield short-term benefits in the software development process, but may negatively affect the long-term quality of software products. Predicting the future value of TD could facilitate decision-making tasks regarding software maintenance and assist developers and project managers in taking proactive actions regarding TD repayment. However, no notable contributions exist in the field of TD forecasting, indicating that it is a scarcely investigated field. To this end, in the present paper, we empirically evaluate the ability of machine learning (ML) methods to model and predict TD evolution. More specifically, an extensive study is conducted, based on a dataset that we constructed by obtaining weekly snapshots of fifteen open source software projects over three years and using two popular static analysis tools to extract software-related metrics that can act as TD predictors. Subsequently, based on the identified TD predictors, a set of TD forecasting models are produced using popular ML algorithms and validated for various forecasting horizons. The results of our analysis indicate that linear Regularization models are able to fit and provide meaningful forecasts of TD evolution for shorter forecasting horizons, while the non-linear Random Forest regression performs better than the linear models for longer forecasting horizons. In most of the cases, the future TD value is captured with a sufficient level of accuracy. These models can be Used to facilitate planning for software evolution budget and time allocation. The approach presented in this paper provides a basis for predictive TD analysis, suitable for projects with a relatively long history. To the best of our knowledge, this is the first study that investigates the feasibility of using ML models for forecasting TD.",Use,"Dimitrios Tsoukalas
Dionysios Kehagias
Miltiadis Siavvas
Alexander Chatzigeorgiou",Academia,"2,020.00",The Journal of Systems and Software,Journal,https://doi.org/10.1016/j.jss.2020.110777,"@article{Tsoukalas_2020,
	doi = {10.1016/j.jss.2020.110777},
	url = {https://doi.org/10.1016%2Fj.jss.2020.110777},
	year = 2020,
	month = {dec},
	publisher = {Elsevier {BV}},
	volume = {170},
	pages = {110777},
	author = {Dimitrios Tsoukalas and Dionysios Kehagias and Miltiadis Siavvas and Alexander Chatzigeorgiou},
	title = {Technical debt forecasting: An empirical study on open-source repositories},
	journal = {Journal of Systems and Software}
}","To this end, in the present paper, we empirically evaluate the ability of machine learning (ML) methods to model and predict TD evolution. More specifically, an extensive study is conducted, based on a dataset that we constructed by obtaining weekly snapshots of fifteen open source software projects over three years and using two popular static analysis tools to extract software-related metrics that can act as TD predictors.","SonarQube
CKJM
Sigrid
Structure101
NDepend
Teamscale
FindBugs
CheckStyle
<Code from authors>"
126,S127,Evolution of technical debt remediation in Python: A case study on the Apache Software Ecosystem,"In recent years, the evolution of software ecosystems and the detection of technical debt received significant attention by researchers from both industry and academia. While a few studies that analyze various aspects of technical debt evolution already exist, to the best of our knowledge, there is no large-scale study that focUses on the remediation of technical debt over time in Python projects—that is, one of the most popular programming languages at the moment. In this paper, we analyze the evolution of technical debt in 44 Python open-source software projects belonging to the Apache Software Foundation. We focus on the type and amount of technical debt that is paid back. The study required the mining of over 60K commits, detailed code analysis on 3.7K system versions, and the analysis of almost 43K fixed issues. The findings show that most of the repayment effort goes into testing, documentation, complexity, and duplication removal. Moreover, more than half of the Python technical debt is short term being repaid in less than 2 months. In particular, the observations that a minority of rules account for the majority of issues fixed and spent effort suggest that addressing those kinds of debt in the future is important for research and practice.",Use,"Jie Tan
Daniel Feitosa
Paris Avgeriou
Mircea Lungu",Academia,"2,020.00",Journal of Software: Evolution and Process,Journal,http://doi.org/10.1002/smr.2319,"@article{Tan_2020,
	doi = {10.1002/smr.2319},
	url = {https://doi.org/10.1002%2Fsmr.2319},
	year = 2020,
	month = {nov},
	publisher = {Wiley},
	volume = {33},
	number = {4},
	author = {Jie Tan and Daniel Feitosa and Paris Avgeriou and Mircea Lungu},
	title = {Evolution of technical debt remediation in Python: A case study on the Apache Software Ecosystem},
	journal = {Journal of Software: Evolution and Process}
}","In this paper, we analyze the evolution of technical debt in 44 Python open-source software projects belonging to the Apache Software Foundation.","<Code from the aurhos>
SonarQube"
127,S128,Towards an Approach to Identify Obsolete Features based on Importance and Technical Debt,"Many of today's software systems are maintained over years or even decades. To ensure that software remains Useful, new features have to be added or old features have to be adapted to respond to new or changed requirements. As time goes on, some of the features become obsolete, i.e., are not needed anymore. Typically, these features are not removed becaUse of various reasons, e.g., becaUse removing them might be considered too costly, the costs of keeping unUsed features is considered low, or becaUse of the ""sunk cost fallacy"", i.e., that a feature is considered worth to keep becaUse of the previously invested resources (time, money or effort) to build it. The consequences of keeping unUsed source code can impact maintainability, technical debt, performance, and extensibility of the system. This can lead to lower development productivity and to a reduced innovation ability, consequently reducing competitiveness on the market. This paper aims to present an approach to identify features based on their value and on costs for keeping or removing them.",Propose,"Andrea Janes
Valentina Lenarduzzi",Academia,"2,020.00",Euromicro Conference on Software Engineering and Advanced Applications,Conference,http://doi.org/10.1109/SEAA51224.2020.00070,"@INPROCEEDINGS{Janes2020-ye,
  title           = ""Towards an approach to identify obsolete features based on
                     importance and technical debt"",
  booktitle       = ""2020 46th Euromicro Conference on Software Engineering and
                     Advanced Applications ({SEAA})"",
  author          = ""Janes, Andrea and Lenarduzzi, Valentina"",
  publisher       = ""IEEE"",
  month           =  aug,
  year            =  2020,
  copyright       = ""https://ieeexplore.ieee.org/Xplorehelp/downloads/license-information/IEEE.html"",
  conference      = ""2020 46th Euromicro Conference on Software Engineering and
                     Advanced Applications (SEAA)"",
  location        = ""Portoroz, Slovenia""
}",,"SonarQube
Jaeger"
128,S129,"Comparing Maintainability Index, SIG Method, and SQALE for Technical Debt Identification","There are many definitions of software Technical Debt (TD) that were Proposed over time. While many techniques to measure TD emerged in recent times, there is still not a clear understanding about how different techniques Compare when applied to software projects. The goal of this paper is to shed some light on this aspect, by comparing three techniques about TD identification that were Proposed over time: (i) the Maintainability Index (MI), (ii) SIG TD models, and (iii) SQALE analysis. Considering 20 open source Python libraries, we Compare the TD measurements time series in terms of trends and evolution according to different sets of releases (major, minor, and micro), to see if the perception of practitioners about TD evolution could be impacted. While all methods report generally growing trends of TD over time, there are different patterns. SQALE reports more periods of steady states Compared to MI and SIG TD. MI is the method that reports more repayments of TD Compared to the other methods. SIG TD and MI are the models that show more similarity in the way TD evolves, while SQALE and MI are less similar. The implications are that each method gives slightly a different perception about TD evolution.",Compare,"Peter Strecansky 
Stanislav Chren
Bruno Rossi",Academia,"2,020.00",Hindawi Scientific Programming,Journal,https://doi.org/10.1155/2020/2976564,"@ARTICLE{Strecansky2020-ji,
  title     = ""Comparing Maintainability Index, {SIG} method, and {SQALE} for
               Technical Debt identification"",
  author    = ""Stre{\v c}ansk{\'y}, Peter and Chren, Stanislav and Rossi, Bruno"",
  journal   = ""Sci. Program."",
  publisher = ""Hindawi Limited"",
  volume    =  2020,
  pages     = ""1--14"",
  month     =  jul,
  year      =  2020,
  language  = ""en""
}
","The goal of this paper is to shed some light on this aspect, by comparing three techniques about TD identification that
were Proposed over time: (i) the Maintainability Index (MI), (ii) SIG TD models, and (iii) SQALE analysis.","Radon
SonarQube"
129,S130,Skuld: A self-learning tool for impact-driven technical debt management,"As the development progresses, software projects tend to accumulate Technical Debt and become harder to maintain. Multiple tools exist with the mission to help practitioners to better manage Technical Debt. Despite this progress, there is a lack of tools providing actionable and self-learned suggestions to practitioners aimed at mitigating the impact of Technical Debt in real projects. We aim to create a data-driven, lightweight, and self-learning tool positioning highly impactful refactoring proposals on a Jira backlog. Bearing this goal in mind, the first two authors have founded a startup, called Skuld.ai, with the vision of becoming the go-to software renovation company. In this tool paper, we present the software architecture and demonstrate the main functionalities of our tool. It has been showcased to practitioners, receiving positive feedback. Currently, its release to the market is underway thanks to an industry-research institute collaboration with Fraunhofer IESE to incorporate self-learning technical debt capabilities. © 2020 ACM.",Propose,"Josep Burgaya Pujols
Pieter Bas
Silverio Martínez-Fernández
Antonio Martini
Adam Trendowicz",Both,"2,020.00",International Conference on Technical Debt,Conference,https://doi.org/10.1145/3387906.3388626,"@INPROCEEDINGS{Pujols2020-hk,
  title      = ""Skuld"",
  booktitle  = ""Proceedings of the 3rd International Conference on Technical
                Debt"",
  author     = ""Pujols, Josep Burgaya and Bas, Pieter and
                Mart{\'\i}nez-Fernandez, Silverio and Martini, Antonio and
                Trendowicz, Adam"",
  publisher  = ""ACM"",
  month      =  jun,
  year       =  2020,
  address    = ""New York, NY, USA"",
  conference = ""TechDebt '20: International Conference on Technical Debt"",
  location   = ""Seoul Republic of Korea""
}","We aim to create a data-driven, lightweight, and
self-learning tool positioning highly impactful refactoring
proposals on a Jira backlog.",Skuld
130,S131,Towards Better Technical Debt Detection with NLP and Machine Learning Methods,"Technical debt (TD) is an economical term Used to depict non-optimal choices made in the software development process. It occurs usually when developers take shortcuts instead of following agreed upon development practices, and unchecked growth of technical debt can start to incur negative effects for software development processes.Technical debt detection and management is mainly done manually, and this is both slow and costly way of detecting technical debt. Automatic detection would solve this issue, but even state-of-the-art tools of today do not accurately detect the appearance of technical debt. Therefore, increasing the accuracy of automatic classification is of high importance, so that we could eliminate significant portion from the costs relating to technical debt detection.This research aims to solve the problem in detection accuracy by bringing in together static code analysis and natural language processing. This combination of techniques will allow more accurate detection of technical debt, when Compared to them being Used separately from each other. Research also aims to discover themes and topics from written developer messages that can be linked to technical debt. These can help us to understand technical debt from developers' viewCite. Finally, we will build an open-source tool/plugin that can be Used to accurately detect technical debt using both static analysis and natural language processing methods. © 2020 ACM.",Propose,Leevi Rantala,Academia,"2,020.00",International Conference on Software Engineering: Companion Proceedings,Conference,https://doi.org/10.1145/3377812.3381404,"@ARTICLE{Volodina2022-ab,
  title     = ""Formation of future teachers' worldview culture by means of
               foreign-language education"",
  author    = ""Volodina, Olga V and
               {https://pnojournal.wordpress.com/2022/07/01/volodina-3/}"",
  journal   = ""P Sci Edu"",
  publisher = ""Scientific and Educational Initiative"",
  volume    =  57,
  number    =  3,
  pages     = ""126--159"",
  month     =  jul,
  year      =  2022
}
","This research aims to solve the problem in detection accuracy
by bringing in together static code analysis and natural language

processing. This combination of techniques will allow more ac-
curate detection of technical debt, when Compared to them being

Used separately from each other.",SonarQube
131,S132,Sen4Smells: A Tool for Ranking Sensitive Smells for an Architecture Debt Index,"Technical debt indexes are metrics for assessing the quality of a software system. Both academic and commercial tools have begun to provide computations of such indexes based on design violations and smells (e.g., cycles among system elements). When computing a debt index for a given project, a common Use case is that engineers look at the index values for spotting design issues that negatively affect system evolution and quality. In this context, those smells being critical for the system architecture should be promptly identified soastoe valuate proper remediation actions. However, the interpretation of an index value in terms of problematic smells is usually a manual and labor-intensive task for engineers. To help with this task, we Propose a tool called Sen4Smells that performs an automated sensitivity analysis for a given debt index based on the evolution of both the index values and the corresponding smells across (past) system versions. The Sen4Smells output is a ranking of smells that, due to their variations or instability, are major contributors to the debt index, and thus, can impact on architecture quality. Sen4Smells is designed as a pipeline that combines information from existing tools for smell detection, predefined d ebt i ndex f ormulas, and the Sobol method for sensitivity analysis. As a demonstration of the tool functionality, we briefly present implementations for the Arcan and Sonargraph tools with their respective debt indexes. ©2020 IEEE",Propose,"J. Andres Diaz-Pace
Antonela Tommasel
Ilaria Pigazzini
Francesca Arcelli Fontana",Academia,"2,020.00",Biennial Congress of Argentina,Conference,https://doi.org/10.1109/ARGENCON49523.2020.9505535,"@INPROCEEDINGS{Diaz-Pace2020-bk,
  title           = ""{Sen4Smells}: A tool for ranking sensitive smells for an
                     architecture debt index"",
  booktitle       = ""2020 {IEEE} Congreso Bienal de Argentina ({ARGENCON})"",
  author          = ""Diaz-Pace, J Andres and Tommasel, Antonela and Pigazzini,
                     Ilaria and Fontana, Francesca Arcelli"",
  publisher       = ""IEEE"",
  month           =  dec,
  year            =  2020,
  conference      = ""2020 IEEE Congreso Bienal de Argentina (ARGENCON)"",
  location        = ""Resistencia, Argentina""
}","To help with this task, we Propose

a tool called Sen4Smells that performs an automated sensitivity
analysis for a given debt index based on the evolution of both the
index values and the corresponding smells across (past) system
versions.",Sen4Smells
132,S133,Towards Microservice Smells Detection,"With the adoption of microservices architectural styles, practitioners started noticing increasing pitfalls in managing and maintaining such architectures, with the risk of introducing architectural debt. Previous studies identified different microservice smells (also named anti-patterns) that harm microservices architectures. However, according to our knowledge, there are no tools that can automatically detect microservice smells, so their identification is left to the experience of the developer. In this paper, we extend an existing tool developed for the detection of architectural smells to explore microservices architecture through the detection of three microservice smells: Cyclic Dependencies, Hard-Coded EndCites, and Shared Persistence. We detected the smells on five open-source projects implemented with microservices and manually validated the precision of the detection results. This work aims to open new perspectives on facing and studying architectural debt in the field of microservices architectures. © 2020 ACM.",Use,"Ilaria Pigazzini
Francesca Arcelli Fontana
Valentina Lenarduzzi
Davide Taibi",Academia,"2,020.00",International Conference on Technical Debt,Conference,https://doi.org/10.1145/3387906.3388625,"@INPROCEEDINGS{Pigazzini2020-xf,
  title      = ""Towards microservice smells detection"",
  booktitle  = ""Proceedings of the 3rd International Conference on Technical
                Debt"",
  author     = ""Pigazzini, Ilaria and Fontana, Francesca Arcelli and
                Lenarduzzi, Valentina and Taibi, Davide"",
  publisher  = ""ACM"",
  month      =  jun,
  year       =  2020,
  address    = ""New York, NY, USA"",
  conference = ""TechDebt '20: International Conference on Technical Debt"",
  location   = ""Seoul Republic of Korea""
}","In this paper, we extend an existing tool

developed for the detection of architectural smells to explore mi-
croservices architecture through the detection of three microservice

smells: Cyclic Dependencies, Hard-Coded EndCites, and Shared

Persistence.","Neo4j
Arcan"
133,S134,ATDx: A tool for Providing a Data-driven Overview of Architectural Technical Debt in Software-intensive Systems,"Architectural technical debt (ATD) in software-intensive systems is mostly invisible to software developers, can be widespread throughout entire code-bases, and its remediation cost is often steep. In recent years, numerous approaches have been Proposed to identify, keep track, and ultimately manage ATD. The variety of approaches available opens a new problem, namely how to gain an encompassing overview of the ATD identified in a software-intensive system. With this paper we make available the ATDx tool, an implementation of ATDx written in Python, designed in a plug-in fashion. ATDx is an approach designed to provide a data-driven, intuitive, and actionable overview of the ATD present in a portfolio of software projects. ATDx is based on third-party source code analysis tools, architectural issue severity calculation via clustering, and aggregation of measurements into different architectural technical debt dimensions. The ATDx tool allows Users to automatically run the ATDx analysis, generate reports containing the ATDx analysis results, and is integrated with GitHub. In addition to the tool, we provide two already implemented plugins, allowing Users to run the ATDx tool out-of-the-box. GitHub repository: https://github.com/S2-group/ATDx Video: https://youtu.be/ULT9fgxuB7E © 2021 Copyright for this paper by its authors. Use permitted under Creative Commons License Attribution 4.0 International (CC BY 4.0).",Propose,"Sebastian Ospina
Roberto Verdecchia
Ivano Malavolta
Patricia Lago",Academia,"2,021.00",European Conference on Software Architecture,Conference,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85117850664&partnerID=40&md5=ec083cccd8995030bb503d8e44957683,"@inproceedings{inproceedings,
author = {Ospina, Sebastian and Verdecchia, Roberto and Malavolta, Ivano and Lago, Patricia},
year = {2021},
month = {09},
pages = {},
title = {ATDx: A tool for Providing a Data-driven Overview of Architectural Technical Debt in Software-intensive Systems}
}","With this paper we make available the
ATDx tool, an implementation of ATDx written in Python, designed in a plug-in fashion.",ATDx:
134,S135,Determining Enterprise Architecture Smells from Software Architecture Smells,"Software Architectural Smells (SA smells) are design problems in the internal structure and behavior of an SA. These can be seen as a specific category under the umbrella concept of Technical Debt (TD). TD is a central concept in software development projects and having the means to detect and measure the smells is important to understand impairments they may caUse. However, TD is only limited to the technical aspects and does not describe smells found on an enterprise level. Enterprise Architecture Debt (EAD) expands the concepts of TD beyond the technical aspects such that it covers the debts that can be found in all layers of an Enterprise Architecture (EA). EA smells give a measurement for EAD, by providing means for detecting the smell, hence enabling a method to quantify the level of debt. The goal of this paper is to find EA smells derived from existing SA smells. This has resulted in three new EA smells that could be Used as measurements for the quality of an EA. They can also be Used in the future as a basis for automatic EA smell detection. © 2021 IEEE.",Use,"Benny Tieu
Simon Hacks",Academia,"2,021.00",Conference on Business Informatics,Conference,http://doi.org/10.1109/CBI52690.2021.10064,"@INPROCEEDINGS{Tieu2021-sq,
  title           = ""Determining enterprise architecture smells from software
                     architecture smells"",
  booktitle       = ""2021 {IEEE} 23rd Conference on Business Informatics
                     ({CBI})"",
  author          = ""Tieu, Benny and Hacks, Simon"",
  publisher       = ""IEEE"",
  month           =  sep,
  year            =  2021,
  copyright       = ""https://ieeexplore.ieee.org/Xplorehelp/downloads/license-information/IEEE.html"",
  conference      = ""2021 IEEE 23rd Conference on Business Informatics (CBI)"",
  location        = ""Bolzano, Italy""
}",The goal of this paper is to find EA smells derived from existing SA smells.,"inFusion
iPlasma
Arcan"
135,S136,Experiences on Managing Technical Debt with Code Smells and AntiPatterns,"Technical debt has become a common metaphor for the accumulation of software design and implementation choices that seek fast initial gains but that are under par and counterproductive in the long run. However, as a metaphor, technical debt does not offer actionable advice on how to get rid of it. To get to a practical level in solving problems, more focUsed mechanisms are needed. Commonly Used approaches for this include identifying code smells as quick indications of possible problems in the codebase and detecting the presence of AntiPatterns that refer to overt, recurring problems in design. There are known remedies for both code smells and AntiPatterns. In paper, our goal is to show how to effectively Use common tools and the existing body of knowledge on code smells and AntiPatterns to detect technical debt and pay it back. We present two main results: (i) How a combination of static code analysis and manual inspection was Used to detect code smells in a codebase leading to the discovery of AntiPatterns; and (ii) How AntiPatterns were Used to identify, characterize, and fix problems in the software. The experiences stem from a private company and its long-lasting software product development effort. © 2021 IEEE.",Cite,"Jacinto Ramirez Lahti
Antti-Pekka Tuovinen
Tommi Mikkonen",Both,"2,021.00",International Conference on Technical Debt,Conference,http://doi.org/10.1109/TechDebt52882.2021.00013,"@INPROCEEDINGS{Lahti2021-ot,
  title           = ""Experiences on managing technical debt with code smells
                     and {AntiPatterns}"",
  booktitle       = ""2021 {IEEE/ACM} International Conference on Technical Debt
                     ({TechDebt})"",
  author          = ""Lahti, Jacinto Ramirez and Tuovinen, Antti-Pekka and
                     Mikkonen, Tommi"",
  publisher       = ""IEEE"",
  month           =  may,
  year            =  2021,
  copyright       = ""https://ieeexplore.ieee.org/Xplorehelp/downloads/license-information/IEEE.html"",
  conference      = ""2021 IEEE/ACM International Conference on Technical Debt
                     (TechDebt)"",
  location        = ""Madrid, Spain""
}","In paper, our goal is to show how to effectively Use common
tools and the existing body of knowledge on code smells and
AntiPatterns to detect technical debt and pay it back.","CodeMR
IntelliJ IDEA"
136,S137,SATDBailiff-mining and tracking self-admitted technical debt,"Self-Admitted Technical Debt (SATD) is a metaphorical concept to describe the self-documented addition of technical debt to a software project in the form of source code comments. SATD can linger in projects and degrade source-code quality, but it can also be more visible than unintentionally added or undocumented technical debt. Understanding the implications of adding SATD to a software project is important becaUse developers can benefit from a better understanding of the quality trade-offs they are making. However, empirical studies, analyzing the survivability and removal of SATD comments, are challenged by potential code changes or SATD comment updates that may interfere with properly tracking their appearance, existence, and removal. In this paper, we Propose SATDBailiff, a tool that Uses an existing state-of-the-art SATD detection tool, to identify SATD in method comments, then properly track their lifespan. SATDBailiff is given as input links to open source projects, and its output is a list of all identified SATDs, and for each detected SATD, SATDBailiff reports all its associated changes, including any updates to its text, all the way to reporting its removal. The goal of SATDBailiff is to aid researchers and practitioners in better tracking SATDs instances, and providing them with a reliable tool that can be easily extended. SATDBailiff was validated using a dataset of previously detected and manually validated SATD instances. SATDBailiff is publicly available as an open source, along with the manual analysis of SATD instances associated with its validation, on the project website. © 2021 Elsevier B.V.",Propose,"Eman Abdullah AlOmar
Ben Christians
Mihal Busho
Ahmed Hamad AlKhalid
Ali Ouni
Christian Newman
Mohamed Wiem Mkaouer",Academia,"2,021.00",Science of Computer Programming,Journal,https://doi.org/10.1016/j.scico.2021.102693,"@article{AlOmar2022,
  doi = {10.1016/j.scico.2021.102693},
  url = {https://doi.org/10.1016/j.scico.2021.102693},
  year = {2022},
  month = jan,
  publisher = {Elsevier {BV}},
  volume = {213},
  pages = {102693},
  author = {Eman Abdullah AlOmar and Ben Christians and Mihal Busho and Ahmed Hamad AlKhalid and Ali Ouni and Christian Newman and Mohamed Wiem Mkaouer},
  title = {{SATDBailiff}-mining and tracking self-admitted technical debt},
  journal = {Science of Computer Programming}
}","In this paper, we Propose SATDBailiff, a tool that Uses an existing state-of-the-art SATD detection tool, to identify SATD in method comments, then properly track their lifespan.",SATDBailiff
137,S138,The Technical Debt Density Over Multiple Releases and the Refactoring Story,"Do developers postpone fixing Technical Debt (TD) in software systems? TD is a metaphor that refers to short-term decisions in software development that may affect the cost of the software development life cycle. The bad smell is an imperfect solution in the software system that negatively impacts the internal software quality and maintainability. In this paper, we will study five open-source software projects (OSSPs) that have several releases and also estimate the numbers of architecture smells (ASs), design smells (DSs), and code smells (CSs) for every release. Designite will be Used to detect smells. We describe a case study conducted to explore the following: (1) What is theaverage smells density for architecture, design, and code smells in an OSSP? (2) Does the density of each smell type increase over multiple releases? (3) What percentage of each smell-type density is eliminated by refactoring? We collected around 2 million LOC from five OSSPs that have multiple releases from the GitHub repository to statistically analyze the software concerning the smells as indicators of TD. We find 36% of Architecture Technical Debt (ATD) is Cyclic Dependency, while 33% of Design Debt (DD) is Cyclically-dependent Modularization. More than 70% of Code Debt (CD) is MagicNumber. Even though the developers do refactoring between releases, the TD density in general increases. On average, by refactoring, developers remove around 48%, 16%, and 22% from the introduced ATD, DD, and CD from their next release, respectively. © 2021 World Scientific Publishing Company.",Use,"Mrwan BenIdris
Hany Ammar
Dale Dzielski",Academia,"2,021.00",International Journal of Software Engineering and Knowledge Engineering,Journal,https://doi.org/10.1142/S0218194021500017,"@article{BenIdris_2021,
	doi = {10.1142/s0218194021500017},
	url = {https://doi.org/10.1142%2Fs0218194021500017},
	year = 2021,
	month = {jan},
	publisher = {World Scientific Pub Co Pte Lt},
	volume = {31},
	number = {01},
	pages = {99--116},
	author = {Mrwan BenIdris and Hany Ammar and Dale Dzielski},
	title = {The Technical Debt Density Over Multiple Releases and the Refactoring Story},
	journal = {International Journal of Software Engineering and Knowledge Engineering}
}","Designite will be Used to detect smells. We describe a case study conducted to explore
the following: (1) What is the average smells density for architecture, design, and code smells in an OSSP? (2) Does the density of each smell type increase over multiple releases? (3) What percentage of each smell-type density is eliminated by refactoring?",Designite
138,S139,"Experience With Managing Technical Debt in Scientific Software Development Using the
EXA2PRO Framework","Technical Debt (TD) is a software engineering metaphor that resembles the production of poor-quality code to going into debt. In particular, a development team that 'saves' effort while developing by not removing inefficiencies, has to 'pay-back' with interest, in the form of additional maintenance costs (i.e., fixing bugs, adding features, etc.) due to the poor maintainability of the developed code. Although maintainability assurance is an established practice in traditional software development (lately known as TD management), it has still not attracted the attention of scientific software developers; i.e., researchers writing code and developing tools for purely research purposes. Nevertheless, based on the literature and practice, maintainability seems to be ranked as an important key-driver for the development of such applications; since the effort needed to update the code before the experimentation (e.g., executing a simulation) is common and should not receive low priority. In this paper, we present the outcome of a 3-year research project on Technical Debt Management (TDM) for scientific software development. The outcome of the project is a framework (termed: EXA2PRO TDM framework) and an accompanying platform for assisting scientific software developers in managing the TD of their applications. The framework is a collection of methods tailored for the mainstream programming languages of scientific software development, which have been empirically validated through five pilot applications. The majority of the EXA2PRO framework suggestions have been applied by scientific software developers and eased future maintenance activities. © 2013 IEEE.",Cite,"NIKOLAOS NIKOLAIDIS
DIMITRIOS ZISIS
APOSTOLOS AMPATZOGLOU
ALEXANDER CHATZIGEORGIOU
DIMITRIOS SOUDRIS",Academia,"2,021.00",IEEE Access,Journal,http://doi.org/10.1109/ACCESS.2021.3079271,"@article{Nikolaidis_2021,
	doi = {10.1109/access.2021.3079271},
	url = {https://doi.org/10.1109%2Faccess.2021.3079271},
	year = 2021,
	publisher = {Institute of Electrical and Electronics Engineers ({IEEE})},
	volume = {9},
	pages = {72524--72534},
	author = {Nikolaos Nikolaidis and Dimitrios Zisis and Apostolos Ampatzoglou and Alexander Chatzigeorgiou and Dimitrios Soudris},
	title = {Experience With Managing Technical Debt in Scientific Software Development Using the {EXA}2PRO Framework},
	journal = {{IEEE} Access}
}","In this paper, we present the outcome of a 3-year research project on
Technical Debt Management (TDM) for scientific software development. The outcome of the project is a
framework (termed: EXA2PRO TDM framework) and an accompanying platform for assisting scientific
software developers in managing the TD of their applications.",EXA2PRO
139,S140,Technical Debt Forecasting Based on Deep Learning Techniques,"Technical debt (TD) is a metaphor commonly Used to reflect the consequences of quality compromises that can derive short-term benefits but may result in quality decay of software products in the long run. While a broad variety of methods and tools have been Proposed over the years for the identification and quantification of TD during the software development cycle, it is not until recently that researchers have turned their interest towards methods aiming to forecast the future TD evolution of a software project. Predicting the future value of TD could facilitate decision-making tasks regarding software maintenance and assist developers and project managers in taking proactive actions regarding TD repayment. In previous relevant studies, time series analysis and Machine Learning techniques have been employed in order to generate meaningful TD forecasts. While these approaches have been proven capable of producing reliable TD predictions, their predictive performance has been observed to decrease significantly for long-term predictions. To this end, in the present paper we investigate whether the adoption of Deep Learning may lead to more accurate long-term TD prediction. For this purpose, Deep Learning models are constructed, evaluated, and Compared based on a dataset of five popular real-world software applications. The results of our analysis indicate that the adoption of Deep Learning results in TD forecasting models with sufficient predictive performance up to 150 steps ahead into the future. © 2021, Springer Nature Switzerland AG.",Propose,"Maria Mathioudaki
Dimitrios Tsoukalas
Miltiadis Siavvas
Dionysios Kehagias",Academia,"2,021.00",International Conference on Computational Science and Its Applications,Conference,https://doi.org/10.1007/978-3-030-87007-2_22,"@incollection{Mathioudaki_2021,
	doi = {10.1007/978-3-030-87007-2_22},
	url = {https://doi.org/10.1007%2F978-3-030-87007-2_22},
	year = 2021,
	publisher = {Springer International Publishing},
	pages = {306--322},
	author = {Maria Mathioudaki and Dimitrios Tsoukalas and Miltiadis Siavvas and Dionysios Kehagias},
	title = {Technical Debt Forecasting Based on Deep Learning Techniques},
	booktitle = {Computational Science and Its Applications {\textendash} {ICCSA} 2021}
}","To this end, in the present paper we investigate whether the adoption of Deep
Learning models may lead to accurate and practical TD forecasts, giving partic-
ular emphasis on the long-term predictions that have been the most important
limitation of our previous relevant studies [15,16]. For this purpose, we utilize
TD measurements throughout the different commits of five open-source Java
projects obtained from the Technical Debt Dataset [18]. Subsequently, based on
this dataset, a Multi-layer Perceptron (MLP) model is constructed and exper-
iments are performed for each of the five projects for 5 to 150 commits ahead.","Keras
Scikit-Learn
SonarQube"
140,S141,Machine Learning for Technical Debt Identification,"Technical Debt (TD) is a successful metaphor in conveying the consequences of software inefficiencies and their elimination to both technical and non-technical stakeholders, primarily due to its monetary nature. The identification and quantification of TD rely heavily on the Use of a small handful of sophisticated tools that check for violations of certain predefined rules, usually through static analysis. Different tools result in divergent TD estimates calling into question the reliability of findings derived by a single tool. To alleviate this issue we Use 18 metrics pertaining to source code, repository activity, issue tracking, refactorings, duplication and commenting rates of each class as features for statistical and Machine Learning models, so as to classify them as High-TD or not. As a benchmark we exploit 18.857 classes obtained from 25 Java projects, whose high levels of TD has been confirmed by three leading tools. The findings indicate that it is feasible to identify TD issues with sufficient accuracy and reasonable effort: a subset of superior classifiers achieved an F&lt;sub&gt;2&lt;/sub&gt;-measure score of approximately 0.79 with an associated Module Inspection ratio of approximately 0.10. Based on the results a tool prototype for automatically assessing the TD of Java projects has been implemented. IEEE",Propose,"Dimitrios Tsoukalas
Nikolaos Mittas
Alexander Chatzigeorgiou
Dionysios Kehagias
Apostolos Ampatzoglou
Theodoros Amanatidis
Lefteris Angelis",Academia,"2,021.00",IEEE TRANSACTIONS ON SOFTWARE ENGINEERING,Journal,http://doi.org/10.1109/TSE.2021.3129355,"@article{Tsoukalas_2021,
	doi = {10.1109/tse.2021.3129355},
	url = {https://doi.org/10.1109.tse.2021.3129355},
	year = 2021,
	publisher = {Institute of Electrical and Electronics Engineers ({IEEE})},
	pages = {1--1},
	author = {Dimitrios Tsoukalas and Nikolaos Mittas and Alexandros Chatzigeorgiou and Dionisis D. Kehagias and Apostolos Ampatzoglou and Theodoros Amanatidis and Lefteris Angelis},
	title = {Machine Learning for Technical Debt Identification},
	journal = {{IEEE} Transactions on Software Engineering}
}","To alleviate this issue we Use 18 metrics pertaining to source code, repository activity, issue tracking, refactorings, duplication and commenting rates of each class as features for statistical and Machine Learning models, so as to classify them as High-TD or not. As a
benchmark we exploit 18,857 classes obtained from 25 Java projects, whose high levels of TD has been confirmed by three leading tools.","TD Benchmarker
PyDriller 
RMiner
CK [26]
PMD’s Copy/Paste Detector
cloc
Scikit-Learn"
141,S142,FixMe: A GitHub Bot for Detecting and Monitoring On-Hold Self-Admitted Technical Debt,"Self-Admitted Technical Debt (SATD) is a special form of technical debt in which developers intentionally record their hacks in the code by adding comments for attention. Here, we focus on issue-related ""On-hold SATD"", where developers suspend proper implementation due to issues reported inside or outside the project. When the referenced issues are resolved, the On-hold SATD also need to be addressed, but since monitoring these issue reports takes a lot of time and effort, developers may not be aware of the resolved issues and leave the On-hold SATD in the code. In this paper, we Propose FixMe, a GitHub bot that helps developers detecting and monitoring On-hold SATD in their repositories and notify them whenever the On-hold SATDs are ready to be fixed (i.e. the referenced issues are resolved). The bot can automatically detect On-hold SATD comments from source code using machine learning techniques and discover referenced issues. When the referenced issues are resolved, developers will be notified by FixMe bot. The evaluation conducted with 11 participants shows that our FixMe bot can support them in dealing with On-hold SATD. FixMe is available at https://www.fixmebot.app/ and FixMe's VDO is at https://youtu.be/YSz9kFxN_YQ. © 2021 IEEE.",Propose,"Saranphon Phaithoon
Supakarn Wongnil
Patiphol Pussawong
Morakot Choetkiertikul
Chaiyong Ragkhitwetsagul
Thanwadee Sunetnanta
Rungroj Maipradit
Hideaki Hata
Kenichi Matsumoto†",Academia,"2,021.00",International Conference on Automated Software Engineering,Conference,https://doi.org/10.1109/ASE51524.2021.9678680,"@inproceedings{Phaithoon_2021,
        doi = {10.1109/ase51524.2021.9678680},
        url = {https://doi.org/10.1109%2Fase51524.2021.9678680},
        year = 2021,
        month = {nov},
        publisher = {{IEEE}},
        author = {Saranphon Phaithoon and Supakarn Wongnil and Patiphol Pussawong and Morakot Choetkiertikul and Chaiyong Ragkhitwetsagul and Thanwadee Sunetnanta and Rungroj Maipradit and Hideaki Hata and Kenichi Matsumoto},
        title = {{FixMe}: A {GitHub} Bot for Detecting and Monitoring On-Hold Self-Admitted Technical Debt},
        booktitle = {2021 36th {IEEE}/{ACM} International Conference on Automated Software Engineering ({ASE})}
}
","In this paper, we Propose FixMe, a GitHub bot that helps developers detecting and monitoring On-hold SATD in their repositories and notify them whenever the On-hold SATDs are ready to be fixed (i.e. the referenced issues are resolved).",FixMe
142,S143,A Clustering Approach Towards Cross‐Project Technical Debt Forecasting,"Technical debt (TD) describes quality compromises that can yield short-term benefits but may negatively affect the quality of software products in the long run. A wide range of tools and techniques have been introduced over the years in order for the developers to be able to determine and manage TD. However, being able to also predict its future evolution is of equal importance to avoid its accumulation, and, in turn, the unlikely event of making the project unmaintainable. Although recent research endeavors have showcased the feasibility of building accurate project-specific TD forecasting models, there is a gap in the field regarding cross-project TD forecasting. Cross-project TD forecasting is of practical importance, since it would enable the application of pre-existing forecasting models on previously unknown software projects, especially new projects that do not exhibit sufficient commit history to enable the construction of project-specific models. To this end, in the present paper, we focus on cross-project TD forecasting, and we examine whether the consideration of similarities between software projects could be the key for more accurate forecasting. More specifically, we Propose an approach based on data clustering. In fact, a relatively large repository of software projects is divided into clusters of similar projects with respect to their TD aspects, and specific TD forecasting models are built for each cluster, using regression algorithms. According to our approach, previously unknown software projects are assigned to one of the defined clusters and the cluster-specific TD forecasting model is applied to predict future TD values. The approach was evaluated through several experiments based on real-world applications. The results of the analysis suggest that the Proposed approach comprises a promising solution for accurate cross-project TD forecasting. © 2021, Springer Nature Singapore Pte Ltd.",Propose,"Dimitrios Tsoukalas
Maria Mathioudaki
Miltiadis Siavvas
Dionysios Kehagias
Alexander Chatzigeorgiou",Academia,"2,021.00",SN Computer Science,Journal,https://doi.org/10.1007/s42979-020-00408-4,"@article{Tsoukalas_2021,
	doi = {10.1007/s42979-020-00408-4},
	url = {https://doi.org/10.1007%2Fs42979-020-00408-4},
	year = 2021,
	month = {jan},
	publisher = {Springer Science and Business Media {LLC}},
	volume = {2},
	number = {1},
	author = {Dimitrios Tsoukalas and Maria Mathioudaki and Miltiadis Siavvas and Dionysios Kehagias and Alexander Chatzigeorgiou},
	title = {A Clustering Approach Towards Cross-Project Technical Debt Forecasting},
	journal = {{SN} Computer Science}
}","To this end, in the present paper, to overcome the aforementioned problem, we intro-
duce a novel clustering-based approach that aims to improve the performance of TD forecasting models in cross-project prediction.","Scikit-Learn
SonarQube"
143,S144,Impact of Opportunistic ReUse Practices to Technical Debt,"Technical debt (TD) has been recognized as an important quality problem for both software architecture and code. The evolution of TD techniques over the past years has led to a number of research and commercial tools. In addition, the increasing trend of opportunistic reUse (as opposed to systematic reUse), where developers reUse code assets in popular repositories, is changing the way components are selected and integrated into existing systems. However, reusing software opportunistically can lead to a loss of quality and induce TD, especially when the architecture is changed in the process. However, to the best of our knowledge, no studies have investigated the impact of opportunistic reUse in TD. In this paper, we carry out an exploratory study to investigate to what extent reusing components opportunistically negatively affects the quality of systems. We Use one commercial and one research tool to analyze the TD ratios of three case systems, before and after opportunistically extending them with open-source software. © 2021 IEEE.",Cite,"Rafael Capilla
Tommi Mikkonen
Carlos Carrillo
Francesca Arcelli Fontana
Ilaria Pigazzini
Valentina Lenarduzzi",Academia,"2,021.00",International Conference on Technical Debt,Conference,http://doi.org/10.1109/TechDebt52882.2021.00011,"@inproceedings{Capilla_2021,
	doi = {10.1109/techdebt52882.2021.00011},
	url = {https://doi.org/10.1109%2Ftechdebt52882.2021.00011},
	year = 2021,
	month = {may},
	publisher = {{IEEE}},
	author = {Rafael Capilla and Tommi Mikkonen and Carlos Carrillo and Francesca Arcelli Fontana and Ilaria Pigazzini and Valentina Lenarduzzi},
	title = {Impact of Opportunistic ReUse Practices to Technical Debt},
	booktitle = {2021 {IEEE}/{ACM} International Conference on Technical Debt ({TechDebt})}
}","In this paper, we carry out an exploratory study to investigate to what extent reusing components opportunistically negatively affects the quality of systems. We Use one commercial and one research tool to analyze the TD ratios of three case systems, before and after opportunistically extending them with open-source software.","SonarQube
Arcan"
144,S145,On the Lack of Consensus Among Technical Debt Detection Tools,"A vigorous and growing set of technical debt analysis tools have been developed in recent years-both research tools and industrial products-such as Structure 101, SonarQube, and DV8. Each of these tools identifies problematic files using their own definitions and measures. But to what extent do these tools agree with each other in terms of the files that they identify as problematic? If the top-ranked files reported by these tools are largely consistent, then we can be confident in using any of these tools. Otherwise, a problem of accuracy arises. In this paper, we report the results of an empirical study analyzing 10 projects using multiple tools. Our results show that: 1) these tools report very different results even for the most common measures, such as size, complexity, file cycles, and package cycles. 2) These tools also differ dramatically in terms of the set of problematic files they identify, since each implements its own definitions of 'problematic'. After normalizing by size, the most problematic file sets that the tools identify barely overlap. 3) Our results show that code-based measures, other than size and complexity, do not even moderately correlate with a file's change-proneness or error-proneness. In contrast, co-change-related measures performed better. Our results suggest that, to identify files with true technical debt-those that experience excessive changes or bugs-co-change information must be considered. Code-based measures are largely ineffective at pinCiteing true debt. Finally, this study reveals the need for the community to create benchmarks and data sets to assess the accuracy of software analysis tools in terms of commonly Used measures. © 2021 IEEE.",Compare,"Jason Lefever
Yuanfang Cai
Humberto Cervantes
Rick Kazman
Hongzhou Fang",Academia,"2,021.00",International Conference on Software Engineering: Software Engineering in Practice,Conference,http://doi.org/10.1109/ICSE-SEIP52600.2021.00021,"@INPROCEEDINGS{Lefever2021-ot,
  title           = ""On the lack of consensus among technical debt detection
                     tools"",
  booktitle       = ""2021 {IEEE/ACM} 43rd International Conference on Software
                     Engineering: Software Engineering in Practice
                     ({ICSE-SEIP})"",
  author          = ""Lefever, Jason and Cai, Yuanfang and Cervantes, Humberto
                     and Kazman, Rick and Fang, Hongzhou"",
  publisher       = ""IEEE"",
  month           =  may,
  year            =  2021,
  conference      = ""2021 IEEE/ACM 43rd International Conference on Software
                     Engineering: Software Engineering in Practice (ICSE-SEIP)"",
  location        = ""Madrid, ES""
}",,"SonarQube
Designite Java
DV8
Structure101
Archinaut
Succinct Code Counter"
145,S146,An Overview and Comparison of Technical Debt Measurement Tools,"Different tools adopt different terms, metrics, and ways to identify and measure technical debt (TD). Researchers attempt to clarify the situation by comparing the features and popularity of technical debt measurement tools and analyzing the existing empirical evidence on their validity. Researchers’ aim is to provide an overview of the current landscape of TD measurement tools through a set of objective criteria related to the offered features and their popularity. Practitioners can Use this overview to assess the tools, understand their strengths and weaknesses, and ultimately select the most suitable one for their needs.",Compare,"Paris Avgeriou
Davide Taibi
Apostolos Ampatzoglou
Francesca Arcelli Fontana
Terese Besker
Alexander Chatzigeorgiou
Valentina Lenarduzzi
Antonio Martini
Athanasia Moschou
Ilaria Pigazzini
Nyyti Saarimäki
Darius Sas
Saulo Soares de Toledo
Angeliki Tsintzira",Academia,"2,021.00",IEEE Software,Journal,https://doi.org/10.1109/MS.2020.3024958,"@ARTICLE{Avgeriou2021-fi,
  title     = ""An overview and comparison of technical debt measurement tools"",
  author    = ""Avgeriou, Paris C and Taibi, Davide and Ampatzoglou, Apostolos
               and Arcelli Fontana, Francesca and Besker, Terese and
               Chatzigeorgiou, Alexander and Lenarduzzi, Valentina and Martini,
               Antonio and Moschou, Athanasia and Pigazzini, Ilaria and
               Saarimaki, Nyyti and Sas, Darius Daniel and de Toledo, Saulo
               Soares and Tsintzira, Angeliki Agathi"",
  journal   = ""IEEE Softw."",
  publisher = ""Institute of Electrical and Electronics Engineers (IEEE)"",
  volume    =  38,
  number    =  3,
  pages     = ""61--71"",
  month     =  may,
  year      =  2021,
  copyright = ""https://ieeexplore.ieee.org/Xplorehelp/downloads/license-information/IEEE.html""
}","Different tools adopt different terms, metrics, and ways to identify and measure technical debt.We attempt to clarify the situation by comparing the features and popularity of technical debt measurement tools and analyzing the existing empirical evidence on their validity.","CAST
SonarGraph
NDepend
SonarQube
SQuORE
CodeMRI
Code Inspector
DV8
SymfonyInsight"
146,S147,DebtHunter: A Machine Learning-based Approach for Detecting Self-Admitted Technical Debt,"Due to limited time, budget or resources, a team is prone to introduce code that does not follow the best software development practices. This code that introduces instability in the software projects is known as Technical Debt (TD). Often, TD intentionally manifests in source code, which is known as Self-Admitted Technical Debt (SATD). This paper presents DebtHunter, a natural language processing (NLP)- and machine learning (ML)- based approach for identifying and classifying SATD in source code comments. The Proposed classification approach combines two classification phases for differentiating between the multiple debt types. Evaluations over 10 open source systems, containing more than 259k comments, showed that the approach was able to improve the performance of others in the literature. The presented approach is supported by a tool that can help developers to effectively manage SATD. The tool complements the analysis over Java source code by allowing developers to also examine the associated issue tracker. DebtHunter can be Used in a continuous evolution environment to monitor the development process and make developers aware of how and where SATD is introduced, thus helping them to manage and resolve it. © 2021 ACM.",Propose,"Irene Sala
Antonela Tommasel
Francesca Arcelli Fontana",Academia,"2,021.00",Evaluation and Assessment in Software Engineering,Conference,https://doi.org/10.1145/3463274.3464455,"@INPROCEEDINGS{Sala2021-gk,
  title      = ""{DebtHunter}: A machine learning-based approach for detecting
                self-admitted technical debt"",
  booktitle  = ""Evaluation and Assessment in Software Engineering"",
  author     = ""Sala, Irene and Tommasel, Antonela and Arcelli Fontana,
                Francesca"",
  publisher  = ""ACM"",
  month      =  jun,
  year       =  2021,
  address    = ""New York, NY, USA"",
  conference = ""EASE 2021: Evaluation and Assessment in Software Engineering"",
  location   = ""Trondheim Norway""
}","This paper presents DebtHunter, a natural language processing (NLP)- and machine learning (ML)- based approach for identifying and classifying SATD in source code comments.",DebtHunter
147,S148,Architectural Technical Debt of Multiagent Systems Development Platforms,"Technical debt is candidate to be the next buzzword in software engineering, and the number of studies evaluating the technical debt of software projects is increasing. A particular and dangerous type of debt is the architectural debt, i.e., the consequences of sub-optimal design decisions. Currently, there are no studies about the evaluation of architectural debt in MultiAgent Systems (MAS) and platforms. Hence, in this paper we Propose the analysis of four well-known MAS development platforms, with the aim of evaluating their architectural debt and open the discussion in this field. We exploit a tool, named Arcan, developed for architectural smell detection and for the computation of an architectural debt index. The results show that MAS development platforms are subjected to architectural debt, and in particular to the presence of Cyclic Dependency smells. However, there is evidence that the minimum amount of debt is reached when developers report “bug fixes” and “Improvements”. © 2021 CEUR-WS. All rights reserved.",Use,"Ilaria Pigazzini
Daniela Briola
Francesca Arcelli Fontana",Academia,"2,021.00",Workshop From Objects to Agents,Workshop,,,,Arcan
148,S149,Metrics to Measure Code Complexity Based on Software Design: Practical Evaluation,"Software complexity is an indicator to the quality of software. It shows that a software or a component of software has a design or implementation that is difficult to understand, modify and maintain. Many complexity metrics have been developed by researchers to identify and measure the degree of complexity. Unfortunately, Current complexity metrics are based on the number of model elements only, regardless of the complexity of those elements themselves. In this paper, we Propose new code complexity metrics that are derived from its design. This approach ensures that the derived metrics are uniquely tailored for the software under development, and the derived metrics are unique for each software module. In this study, we aim to attempt an empirical evaluation study in order to have a clear understanding of the Proposed complexity metrics. We investigated whether there is a correlation between the Proposed UML Class Diagram complexity and the associated code, specially code size, code smells, and technical debt. The result shows that there is a high correlation between the design driven code complexity metrics and the associated code. © 2021, The Author(s), under exclusive license to Springer Nature Switzerland AG.",Use,"Omar Masmali
Omar Badreddin
Rahad khandoker",Academia,"2,021.00",Future of Information and Communication Conference,Conference,https://doi.org/10.1007/978-3-030-73103-8_9,"@INCOLLECTION{Masmali2021-ps,
  title     = ""Metrics to measure code complexity based on software design:
               Practical evaluation"",
  booktitle = ""Advances in Intelligent Systems and Computing"",
  author    = ""Masmali, Omar and Badreddin, Omar and Khandoker, Rahad"",
  publisher = ""Springer International Publishing"",
  pages     = ""142--157"",
  series    = ""Advances in intelligent systems and computing"",
  year      =  2021,
  address   = ""Cham""
}","In this paper, we Propose new code complexity metrics that are derived from its design. This
approach ensures that the derived metrics are uniquely tailored for the software
under development, and the derived metrics are unique for each software module.","PMD
inFusion
JDeodorant
JSpIRIT
SonarQube
Understand
Visual Paradigm"
149,S150,The Need for Holistic Technical Debt Management across the Value Stream: Lessons Learnt and Open Challenges,"The long lifetime and the evolving nature of industrial products make them subject to technical debt at different levels. Despite multiple years of research on technical debt management, our industrial experience shows that introducing systematic technical debt management in a large-scale company is very challenging. To identify the challenges, we provide a conceptual framework for holistic debt management across the product development value stream, which takes multiple categories of debt and their interplays into account. We Use this framework to identify multiple challenges that are still open to be explored by the research community. Due to the practical nature of technical debt management, we believe this paper can guide the research community on the needs of industry for the effective application of technical debt management in practice. © 2021 IEEE.",Cite,"Somayeh Malakuti
Jens Heuschkel",Industry,"2,021.00",International Conference on Technical Debt,Conference,https://doi.org/10.1145/1122445.1122456,"@INPROCEEDINGS{Malakuti2021-jd,
  title           = ""The need for holistic technical debt management across the
                     value stream: Lessons learnt and open challenges"",
  booktitle       = ""2021 {IEEE/ACM} International Conference on Technical Debt
                     ({TechDebt})"",
  author          = ""Malakuti, Somayeh and Heuschkel, Jens"",
  publisher       = ""IEEE"",
  month           =  may,
  year            =  2021,
  copyright       = ""https://ieeexplore.ieee.org/Xplorehelp/downloads/license-information/IEEE.html"",
  conference      = ""2021 IEEE/ACM International Conference on Technical Debt
                     (TechDebt)"",
  location        = ""Madrid, Spain""
}","To identify the challenges, we provide a conceptual framework for holistic debt management across the product development value stream, which takes multiple categories of debt and their interplays into account. We Use this framework to identify multiple challenges that are still open to be explored by the research community.","Lattix
SonarQube"
150,S151,Building and evaluating a theory of architectural technical debt in software-intensive systems,"Architectural technical debt in software-intensive systems is a metaphor Used to describe the “big” design decisions (e.g., choices regarding structure, frameworks, technologies, languages, etc.) that, while being suitable or even optimal when made, significantly hinder progress in the future. While other types of debt, such as code-level technical debt, can be readily detected by static analyzers, and often be refactored with minimal or only incremental efforts, architectural debt is hard to be identified, of wide-ranging remediation cost, daunting, and often avoided. In this study, we aim at developing a better understanding of how software development organizations conceptualize architectural debt, and how they deal with it. In order to do so, in this investigation we apply a mixed empirical method, constituted by a grounded theory study followed by focus groups. With the grounded theory method we construct a theory on architectural technical debt by eliciting qualitative data from software architects and senior technical staff from a wide range of heterogeneous software development organizations. We applied the focus group method to evaluate the emerging theory and refine it according to the new data collected. The result of the study, i.e., a theory emerging from the gathered data, constitutes an encompassing conceptual model of architectural technical debt, identifying and relating concepts such as its symptoms, caUses, consequences, management strategies, and communication problems. From the conducted focus groups, we assessed that the theory adheres to the four evaluation criteria of classic grounded theory, i.e., the theory fits its underlying data, is able to work, has relevance, and is modifiable as new data appears. By grounding the findings in empirical evidence, the theory provides researchers and practitioners with novel knowledge on the crucial factors of architectural technical debt experienced in industrial contexts. © 2021 The Author(s)",Use,"Roberto Verdecchia
Philippe Kruchten
Patricia Lago
Ivano Malavolta",Academia,"2,021.00",The Journal of Systems and Software,Journal,https://doi.org/10.1016/j.jss.2021.110925,"@ARTICLE{Verdecchia2021-as,
  title     = ""Building and evaluating a theory of architectural technical debt
               in software-intensive systems"",
  author    = ""Verdecchia, Roberto and Kruchten, Philippe and Lago, Patricia
               and Malavolta, Ivano"",
  journal   = ""J. Syst. Softw."",
  publisher = ""Elsevier BV"",
  volume    =  176,
  number    =  110925,
  pages     = ""110925"",
  month     =  jun,
  year      =  2021,
  copyright = ""http://creativecommons.org/licenses/by/4.0/"",
  language  = ""en""
}","In this study, we aim at developing a better understanding of how software development organizations conceptualize architectural debt, and how they deal with it.","Clang Tidy
SonarQube
Ndepend"
151,S152,Self-admitted technical debt practices: a comparison between industry and open-source,"Self-admitted technical debt (SATD) consists of annotations, left by developers as comments in the source code or elsewhere, as a reminder about pieces of software manifesting technical debt (TD), i.e., “not being ready yet”. While previous studies have investigated SATD management and its relationship with software quality, there is little understanding of the extent and circumstances to which developers admit TD. This paper reports the results of a study in which we asked developers from industry and open-source about their practices in annotating source code and other artifacts for self-admitting TD. The study consists of two phases. First, we conducted 10 interviews to gather a first understanding of the phenomenon and to prepare a survey questionnaire. Then, we surveyed 52 industrial developers as well as 49 contributors to open-source projects. Results of the study show how the TD annotation practices, as well as the typical content of SATD comments, are very similar between open-source and industry. At the same time, our results highlight how, while open-source code is spread of comments admitting the need for improvements, SATD in industry may be dictated by organizational guidelines but, at the same time, implicitly discouraged by the fear of admitting responsibilities. Results also highlight the need for tools helping developers to achieve a better TD awareness. © 2021, The Author(s), under exclusive licence to Springer Science+Business Media, LLC, part of Springer Nature.",Propose,"Fiorella Zampetti
Gianmarco Fucci
Alexander Serebrenik
Massimiliano Di Penta",Academia,"2,021.00",Empirical Software Engineering,Journal,https://doi.org/10.1007/s10664-021-10031-3,"@article{Zampetti_2021,
	doi = {10.1007/s10664-021-10031-3},
	url = {https://doi.org/10.1007%2Fs10664-021-10031-3},
	year = 2021,
	month = {sep},
	publisher = {Springer Science and Business Media {LLC}},
	volume = {26},
	number = {6},
	author = {Fiorella Zampetti and Gianmarco Fucci and Alexander Serebrenik and Massimiliano Di Penta},
	title = {Self-admitted technical debt practices: a comparison between industry and open-source},
	journal = {Empirical Software Engineering}
}",This paper reports the results of a study in which we asked developers from industry and open-source about their practices in annotating source code and other artifacts for self-admitting TD.,"todo
Probot (framework to develop apps for automate github workflow)"
152,S153,QScored: A Large Dataset of Code Smells and Quality Metrics,"Code quality aspects such as code smells and code quality metrics are widely Used in exploratory and empirical software engineering research. In such studies, researchers spend a substantial amount of time and effort to not only select the appropriate subject systems but also to analyze them to collect the required code quality information. In this paper, we present QScored dataset; the dataset contains code quality information of more than 86 thousand C# and Java GitHub repositories containing more than 1.1 billion lines of code. The code quality information contains seven kinds of detected architecture smells, 20 kinds of design smells, eleven kinds of implementation smells, and 27 commonly Used code quality metrics computed at project, package, class, and method levels. Availability of the dataset will facilitate empirical studies involving code quality aspects by making the information readily available for a large number of active GitHub repositories. © 2021 IEEE.",Cite,"Tushar Sharma
Marouane Kessentini",Both,"2,021.00",International Conference on Mining Software Repositories,Conference,http://doi.org/10.1109/MSR52588.2021.00080,"@inproceedings{Sharma_2021,
	doi = {10.1109/msr52588.2021.00080},
	url = {https://doi.org/10.1109%2Fmsr52588.2021.00080},
	year = 2021,
	month = {may},
	publisher = {{IEEE}},
	author = {Tushar Sharma and Marouane Kessentini},
	title = {{QScored}: A Large Dataset of Code Smells and Quality Metrics},
	booktitle = {2021 {IEEE}/{ACM} 18th International Conference on Mining Software Repositories ({MSR})}
}","In this paper, we present
QScored dataset; the dataset contains code quality information
of more than 86 thousand C# and Java GitHub repositories
containing more than 1.1 billion lines of code.","Designite
DesigniteJava
QScored"
153,S154,One Step Further: Investigating Problematic Files of Architecture Anti-patterns,"Architecture anti-patterns violate design principles and negatively impact software internal quality. Both academia and industry have designed methods and tools to detect anti-patterns. However, these tools tend to report a large number of defects, hindering developers from prioritizing true debts. In this work, we take one step further to explore the most problematic files (we define them as root files) in the architecture anti-patterns, which are potential caUses leading to the difficulty of software maintenance. Using 45 Python projects as subjects, we investigate root files' maintainability, evolution (i.e., birth, living, and death), and their interactions in different architecture anti-patterns. Our results reveal that, Compared with other files in anti-patterns, these root files take only a small proportion but incur heavy maintenance costs. Our study of their evolution and interactions can help developers identify potential caUses of anti-patterns. We believe our findings will benefit the practice of design problem fixing. © 2021 IEEE.",Use,"Jingwen Liu
Wuxia Jin
Qiong Feng
Xinyu Zhang
Yitong Dai",Academia,"2,021.00",International Symposium on Software Reliability Engineering,Conference,http://doi.org/10.1109/ISSRE52982.2021.00060,"@inproceedings{Liu_2021,
	doi = {10.1109/issre52982.2021.00060},
	url = {https://doi.org/10.1109%2Fissre52982.2021.00060},
	year = 2021,
	month = {oct},
	publisher = {{IEEE}},
	author = {Jingwen Liu and Wuxia Jin and Qiong Feng and Xinyu Zhang and Yitong Dai},
	title = {One Step Further: Investigating Problematic Files of Architecture Anti-patterns},
	booktitle = {2021 {IEEE} 32nd International Symposium on Software Reliability Engineering ({ISSRE})}
}","Using 45 Python projects as subjects, we investigate
root files’ maintainability, evolution (i.e., birth, living, and death),
and their interactions in different architecture anti-patterns.","DV8
AI Reviewer
ARCADE
Arcan
Designite
Sonargraph
Structure 101"
154,S155,Refactorings and Technical Debt in Docker Projects: An Empirical Study,"Software containers, such as Docker, are recently considered as the mainstream technology of providing reusable software artifacts. Developers can easily build and deploy their applications based on the large number of reusable Docker images that are publicly available. Thus, a current popular trend in industry is to move towards the containerization of their applications. However, container-based projects compromise different components including the Docker and Docker-compose files, and several other dependencies to the source code combining different containers and facilitating the interactions with them. Similar to any other complex systems, container-based projects are prone to various quality and technical debt issues related to different artifacts: Docker and Docker-compose files, and regular source code ones. Unfortunately, there is a gap of knowledge in how container-based projects actually evolve and are maintained.In this paper, we address the above gap by studying refactorings, i.e., structural changes while preserving the behavior, applied in open-source Docker projects, and the technical debt issues they alleviate. We analyzed 68 projects, consisting of 19, 5 MLOC, along with 193 manually examined commits. The results indicate that developers refactor these Docker projects for a variety of reasons that are specific to the configuration, combination and execution of containers, leading to several new technical debt categories and refactoring types Compared to existing refactoring domains. For instance, refactorings for reducing the image size of Dockerfiles, improving the extensibility of Docker-compose files, and regular source code refactorings are mainly associated with the evolution of Docker and Docker-compose files. We also introduced 24 new Docker-specific refactorings and technical debt categories, respectively, and defined different best practices. The implications of this study will assist practitioners, tool builders, and educators in improving the quality of Docker projects. © 2021 IEEE.",Use,"Emna Ksontini
Marouane Kessentini
Thiago do N. Ferreira
Foyzul Hassan",Academia,"2,021.00",International Conference on Automated Software Engineering,Conference,https://doi.org/10.1109/ASE51524.2021.9678585,"@inproceedings{Ksontini_2021,
	doi = {10.1109/ase51524.2021.9678585},
	url = {https://doi.org/10.1109%2Fase51524.2021.9678585},
	year = 2021,
	month = {nov},
	publisher = {{IEEE}},
	author = {Emna Ksontini and Marouane Kessentini and Thiago do N. Ferreira and Foyzul Hassan},
	title = {Refactorings and Technical Debt in Docker Projects: An Empirical Study},
	booktitle = {2021 36th {IEEE}/{ACM} International Conference on Automated Software Engineering ({ASE})}
}","In this paper, we address the above gap by studying refactorings, i.e., structural changes while preserving the behavior, applied in open-source Docker projects, and the technical debt
issues they alleviate.","RMiner
"
155,S156,Two Different Facets of Architectural Smells Criticality: An Empirical Study,"Architectural smells (AS) represent symptoms of problems at architectural level that have an impact on architectural debt. It is important to identify among them the most critical ones, so that developers can prioritize them for their removal. In order to evaluate the criticality of AS, in this paper we consider two facets: the PageRank metric, to assess the centrality of a smell in a project, and Severity, a metric to estimate the cost-solving of smells. We have Proposed these two metrics in a previous work and here we perform an empirical analysis of the evolution and correlation of these metrics in the version history of 10 projects (at least 22 versions each, 264 projects in total). The analysis of the evolution is Useful in order to identify which architectural smells types tend to become more critical. The analysis of the correlation is Useful to study whether the criticality of a smell has an influence on how much it costs to remove it, and vice-versa. © 2021 Copyright for this paper by its authors. Use permitted under Creative Commons License Attribution 4.0 International (CC BY 4.0).",Use,"Ilaria Pigazzini
Davide Foppiani
Francesca Arcelli Fontana",Academia,"2,021.00"," 1st International Workshop on Mining Software
Repositories for Software Architectur",Workshop,,"@inproceedings{DBLP:conf/ecsa/PigazziniFF21,
  author    = {Ilaria Pigazzini and
               Davide Foppiani and
               Francesca Arcelli Fontana},
  editor    = {Robert Heinrich and
               Raffaela Mirandola and
               Danny Weyns},
  title     = {Two Different Facets of Architectural Smells Criticality: An Empirical
               Study},
  booktitle = {{ECSA} 2021 Companion Volume, Virtual (originally: V{\""{a}}xj{\""{o}},
               Sweden), 13-17 September, 2021},
  series    = {{CEUR} Workshop Proceedings},
  volume    = {2978},
  publisher = {CEUR-WS.org},
  year      = {2021},
  url       = {http://ceur-ws.org/Vol-2978/msr4sa-paper2.pdf},
  timestamp = {Mon, 25 Oct 2021 15:03:56 +0200},
  biburl    = {https://dblp.org/rec/conf/ecsa/PigazziniFF21.bib},
  bibsource = {dblp computer science bibliography, https://dblp.org}
}","In order to evaluate the criticality of AS, in this paper we consider two facets: the PageRank metric, to assess the centrality of a smell in a project, and Severity, a metric to estimate the cost-solving of smells.",Arcan
156,S157,A DQN-based agent for automatic software refactoring,"Context: Nowadays, technical debt has become a very important issue in software project management. The main mechanism to repay this debt is through refactoring. Refactoring software projects usually comes at a high cost. As a result, researchers have always looked for ways to minimize this cost, and a good potential candidate to reduce the cost of a process is to automate it. Objective: One of the automatic software refactoring methods that recently has received a lot of attention is based on search-based software engineering (SBSE) methods. Although becaUse of comprehensiveness and versatility SBSE is considered an appropriate method for automatic refactoring, it has its downsides, the most important of which are the uncertainty of the results and the exponential execution time. Method: In this research, a solution is Proposed inspired by search-based refactoring while taking advantage of exploitation in reinforcement learning techniques. This work aims to solve the uncertainty problems and execution time for large programs. In the Proposed approach, the problem of uncertainty is solved by targeting the selection of refactoring actions Used in the search-based approach. Also, due to the reduction of the dependency between the choice of the appropriate refactoring and its execution time, the time problem in large software refactoring has been greatly improved. Results: Amongst the performed evaluations and specifically for the refactoring of the largest case study, the Proposed approach managed to increase the accuracy to more than twice of the SBSE refactoring approaches, while reducing the execution time of refactoring by more than 98%. Conclusion: The results of the tests show that with increasing the volume and size of the software, the performance of the Proposed approach also improves Compared to the methods based on SBSE, both in terms of reducing technical debt and speeding up the refactoring process. © 2022",Propose,"Hamidreza Ahmadi
Mehrdad Ashtiani
Mohammad Abdollahi Azgomi
Raana Saheb-Nassagh",Academia,"2,022.00",Information and Software Technology,Journal,https://doi.org/10.1016/j.infsof.2022.106893,"@article{Ahmadi2022,
title = {A DQN-based agent for automatic software refactoring},
journal = {Information and Software Technology},
volume = {147},
pages = {106893},
year = {2022},
issn = {0950-5849},
doi = {https://doi.org/10.1016/j.infsof.2022.106893},
url = {https://www.sciencedirect.com/science/article/pii/S0950584922000556},
author = {Hamidreza Ahmadi and Mehrdad Ashtiani and Mohammad Abdollahi Azgomi and Raana Saheb-Nassagh},
keywords = {Software refactoring, Design patterns, Technical debt, Software metrics, Reinforcement learning}}","In this research, a solution is Proposed inspired by search-based refactoring while taking advantage of exploitation in reinforcement learning techniques. In the Proposed approach, the problem of uncertainty is solved by targeting the selection of refactoring actions Used in the search-based approach. Also, due to the reduction of the dependency between the choice of the appropriate refactoring and its execution time, the time problem in large software refactoring has been greatly improved.","A-CMA
A-CMA DQN"
157,S158,DebtFree: minimizing labeling cost in self-admitted technical debt identification using semi-supervised learning,"Keeping track of and managing Self-Admitted Technical Debts (SATDs) is important for maintaining a healthy software project. Current active-learning SATD recognition tool involves manual inspection of 24% of the test comments on average to reach 90% of the recall. Among all the test comments, about 5% are SATDs. The human experts are then required to read almost a quintuple of the SATD comments which indicates the inefficiency of the tool. Plus, human experts are still prone to error: 95% of the false-positive labels from previous work were actually true positives. To solve the above problems, we Propose DebtFree, a two-mode framework based on unsupervised learning for identifying SATDs. In mode1, when the existing training data is unlabeled, DebtFree starts with an unsupervised learner to automatically pseudo-label the programming comments in the training data. In contrast, in mode2 where labels are available with the corresponding training data, DebtFree starts with a pre-processor that identifies the highly prone SATDs from the test dataset. Then, our machine learning model is employed to assist human experts in manually identifying the remaining SATDs. Our experiments on 10 software projects show that both models yield statistically significant improvement in effectiveness over the state-of-the-art automated and semi-automated models. Specifically, DebtFree can reduce the labeling effort by 99% in mode1 (unlabeled training data), and up to 63% in mode2 (labeled training data) while improving the current active learner’s F1 relatively to almost 100%. © 2022, The Author(s), under exclusive licence to Springer Science+Business Media, LLC, part of Springer Nature.",Propose,"Huy Tu
Tim Menzies",Academia,"2,022.00",Empirical Software Engineering,Journal,https://doi.org/10.1007/s10664-022-10121-w,"@article{Tu2022,
  author    = {Huy Tu and
               Tim Menzies},
  title     = {DebtFree: Minimizing Labeling Cost in Self-Admitted Technical Debt
               Identification using Semi-Supervised Learning},
  journal   = {CoRR},
  volume    = {abs/2201.10592},
  year      = {2022},
  url       = {https://arxiv.org/abs/2201.10592},
  eprinttype = {arXiv},
  eprint    = {2201.10592},
  timestamp = {Tue, 01 Feb 2022 14:59:01 +0100},
  biburl    = {https://dblp.org/rec/journals/corr/abs-2201-10592.bib},
  bibsource = {dblp computer science bibliography, https://dblp.org}
}","To solve the above problems, we Propose DebtFree, a two-mode framework based on unsupervised learning for identifying SATDs. In mode1, when the existing training data is unlabeled, DebtFree starts with an unsupervised learner to automatically pseudo-label the programming comments in the training data. In contrast, in mode2 where labels are available with the corresponding training data, Debt Free starts with a pre-processor that identifies the highly prone SATDs from the test dataset.",DebtFree
158,S159,Empirical evaluation of an architectural technical debt index in the context of the Apache and ONAP ecosystems,"Background. Architectural Technical Debt (ATD) in a software-intensive system denotes architectural design choices which, while being suitable or even optimal when adopted, lower the maintainability and evolvability of the system in the long term, hindering future development activities. Despite the growing research interest in ATD, how to gain an informative and encompassing viewCite of the ATD present in a software-intensive system is still an open problem. Objective. In this study, we evaluate ATDx, a data-driven approach providing an overview of the ATD present in a software-intensive system. The approach, based on the analysis of a software portfolio, calculates severity levels of architectural rule violations via a clustering algorithm, and aggregates results into different ATD dimensions. Method. To evaluate ATDx, we implement an instance of the approach based on SonarQube, and run the analysis on the Apache and ONAP ecosystems. The analysis results are then shared with the portfolio contributors, who are invited to participate in an online survey designed to evaluate the representativeness and actionability of the approach. Results. The survey results confirm the representativeness of the ATDx, in terms of both the ATDx analysis results and the Used architectural technical debt dimensions. Results also showed the actionability of the approach, although to a lower extent when Compared to the ATDx representativeness, with usage scenarios including refactoring, code review, communication, and ATD evolution analysis. Conclusions. With ATDx, we strive for the establishment of a sound, comprehensive, and intuitive architectural view of the ATD identifiable via source code analysis. The collected results are promising, and display both the representativeness and actionability of the approach. As future work, we plan to consolidate the approach via further empirical experimentation, by considering other development contexts (e.g., proprietary portfolios and other source code analysis tools), and enhancing the ATDx report capabilities. Copyright 2022 Verdecchia et al.",Use,"Roberto Verdecchia
Ivano Malavolta
Patricia Lago
Ipek Ozkaya",Academia,"2,022.00",PeerJ Computer Science,Journal,https://doi.org/10.7717/peerj-cs.833,"@article{10.7717/peerj-cs.833,
 title = {Empirical evaluation of an architectural technical debt index in the context of the Apache and ONAP ecosystems},
 author = {Verdecchia, Roberto and Malavolta, Ivano and Lago, Patricia and Ozkaya, Ipek},
 year = 2022,
 month = feb,
 keywords = {Technical debt, Software architecture, Index, Software metrics, Software portfolio analysis, Empirical evaluation},
 volume = 8,
 pages = {e833},
 journal = {PeerJ Computer Science},
 issn = {2376-5992},
 url = {https://doi.org/10.7717/peerj-cs.833},
 doi = {10.7717/peerj-cs.833}
}",,"ATDx
SonarQube"
159,S160,Detection of Design Smells Using Adaptive Neuro-Fuzzy Approaches,"Software evolution, an integral part of the software development process, encompasses frequent and numerous changes and updates that may lead to complex and poor-quality systems. Software engineers and quality practitioners continually refactor the software components to mitigate the negative effects of code and design smells. Although these smells are not directly connected to design and coding bugs, they are high indicators of technical debt that may arise as bugs in future software releases. Therefore, refactoring plays a significant role in the overall software evolution process. To fix the underlying code and design smells, they must be first detected and classified. As code smells have been the focus of research in the literature, this paper focUses on detecting design smells. A novel design smell detection scheme is Proposed using adaptive neuro-fuzzy approaches. This scheme can be seamlessly integrated with any refactoring scheduling and prioritization models as it is efficiently designed using a fast-training scheme based on a neuro-fuzzy architecture. In addition, the design smell detection solution relies on a reduced set of software metrics. A large custom dataset with more than 30,000 class records is created to assess the performance of the design smell detection solution. The reported performance scores confirm the superiority of the Proposed technique over the existing ones. The accuracy, precision, recall, and area-under-the-curve (AUC) scores attained 0.97, 0.98, 0.98, and 0.99, respectively. Thanks to the high detection scores, design smell refactoring sequencing and prioritization routines can be further enhanced. © 2022, The Author(s) under exclusive licence to Taiwan Fuzzy Systems Association.",Propose,"Amjad AbuHassan
Mohammad Alshayeb
Lahouari Ghouti",Academia,"2,022.00",International Journal of Fuzzy Systems,Journal,https://doi.org/10.1007/s40815-022-01248-5,"@ARTICLE{AbuHassan2022-ds,
  title     = ""Detection of design smells using adaptive neuro-fuzzy approaches"",
  author    = ""AbuHassan, Amjad and Alshayeb, Mohammad and Ghouti, Lahouari"",
  journal   = ""Int. J. Fuzzy Syst."",
  publisher = ""Springer Science and Business Media LLC"",
  month     =  feb,
  year      =  2022,
  language  = ""en""
}
","To fix the underlying code and
design smells, they must be first detected and classified. As

code smells have been the focus of research in the litera-
ture, this paper focUses on detecting design smells. A novel

design smell detection scheme is Proposed using adaptive
neuro-fuzzy approaches.","Together
Designite"
160,S161,Crowdsmelling: A preliminary study on using collective knowledge in code smells detection,"Code smells are seen as major source of technical debt and, as such, should be detected and removed. However, researchers argue that the subjectiveness of the code smells detection process is a major hindrance to mitigate the problem of smells-infected code. This paper presents the results of a validation experiment for the Crowdsmelling approach Proposed earlier. The latter is based on supervised machine learning techniques, where the wisdom of the crowd (of software developers) is Used to collectively calibrate code smells detection algorithms, thereby lessening the subjectivity issue. In the context of three consecutive years of a Software Engineering course, a total “crowd” of around a hundred teams, with an average of three members each, classified the presence of 3 code smells (Long Method, God Class, and Feature Envy) in Java source code. These classifications were the basis of the oracles Used for training six machine learning algorithms. Over one hundred models were generated and evaluated to determine which machine learning algorithms had the best performance in detecting each of the aforementioned code smells. Good performances were obtained for God Class detection (ROC= 0.896 for Naive Bayes) and Long Method detection (ROC= 0.870 for AdaBoostM1), but much lower for Feature Envy (ROC= 0.570 for Random Forrest). The results suggest that Crowdsmelling is a feasible approach for the detection of code smells. Further validation experiments based on dynamic learning are required to a comprehensive coverage of code smells to increase external validity. © 2022, The Author(s), under exclusive licence to Springer Science+Business Media, LLC, part of Springer Nature.",Cite,"Jose Pereira dos Reis
Fernando Brito e Abreu
Glauco de Figueiredo Carneiro",Academia,"2,022.00",Empirical Software Engineering,Journal,https://doi.org/10.1007/s10664-021-10110-5,"@ARTICLE{Reis2022-em,
  title     = ""Crowdsmelling: A preliminary study on using collective knowledge
               in code smells detection"",
  author    = ""Reis, Jos{\'e} Pereira dos and Abreu, Fernando Brito e and
               Carneiro, Glauco de Figueiredo"",
  journal   = ""Empir. Softw. Eng."",
  publisher = ""Springer Science and Business Media LLC"",
  volume    =  27,
  number    =  3,
  month     =  may,
  year      =  2022,
  language  = ""en""
}","This paper
presents the results of a validation experiment for the Crowdsmelling approach Proposed
earlier.",JDeodorant
161,S162,Technical debt as an indicator of software security risk: a machine learning approach for software development enterprises,"Vulnerability prediction facilitates the development of secure software, as it enables the identification and mitigation of security risks early enough in the software development lifecycle. Although several factors have been studied for their ability to indicate software security risk, very limited attention has been given to technical debt (TD), despite its potential relevance to software security. To this end, in the present study, we investigate the ability of common TD indicators to indicate security risks in software products, both at project-level and at class-level of granularity. Our findings suggest that TD indicators may potentially act as security indicators as well. © 2020 Informa UK Limited, trading as Taylor & Francis Group.",Propose,"Miltiadis Siavvas
Dimitrios Tsoukalas
Marija Jankovic
Dionysios Kehagias
Dimitrios Tzovaras",Academia,"2,022.00",ENTERPRISE INFORMATION SYSTEMS,Journal,https://doi.org/10.1080/17517575.2020.1824017,"@ARTICLE{Siavvas2022-wk,
  title     = ""Technical debt as an indicator of software security risk: a
               machine learning approach for software development enterprises"",
  author    = ""Siavvas, Miltiadis and Tsoukalas, Dimitrios and Jankovic, Marija
               and Kehagias, Dionysios and Tzovaras, Dimitrios"",
  journal   = ""Enterp. Inf. Syst."",
  publisher = ""Informa UK Limited"",
  volume    =  16,
  number    =  5,
  pages     = ""1--43"",
  month     =  may,
  year      =  2022,
  language  = ""en""
}
","To this
end, in the present study, we investigate the ability of common TD
indicators to indicate security risks in software products, both at
project-level and at class-level of granularity.","SonarQube
FindBugs
PMD"
162,S163,Identifying Self-Admitted Technical Debts With Jitterbug: A Two-Step Approach,"Keeping track of and managing Self-Admitted Technical Debts (SATDs) are important to maintaining a healthy software project. This requires much time and effort from human experts to identify the SATDs manually. The current automated solutions do not have satisfactory precision and recall in identifying SATDs to fully automate the process. To solve the above problems, we Propose a two-step framework called Jitterbug for identifying SATDs. Jitterbug first identifies the 'easy to find' SATDs automatically with close to 100 percent precision using a novel pattern recognition technique. Subsequently, machine learning techniques are applied to assist human experts in manually identifying the remaining 'hard to find' SATDs with reduced human effort. Our simulation studies on ten software projects show that Jitterbug can identify SATDs more efficiently (with less human effort) than the prior state-of-the-art methods. © 1976-2012 IEEE.",Use,Identifying Self-Admitted Technical Debts With Jitterbug: A Two-Step Approach,Academia,"2,022.00",IEEE TRANSACTIONS ON SOFTWARE ENGINEERING,Journal,http://doi.org/10.1109/TSE.2020.3031401,"@article{Yu_2022,
	doi = {10.1109/tse.2020.3031401},
	url = {https://doi.org/10.1109%2Ftse.2020.3031401},
	year = 2022,
	month = {may},
	publisher = {Institute of Electrical and Electronics Engineers ({IEEE})},
	volume = {48},
	number = {5},
	pages = {1676--1691},
	author = {Zhe Yu and Fahmid Morshed Fahid and Huy Tu and Tim Menzies},
	title = {Identifying Self-Admitted Technical Debts With Jitterbug: A Two-Step Approach},
	journal = {{IEEE} Transactions on Software Engineering}
}","To solve the above problems, we Propose a two-step framework called Jitterbug for identifying SATDs.",Jitterbug
163,S164,Towards a taxonomy of code review smells,"Context: Code review is a crucial step of the software development life cycle in order to detect possible problems in source code before merging the changeset to the codebase. Although there is no consensus on a formally defined life cycle of the code review process, many companies and open source software (OSS) communities converge on common rules and best practices. In spite of minor differences in different platforms, the primary purpose of all these rules and practices leads to a faster and more effective code review process. Non-conformance of developers to this process does not only reduce the advantages of the code review but can also introduce waste in later stages of the software development. Objectives: The aim of this study is to provide an empirical understanding of the bad practices followed in the code review process, that are code review (CR) smells. Methods: We first conduct a multivocal literature review in order to gather code review bad practices discussed in white and gray literature. Then, we conduct a targeted survey with 32 experienced software practitioners and perform follow-up interviews in order to get their expert opinion. Based on this process, a taxonomy of code review smells is introduced. To quantitatively demonstrate the existence of these smells, we analyze 226,292 code reviews collected from eight OSS projects. Results: We observe that a considerable number of code review smells exist in all projects with varying degrees of ratios. The empirical results illustrate that 72.2% of the code reviews among eight projects are affected by at least one code review smell. Conclusion: The empirical analysis shows that the OSS projects are substantially affected by the code review smells. The provided taxonomy could provide a foundation for best practices and tool support to detect and avoid code review smells in practice. © 2021",Use,"Emre Doğan
Eray Tüzün",Academia,"2,022.00",Information and Software Technology,Journal,https://doi.org/10.1016/j.infsof.2021.106737,"@article{Do_an_2022,
	doi = {10.1016/j.infsof.2021.106737},
	url = {https://doi.org/10.1016%2Fj.infsof.2021.106737},
	year = 2022,
	month = {feb},
	publisher = {Elsevier {BV}},
	volume = {142},
	pages = {106737},
	author = {Emre Do{\u{g}}an and Eray Tüzün},
	title = {Towards a taxonomy of code review smells},
	journal = {Information and Software Technology}
}","The aim of this study is to provide an empirical understanding of the bad practices followed in the code review process, that are code review (CR) smells.",Not Cited
164,S165,The Known Unknowns: Discovering Trade-Offs Between Heterogeneous Code Changes,"Software projects must adhere to a variety of non-functional requirements, also known as software qualities. Automated evaluation with respect to such requirements can be conducted thanks to a wide array of available tools. Each tool usually focUses on a specific quality, since heterogeneous analyses are needed for each non-functional requirement. Apart from an overall index expressing the project’s performance in terms of the software quality they specialize on, many tools recommend code changes that are expected to improve the aforementioned index. Thus, a development team that cares for more than one non-functional requirement is facing the problem of unknown trade-offs; besides improving the quality on which the tool that generated each suggestion focUses, how would this code change, if implemented, affect the rest of the non-functional requirements? We present a framework for dealing with this problem. We pick energy efficiency, technical debt and software security as our qualities of interest, and Use three respective tools for the analysis of several open-source projects with regard to these qualities. We develop an extensible empirical model, based on fuzzy sets, for the characterization of each suggestion’s trade-offs. Finally, we present an intuitive visualization of said trade-offs, and suggest a method of utilizing them towards reliable decision-making. © 2022, Springer Nature Switzerland AG.",Use,"Christos P. Lamprakos
Charalampos Marantos
Lazaros Papadopoulos
Dimitrios Soudris",Academia,"2,022.00",International Conference on Embedded Computer Systems,Conference,https://doi.org/10.1007/978-3-031-04580-6_23,"@incollection{Lamprakos_2022,
	doi = {10.1007/978-3-031-04580-6_23},
	url = {https://doi.org/10.1007%2F978-3-031-04580-6_23},
	year = 2022,
	publisher = {Springer International Publishing},
	pages = {342--353},
	author = {Christos P. Lamprakos and Charalampos Marantos and Lazaros Papadopoulos and Dimitrios Soudris},
	title = {The Known Unknowns: Discovering Trade-Offs Between Heterogeneous Code Changes},
	booktitle = {Lecture Notes in Computer Science}
}","We develop an extensible empirical model, based on fuzzy sets, for the characterization of each suggestion’s trade-offs. Finally, we present an intuitive visualization of said trade-offs, and suggest a method of utilizing them towards reliable decision-making.",SDK4ED
165,S166,Exploring the relationship between refactoring and code debt indicators,"Refactoring, which aims to improve the internal structure of the software systems preserving their behavior, is the most common payment strategy for technical debt (TD) by removing the code smells. There exist many studies presenting code smell detection approaches/tools or investigating their impact on quality attributes. There are also studies that focus on refactoring techniques, their relation with quality attributes, tool supports, and opportunities for them. Although there are several studies addressing the gap between refactoring and TD indicators, the empirical evidence provided is still limited. In this study, we examine the distribution of 29 refactoring types among the different projects and their relation with code smells or faults. We explore the refactoring types that are most commonly performed together and other activities performed with refactorings. We conduct a large exploratory study with automatically detected 57,528 refactorings, 37,553 smells, 27,340 faults, and 134,812 commits of 33 Java projects. Results show that some refactoring types are more commonly applied by developers. Our analysis indicates that refactorings usually remove or do not affect the code smells, and this contradicts with the previous studies. Also, the commits in which refactoring(s) is performed are three times more fault inducing than those without refactoring. © 2022 John Wiley & Sons, Ltd.",Use,"RUsen Halepmollasi
Ayse Tosun",Academia,"2,022.00",Journal Of Software: Process and Evolution,Journal,https://doi.org/10.1002/smr.2447,"@article{Halepmollasi_2022,
	doi = {10.1002/smr.2447},
	url = {https://doi.org/10.1002%2Fsmr.2447},
	year = 2022,
	month = {mar},
	publisher = {Wiley},
	author = {RUsen Halepmollasi and Ayse Tosun},
	title = {Exploring the relationship between refactoring and code debt indicators},
	journal = {Journal of Software: Evolution and Process}
}","In this study, we examine the distribution of 29 refactoring types among the different projects and their relation with code smells or faults. We explore the refactoring types that are most commonly performed together and other activities performed with refactorings.","Ptidej
Open SZZ
Rminer
SonarQube"
166,S167,Can Clean New Code Reduce Technical Debt Density?,"While technical debt grows in absolute numbers as software systems evolve over time, the density of technical debt (technical debt divided by lines of code) is reduced in some cases. This can be explained by either the application of refactorings or the development of new artifacts with limited Technical Debt. In this paper we explore the second explanation, by investigating the relation between the amount of Technical Debt in new code and the evolution of Technical Debt in the system. To this end, we Compare the Technical Debt Density of new code with existing code, and we investigate which of the three major types of code changes (additions, deletions and modifications) is primarily responsible for changes in the evolution of Technical Debt density. Furthermore, we study whether there is a relation between code quality practices and the 'cleanness' of new code. To obtain the required data, we have performed a large-scale case study on twenty-seven open-source software projects by the Apache Software Foundation, analyzing 66,661 classes and 56,890 commits. The results suggest that writing 'clean' (or at least 'cleaner') new code can be an efficient strategy for reducing Technical Debt Density, and thus preventing software decay over time. The findings also suggest that projects adopting an explicit policy for quality improvement, e.g., through discussions on code quality in board meetings, are associated with a higher frequency of cleaner new code commits. Therefore, we champion the establishment of processes that monitor the density of Technical Debt of new code to control the accumulation of Technical Debt in a software system. © 1976-2012 IEEE.",Use,"George Digkas
Alexander Chatzigeorgiou
Apostolos Ampatzoglou
Paris Avgeriou",Academia,"2,022.00",IEEE TRANSACTIONS ON SOFTWARE ENGINEERING,Journal,http://doi.org/10.1109/TSE.2020.3032557,"@article{Digkas_2022,
	doi = {10.1109/tse.2020.3032557},
	url = {https://doi.org/10.1109%2Ftse.2020.3032557},
	year = 2022,
	month = {may},
	publisher = {Institute of Electrical and Electronics Engineers ({IEEE})},
	volume = {48},
	number = {5},
	pages = {1705--1721},
	author = {George Digkas and Alexander Chatzigeorgiou and Apostolos Ampatzoglou and Paris Avgeriou},
	title = {Can Clean New Code Reduce Technical Debt Density?},
	journal = {{IEEE} Transactions on Software Engineering}
}","In this paper we explore the second explanation, by investigating the relation between the amount of Technical Debt in new code and the evolution of Technical Debt in the system. To this end, we Compare the Technical Debt Density of new code with existing code, and we investigate which of the three major types of code changes (additions, deletions and modifications) is primarily responsible for changes in the evolution of Technical Debt density.",SonarQube
167,S168,Further investigation of the survivability of code technical debt items,"Context: Technical debt (TD) discusses the negative impact of sub-optimal decisions to cope with the need-for-speed in software development. Code technical debt items (TDI) are atomic elements of TD that can be observed in code artifacts. Empirical results on open-source systems demonstrated how code-smells, which are just one type of TDIs, are introduced and “survive” during release cycles. However, little is known about whether the results on the survivability of code-smells hold for other types of code TDIs (i.e., bugs and vulnerabilities) and in industrial settings. Goal: Understanding the survivability of code TDIs by conducting an empirical study analyzing two industrial cases and 31 open-source systems from Apache Foundation. Method: We analyzed 133,670 code TDIs (35,703 from the industrial systems) detected by SonarQube (in 193,196 commits) to assess their survivability using survivability models. Results: In general, code TDIs tend to remain and linger for long periods in open-source systems, whereas they are removed faster in industrial systems. Code TDIs that survive over a certain threshold tend to remain much longer, which confirms previous results. Our results also suggest that bugs tend to be removed faster, while code smells and vulnerabilities tend to survive longer. © 2022 The Authors. Journal of Software: Evolution and Process published by John Wiley & Sons Ltd.",Use,"Ehsan Zabardast
Kwabena Ebo Bennin
Javier Gonzalez-Huerta",Academia,"2,022.00",Journal of Software: Evolution and Process,Journal,http://doi.org/10.1002/smr.2425,"@article{Zabardast_2022,
	doi = {10.1002/smr.2425},
	url = {https://doi.org/10.1002%2Fsmr.2425},
	year = 2022,
	month = {jan},
	publisher = {Wiley},
	volume = {34},
	number = {2},
	author = {Ehsan Zabardast and Kwabena Ebo Bennin and Javier Gonzalez-Huerta},
	title = {Further investigation of the survivability of code technical debt items},
	journal = {Journal of Software: Evolution and Process}
}","Understanding the survivability of code TDIs by conducting an empirical study analyzing two industrial cases and 31 open-source systems from Apache Foundation. Method: We analyzed 133,670 code TDIs (35,703 from the industrial systems) detected by SonarQube (in 193,196 commits) to assess their survivability using survivability models.","SonarQube
Codacy
PMD
<Code from authors>"
168,S169,"A framework for conditional statement technical debt identifcation and description
","Technical Debt occurs when development teams favour short-term operability over long-term stability. Since this places software maintainability at risk, technical debt requires early attention to avoid paying for accumulated interest. Most of the existing work focUses on detecting technical debt using code comments, known as Self-Admitted Technical Debt (SATD). However, there are many cases where technical debt instances are not explicitly acknowledged but deeply hidden in the code. In this paper, we Propose a framework that caters for the absence of SATD comments in code. Our Self-Admitted Technical Debt Identification and Description (SATDID) framework determines if technical debt should be self-admitted for an input code fragment. If that is the case, SATDID will automatically generate the appropriate descriptive SATD comment that can be attached with the code. While our approach is applicable in principle to any type of code fragments, we focus in this study on technical debt hidden in conditional statements, one of the most TD-carrying parts of code. We explore and evaluate different implementations of SATDID. The evaluation results demonstrate the applicability and effectiveness of our framework over multiple benchmarks. Comparing with the results from the benchmarks, our approach provides at least 21.35, 59.36, 31.78, and 583.33% improvements in terms of Precision, Recall, F-1, and Bleu-4 scores, respectively. In addition, we conduct a human evaluation to the SATD comments generated by SATDID. In 1-5 and 0–5 scales for Acceptability and Understandability, the total means achieved by our approach are 3.128 and 3.172, respectively.",Propose,,Academia,"2,022.00",Automated Software Engineering,Journal,,"@article{Alhefdhi_2022,
	doi = {10.1007/s10515-022-00364-8},
	url = {https://doi.org/10.1007%2Fs10515-022-00364-8},
	year = 2022,
	month = {oct},
	publisher = {Springer Science and Business Media {LLC}},
	volume = {29},
	number = {2},
	author = {Abdulaziz Alhefdhi and Hoa Khanh Dam and Yusuf Sulistyo Nugroho and Hideaki Hata and Takashi Ishio and Aditya Ghose},
	title = {A framework for conditional statement technical debt identification and description},
	journal = {Automated Software Engineering}
}
",,
169,S170,BreakBot: Analyzing the Impact of Breaking Changes to Assist Library Evolution,"If we make this change to our code, how will it impact our clients?"" It is difficult for library maintainers to answer this simple-yet essential!-question when evolving their libraries. Library maintainers are constantly balancing between two opposing positions: make changes at the risk of breaking some of their clients, or avoid changes and maintain compatibility at the cost of immobility and growing technical debt. We argue that the lack of objective usage data and tool support leaves maintainers with their own subjective perception of their community to make these decisions. We introduce BreakBot, a bot that analyses the pull requests of Java libraries on GitHub to identify the breaking changes they introduce and their impact on client projects. Through static analysis of libraries and clients, it extracts and summarizes objective data that enrich the code review process by providing maintainers with the appropriate information to decide whether-and how-changes should be accepted, directly in the pull requests.",Propose,,Academia,"2,022.00",International Conference on Software Engineering,Conference,,"@inproceedings{10.1145/3510455.3512783,
author = {Ochoa, Lina and Degueule, Thomas and Falleri, Jean-R\'{e}my},
title = {BreakBot: Analyzing the Impact of Breaking Changes to Assist Library Evolution},
year = {2022},
isbn = {9781450392242},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3510455.3512783},
doi = {10.1145/3510455.3512783},
booktitle = {Proceedings of the ACM/IEEE 44th International Conference on Software Engineering: New Ideas and Emerging Results},
pages = {26–30},
numpages = {5},
location = {Pittsburgh, Pennsylvania},
series = {ICSE-NIER '22}
}",,
170,S171,Characterizing and Mitigating Self-Admitted Technical Debt in Build Systems,"Technical Debt is a metaphor Used to describe the situation in which long-term software artifact quality is traded for short-term goals in software projects. In recent years, the concept of self-admitted technical debt (SATD) was Proposed, which focUses on debt that is intentionally introduced and described by developers. Although prior work has made important observations about admitted technical debt in source code, little is known about SATD in build systems. In this paper, we set out to better understand the characteristics of SATD in build systems. To do so, through a qualitative analysis of 500 SATD comments in the Maven build system of 291 projects, we characterize SATD by location and rationale (reason and purpose). Our results show that limitations in tools and libraries, and complexities of dependency management are the most frequent caUses, accounting for 50% and 24% of the comments. We also find that developers often document SATD as issues to be fixed later. As a first step towards the automatic detection of SATD rationale, we train classifiers to detect the two most frequently occurring reasons and the four most frequently occurring purposes of SATD in the content of comments in Maven build systems. The classifier performance is promising, achieving an F1-score of 0.71-0.79. Finally, within 16 identified 'ready-to-be-addressed' SATD instances, the three SATD submitted by pull requests and the five SATD submitted by issue reports were resolved after developers were made aware. Our work presents the first step towards understanding technical debt in build systems and opens up avenues for future work, such as tool support to track and manage SATD backlogs.",Propose,,Academia,"2,022.00",IEEE TRANSACTIONS ON SOFTWARE ENGINEERING,Journal,,"@article{Xiao_2022,
	doi = {10.1109/tse.2021.3115772},
	url = {https://doi.org/10.1109%2Ftse.2021.3115772},
	year = 2022,
	month = {oct},
	publisher = {Institute of Electrical and Electronics Engineers ({IEEE})},
	volume = {48},
	number = {10},
	pages = {4214--4228},
	author = {Tao Xiao and Dong Wang and Shane McIntosh and Hideaki Hata and Raula Gaikovina Kula and Takashi Ishio and Kenichi Matsumoto},
	title = {Characterizing and Mitigating Self-Admitted Technical Debt in Build Systems},
	journal = {{IEEE} Transactions on Software Engineering}
}
",,
171,S172,Comparing Univariate and Multivariate Time Series Models for Technical Debt Forecasting,"Technical debt (TD) is a successful and widely Used metaphor that expresses the quality compromises that can yield short-term benefits but may negatively affect the overall quality of a software product in the long run. There is a vast variety of techniques and methodologies that have been Proposed over the past years to enable the identification and estimation of TD during the software development cycle. However, it is only until recently that researchers have turned towards the investigation of methods that focus on forecasting its future evolution. Getting insights on the future evolution of TD can enable on-time decision-making and allow stakeholders to plan preventive strategies regarding TD repayment. In our previous studies, we have investigated time series analysis and Machine Learning techniques in order to produce reliable TD forecasts. In our current attempt, we aim to explore the capabilities of a statistical ARIMA model both in a univariate and a multivariate fashion. More specifically, the present paper investigates whether the adoption of an ARIMA model that takes into account, in addition to the TD value itself, various TD-related indicators may lead to more accurate TD predictions than its univariate alternative. For this purpose, dedicated models are constructed, evaluated, and Compared on a dataset of five long-lived, open-source software applications.",Compare,,Academia,"2,022.00",International Conference on Computational Science and Its Applications,Conference,,"@InProceedings{10.1007/978-3-031-10542-5_5,
author=""Mathioudaki, Maria
and Tsoukalas, Dimitrios
and Siavvas, Miltiadis
and Kehagias, Dionysios"",
editor=""Gervasi, Osvaldo
and Murgante, Beniamino
and Misra, Sanjay
and Rocha, Ana Maria A. C.
and Garau, Chiara"",
title=""Comparing Univariate and Multivariate Time Series Models for Technical Debt Forecasting"",
booktitle=""Computational Science and Its Applications -- ICCSA 2022 Workshops"",
year=""2022"",
publisher=""Springer International Publishing"",
address=""Cham"",
pages=""62--78"",
isbn=""978-3-031-10542-5""
}
",,
172,S173,On the Adoption of a TODO Bot on GitHub: A Preliminary Study,"Bots support different software maintenance and evolution activities, such as code review or executing tests. Recently, several bots have been Proposed to help developers to keep track of postponed activities, expressed by means of TODO comments: e.g., TODO Bot automatically creates a GITHuB issue when a TODO comment is added to a repository, increasing visibility of TODO comments. In this work, we perform a preliminary evaluation of the impact of the TODO Bot on software development practice. We conjecture that the introduction of the TODO Bot would facilitate keeping track of the TODO comments, and hence encourage developers to Use more TODO comments in their code changes. To evaluate this conjecture, we analyze all the 2,208 repositories which have at least one GITHuB issue created by the TODO Bot. Firstly, we investigate to what extent the bot is being Used and describe the repositories using the bot. We observe that the majority (54%) of the repositories which adopted the TODO Bot are new, i.e., were created within less than one month of first issue created by the bot, and from those, more than 60% have the issue created within three days. We observe a statistically significant increase in the number of the TODO comments after the adoption of the bot, however with a small effect size. Our results suggest that the adoption of the TODO Bot encourages developers to introduce TODO comments rendering the postponed decisions more visible. Nevertheless, it does not speed up the process of addressing TODO comments or corresponding GITHuB issues.",Cite,,Academia,"2,022.00","International Workshop on
Bots in Software Engineering",Conference,,"@inproceedings{10.1145/3528228.3528408,
author = {Mohayeji, Hamid and Ebert, Felipe and Arts, Eric and Constantinou, Eleni and Serebrenik, Alexander},
title = {On the Adoption of a TODO Bot on GitHub: A Preliminary Study},
year = {2022},
isbn = {9781450393331},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3528228.3528408},
doi = {10.1145/3528228.3528408},
booktitle = {Proceedings of the Fourth International Workshop on Bots in Software Engineering},
pages = {23–27},
numpages = {5},
keywords = {bots, TODO, technical debt, code comments},
location = {Pittsburgh, Pennsylvania},
series = {BotSE '22}
}",,
173,S174,Self-admitted technical debt detection by learning its comprehensive semantics via graph neural networks,"The goal of software development is to deliver software products with high quality and free from defects, but resource and time constraints often caUse the developers to submit incomplete or temporary patches of codes and further bear the additional burden. Therefore, the investigations on identifying self-admitted technical debt (SATD) to improve code quality have been conducted in recent years. However, missing syntactic structure information and the imbalance distribution bias shorten the SATD identification performance. Addressing to this issue, we present a graph neural network based SATD identification model (GNNSI) to improve the performance. Specifically, we obtain the structure information of the missing SATD in a compositional way to obtain different feature maps for different comments, and Use focal loss to handle the imbalance between SATD and non-SATD classes in the comments. Then extensive experiments on 10 open source projects are conducted, and the results show that GNNSI outperforms the baselines and can help developers to better predict SATDs.
",Propose,,Academia,"2,022.00",Journal of Software: Practice and Experience,Journal,,"@article{Li_2022,
        doi = {10.1002/spe.3117},
        url = {https://doi.org/10.1002%2Fspe.3117},
        year = 2022,
        month = {jun},
        publisher = {Wiley},
        volume = {52},
        number = {10},
        pages = {2152--2176},
        author = {Hui Li and Yang Qu and Yong Liu and Rong Chen and Jun Ai and Shikai Guo},
        title = {Self-admitted technical debt detection by learning its comprehensive semantics via graph neural networks},
        journal = {Software: Practice and Experience}
}
",,
174,S175,Sonarlizer Xplorer: a tool to mine Github projects and identify technical debt items using SonarQube,"The advancement of artificial intelligence and the imple-mentation of machine learning capabilities in programming languages such as Python, along with cloud services, allow researchers to apply methods to cluster and predict behav-iors and patterns in software engineering data. On the other hand, these methods need a large amount of data in order to work with high accuracy in different contexts. This paper introduces Sonarlizer Xplorer: a tool that captures a large number of technical debt items and code metrics from pub-lic GitHub projects. Sonarlizer Xplorer is composed of two sub-tools. The first is Github Xplorer, responsible for mining public Github repositories from an initial project. The second is Sonarlizer, responsible for taking projects and analyzing them using SonarQube. We Used the tool over four months, collecting technical debt items and code metrics on almost 46,000 public Java projects. In addition, we mined over 57 million repositories and 4 million Users.",Propose,,Academia,"2,022.00",International Conference on Technical Debt,Conference,,"@INPROCEEDINGS{9804475,  author={Pina, Diogo and Goldman, Alfredo and Seaman, Carolyn},  booktitle={2022 IEEE/ACM International Conference on Technical Debt (TechDebt)},   title={Sonarlizer Xplorer: a tool to mine Github projects and identify technical debt items using SonarQube},   year={2022},  volume={},  number={},  pages={71-75},  doi={10.1145/3524843.3528098}}",,
175,S176,Merging Smell Detectors: Evidence on the Agreement of Multiple Tools,"Technical Debt estimation relies heavily on the Use of static anal-ysis tools looking for violations of pre-defined rules. Largely, Technical Debt principal is attributed to the presence of low-level code smells, unavoidably tying the effort for fixing the problems with mere coding inefficiencies. At the same time, despite their simple definition, the detection of most code smells is non-trivial and subjective, rendering the assessment of Technical Debt prin-cipal dubious. To this end, we have revisited the literature on code smell detection approaches backed by tools and developed an Eclipse plugin that incorporates six code smell detection ap-proaches. The combined application of various smell detectors can increase the certainty of identifying actual code smells that matter to the development team. We also conduct a case study to investigate the agreement among the employed code smell detec-tors. To our surprise the level of agreement is quite low even for relatively simple code smells, threating the validity of existing TD analysis tools and calling for increased attention to the precise specification of code and design level issues. Source code: https://github.com/apostolisich/SmellDetectorMerger",Compare,,Academia,"2,022.00",International Conference on Technical Debt,Conference,,"@INPROCEEDINGS{9804506,  author={Ichtsis, Apostolos and Mittas, Nikolaos and Ampatzoglou, Apostolos and Chatzigeorgiou, Alexander},  booktitle={2022 IEEE/ACM International Conference on Technical Debt (TechDebt)},   title={Merging Smell Detectors: Evidence on the Agreement of Multiple Tools},   year={2022},  volume={},  number={},  pages={61-65},  doi={10.1145/3524843.3528089}}",,
176,S177,TD Classifier: Automatic Identification of Java Classes with High Technical Debt,"To date, the identification and quantification of Technical Debt (TD) rely heavily on a few sophisticated tools that check for violations of certain predefined rules, usually through static analysis. Different tools result in divergent TD estimates calling into question the reliability of findings derived by a single tool. To alleviate this issue, we present a tool that employs machine learning on a dataset built upon the convergence of three widely-adopted TD Assessment tools to automatically assess the class-level TD for any arbitrary Java project. The Proposed tool is able to classify software classes as high-TD or not, by synthesizing source code and repository ac-tivity information retrieved by employing four popular open source analyzers. The classification results are combined with proper vi-sualization techniques, to enable the identification of classes that are more likely to be problematic. To demonstrate the Proposed tool and evaluate its Usefulness, a case study is conducted based on a real-world open-source software project. The Proposed tool is expected to facilitate TD management activities and enable fur-ther experimentation through its Use in an academic or industrial setting",Propose,,Academia,"2,022.00",International Conference on Technical Debt,Conference,,"@INPROCEEDINGS{9804507,  author={Tsoukalas, Dimitrios and Chatzigeorgiou, Alexander and Ampatzoglou, Apostolos and Mittas, Nikolaos and Kehagias, Dionysios},  booktitle={2022 IEEE/ACM International Conference on Technical Debt (TechDebt)},   title={TD Classifier: Automatic Identification of Java Classes with High Technical Debt},   year={2022},  volume={},  number={},  pages={76-80},  doi={10.1145/3524843.3528094}}",,
177,S178,"WeakSATD: Detecting Weak Self-admitted Technical Debt
","Speeding up development may produce technical debt, i.e., not-quite-right code for which the effort to make it right increases with time as a sort of interest. Developers may be aware of the debt as they admit it in their code comments. Literature reports that such a self-admitted technical debt survives for a long time in a program, but it is not yet clear its impact on the quality of the code in the long term. We argue that self-admitted technical debt contains a number of different weaknesses that may affect the security of a program. Therefore, the longer a debt is not paid back the higher is the risk that the weaknesses can be exploited. To discuss our claim and rise the developers' awareness of the vulnerability of the self-admitted technical debt that is not paid back, we explore the self-admitted technical debt in the Chromium C-code to detect any known weaknesses. In this preliminary study, we first mine the Common Weakness Enumeration repository to define heuristics for the automatic detection and fix of weak code. Then, we parse the C-code to find self-admitted technical debt and the code block it refers to. Finally, we Use the heuristics to find weak code snippets associated to self-admitted technical debt and recommend their potential mitigation to developers. Such knowledge can be Used to prioritize self-admitted technical debt for repair. A prototype has been developed and applied to the Chromium code. Initial findings report that 55\% of self-admitted technical debt code contains weak code of 14 different types.",Propose,,Academia,"2,022.00",International Conference on Mining Software Repositories,Conference,,"@INPROCEEDINGS {9796253,
author = {B. Russo and M. Camilli and M. Mock},
booktitle = {2022 IEEE/ACM 19th International Conference on Mining Software Repositories (MSR)},
title = {WeakSATD: Detecting Weak Self-admitted Technical Debt},
year = {2022},
volume = {},
issn = {},
pages = {448-453},
keywords = {codes;prototypes;chromium;maintenance engineering;software;security;data mining},
doi = {10.1145/3524842.3528469},
url = {https://doi.ieeecomputersociety.org/10.1145/3524842.3528469},
publisher = {IEEE Computer Society},
address = {Los Alamitos, CA, USA},
month = {may}
}",,